date,title,body,comment,text
2017-03-11,,"*1489193372*[F#]情報隠蔽とモジュールとシグネチャファイル (F# Advent Calendar 2016)

いまさらですが、2016年12月のF# Advent Calendar記事の締め切りに間に合わなかったこともあり、アクセス数が少ないので、ここで再紹介します。

[http://qiita.com/matarillo/items/8444db7b97abd29194c2:title]

シグネチャファイルを書くことで、型の実装を隠蔽する方法について書きました。

……といいつつ、記事のほとんどは、横浜へなちょこプログラミング勉強会さんによるコーディング問題
[http://nabetani.sakura.ne.jp/hena/orde09_penwa/:title]
の回答になっています。　^^

コードの説明というより、解法の説明が長いです。",,"*1489193372*[F#]情報隠蔽とモジュールとシグネチャファイル (F# Advent Calendar 2016)

いまさらですが、2016年12月のF# Advent Calendar記事の締め切りに間に合わなかったこともあり、アクセス数が少ないので、ここで再紹介します。

[http://qiita.com/matarillo/items/8444db7b97abd29194c2:title]

シグネチャファイルを書くことで、型の実装を隠蔽する方法について書きました。

……といいつつ、記事のほとんどは、横浜へなちょこプログラミング勉強会さんによるコーディング問題
[http://nabetani.sakura.ne.jp/hena/orde09_penwa/:title]
の回答になっています。　^^

コードの説明というより、解法の説明が長いです。"
2016-09-06,,"*1473173348*[F#]もしミスチルがF#だったら
>|ocaml|
love : 'Ego -> 'Ego -> seq<int> when 'Ego : comparison
||<

記念に。
",,"*1473173348*[F#]もしミスチルがF#だったら
>|ocaml|
love : 'Ego -> 'Ego -> seq<int> when 'Ego : comparison
||<

記念に。
"
2015-12-09,,"*1449583237*[F#]多相リテラルはないけど、演算子オーバーロードとユーザ定義型変換とカスタム数値リテラルとジェネリック単位元と

この記事は[http://connpass.com/event/22056/:title=F# Advent Calendar 2015]の9日目の記事です。

記事の発端は、id:m-hiyama さんの3つの記事です。

[http://d.hatena.ne.jp/m-hiyama/20151130/1448843034:title]
[http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title]
[http://d.hatena.ne.jp/m-hiyama/20151208/1449544751:title]

3行で無理やりまとめると

- ジェネリクスと演算子オーバーロードと型クラスが便利に使えたらいいなあ。
- C++には演算子オーバーロードがあるし、暗黙の型変換も便利だけど、ユーザー定義リテラルはいまいち。
- 空気を読んでくれる、多相的な定数（数値リテラル）や記号（演算子）があるともっといいのに。

2つ目の記事は、Min-Plus半環という、和と積の定義がちょっとおもしろい代数をネタにしています。

F# は

|ジェネリクス|ある|
|演算子オーバーロード|ある|
|型クラス|ない|
|ユーザー定義リテラル|ある|
|暗黙の型変換|ない(明示的にしかできない)|
|多相的な数値リテラル|ない|

なのだけど、Min-Plus半環のコードを書いてみたらどうなるの？というのをやってみました。

まずは、[http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title=m-hiyamaさんの2番目の記事]のコードを参考に

- 演算子オーバーロード
- ユーザー定義リテラル
- 明示的な型変換

を入れてみたのが、[http://haskell.g.hatena.ne.jp/matarillo/20151207:title=12/7の記事]に載せたコードです。ここに再掲します。

<script src=""https://gist.github.com/matarillo/7502d98b8d46f56b4546.js""></script>

次に、[http://d.hatena.ne.jp/m-hiyama/20151208/1449544751:title=m-hiyamaさんの3番目の記事]を参考にして、多相的な数値リテラルはないけれども演算子オーバーロードをたくさん作ってみたらどんな使い勝手になるかを試してみました。

<script src=""https://gist.github.com/matarillo/d9861bcce64b4b6ae4da.js""></script>

簡単に解説します。

- 演算子 <code>@+</code>と<code>@*</code>がMin-Plus半環のための演算子です。これは（<code>?&lt;-</code>演算子を使うハックによって）<code>int</code>型、<code>float</code>型、および<code>MinPlus</code>カスタム型を引数にとることができます。
-- なお、このハックについては、[http://haskell.g.hatena.ne.jp/matarillo/20150817/1439787013:title=この記事]から始まる5つのエントリーで解説していますので、興味がある人はそちらを読んでください。
- <code>main</code>関数では、シャドーイング機能を使って、<code>+</code>演算子と<code>*</code>演算子の実装を<code>@+</code>と<code>@*</code>に付け替えています。

ちなみに、<code>fstropical</code>モジュール（fstropical.fs）では、Min-Plus半環のための演算子として<code>@+</code>と<code>@*</code>を使っていますが、ここを<code>+</code>と<code>*</code>に置き換えることもできます。すると、<code>fstropical</code>モジュールをopenするだけで、ファイル全体で<code>+</code>演算子と<code>*</code>演算子の動きが置き換わります。

m-hiyamaさんは
>>
僕が名前（記号やリテラルも含む）のオーバーロードに拘るのは、名前の増加に耐えられないからです。
<<
と書いていましたから、<code>@+</code>と<code>@*</code>を使わないコードの方を好まれるかもしれませんね。

というわけで、「空気を読んでくれる演算子」ぐらいならF#でなんとか実現できそう、という感じでした。
",,"*1449583237*[F#]多相リテラルはないけど、演算子オーバーロードとユーザ定義型変換とカスタム数値リテラルとジェネリック単位元と

この記事は[http://connpass.com/event/22056/:title=F# Advent Calendar 2015]の9日目の記事です。

記事の発端は、id:m-hiyama さんの3つの記事です。

[http://d.hatena.ne.jp/m-hiyama/20151130/1448843034:title]
[http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title]
[http://d.hatena.ne.jp/m-hiyama/20151208/1449544751:title]

3行で無理やりまとめると

- ジェネリクスと演算子オーバーロードと型クラスが便利に使えたらいいなあ。
- C++には演算子オーバーロードがあるし、暗黙の型変換も便利だけど、ユーザー定義リテラルはいまいち。
- 空気を読んでくれる、多相的な定数（数値リテラル）や記号（演算子）があるともっといいのに。

2つ目の記事は、Min-Plus半環という、和と積の定義がちょっとおもしろい代数をネタにしています。

F# は

|ジェネリクス|ある|
|演算子オーバーロード|ある|
|型クラス|ない|
|ユーザー定義リテラル|ある|
|暗黙の型変換|ない(明示的にしかできない)|
|多相的な数値リテラル|ない|

なのだけど、Min-Plus半環のコードを書いてみたらどうなるの？というのをやってみました。

まずは、[http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title=m-hiyamaさんの2番目の記事]のコードを参考に

- 演算子オーバーロード
- ユーザー定義リテラル
- 明示的な型変換

を入れてみたのが、[http://haskell.g.hatena.ne.jp/matarillo/20151207:title=12/7の記事]に載せたコードです。ここに再掲します。

<script src=""https://gist.github.com/matarillo/7502d98b8d46f56b4546.js""></script>

次に、[http://d.hatena.ne.jp/m-hiyama/20151208/1449544751:title=m-hiyamaさんの3番目の記事]を参考にして、多相的な数値リテラルはないけれども演算子オーバーロードをたくさん作ってみたらどんな使い勝手になるかを試してみました。

<script src=""https://gist.github.com/matarillo/d9861bcce64b4b6ae4da.js""></script>

簡単に解説します。

- 演算子 <code>@+</code>と<code>@*</code>がMin-Plus半環のための演算子です。これは（<code>?&lt;-</code>演算子を使うハックによって）<code>int</code>型、<code>float</code>型、および<code>MinPlus</code>カスタム型を引数にとることができます。
-- なお、このハックについては、[http://haskell.g.hatena.ne.jp/matarillo/20150817/1439787013:title=この記事]から始まる5つのエントリーで解説していますので、興味がある人はそちらを読んでください。
- <code>main</code>関数では、シャドーイング機能を使って、<code>+</code>演算子と<code>*</code>演算子の実装を<code>@+</code>と<code>@*</code>に付け替えています。

ちなみに、<code>fstropical</code>モジュール（fstropical.fs）では、Min-Plus半環のための演算子として<code>@+</code>と<code>@*</code>を使っていますが、ここを<code>+</code>と<code>*</code>に置き換えることもできます。すると、<code>fstropical</code>モジュールをopenするだけで、ファイル全体で<code>+</code>演算子と<code>*</code>演算子の動きが置き換わります。

m-hiyamaさんは
>>
僕が名前（記号やリテラルも含む）のオーバーロードに拘るのは、名前の増加に耐えられないからです。
<<
と書いていましたから、<code>@+</code>と<code>@*</code>を使わないコードの方を好まれるかもしれませんね。

というわけで、「空気を読んでくれる演算子」ぐらいならF#でなんとか実現できそう、という感じでした。
"
2015-12-07,,"*1449485837*[F#]演算子オーバーロードとユーザ定義型変換とカスタム数値リテラルとジェネリック単位元と

（12/8追記: 檜山さんの新しい記事を受けて、別バージョンを書きました。https://gist.github.com/matarillo/d9861bcce64b4b6ae4da 明日には新しいブログエントリーを書くつもりです。）


[http://haskell.g.hatena.ne.jp/matarillo/20151202/1449027369:title]の続き。

もともとの [http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title]に近しいコードに書き直しました。

<code>Q</code>をプリフィックスとするカスタム数値リテラルを定義してみました。
<code>0Q</code>と<code>1Q</code>の扱いをどうするか悩みましたが、実数 <code>0.0</code>および<code>1.0</code>からの変換と同じ扱いにしました。

MinPlus半環の単位元が必要な場合は、<code>MinPlus.Zero</code>および<code>MinPlus.One</code>を使う想定です。

この2つが定義されているので、<code>LanguagePrimitives.GenericZero</code>と<code>LanguagePrimitives.GenericOne</code>を使うこともできます。といってもインライン関数以外で使ってもそんなにうれしくないですが……

<script src=""https://gist.github.com/matarillo/7502d98b8d46f56b4546.js""></script>


",,"*1449485837*[F#]演算子オーバーロードとユーザ定義型変換とカスタム数値リテラルとジェネリック単位元と

（12/8追記: 檜山さんの新しい記事を受けて、別バージョンを書きました。https://gist.github.com/matarillo/d9861bcce64b4b6ae4da 明日には新しいブログエントリーを書くつもりです。）


[http://haskell.g.hatena.ne.jp/matarillo/20151202/1449027369:title]の続き。

もともとの [http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title]に近しいコードに書き直しました。

<code>Q</code>をプリフィックスとするカスタム数値リテラルを定義してみました。
<code>0Q</code>と<code>1Q</code>の扱いをどうするか悩みましたが、実数 <code>0.0</code>および<code>1.0</code>からの変換と同じ扱いにしました。

MinPlus半環の単位元が必要な場合は、<code>MinPlus.Zero</code>および<code>MinPlus.One</code>を使う想定です。

この2つが定義されているので、<code>LanguagePrimitives.GenericZero</code>と<code>LanguagePrimitives.GenericOne</code>を使うこともできます。といってもインライン関数以外で使ってもそんなにうれしくないですが……

<script src=""https://gist.github.com/matarillo/7502d98b8d46f56b4546.js""></script>


"
2015-12-02,,"*1449027369*[F#]Re: コンピュータは「掛け算は足し算とする」を理解できるか
>http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title>
行列計算はともかくとして、min-plus半環そのものを定義します。
<<

複数のプリミティブ数値型に対応するには？と読みました。

新しい演算子、たとえば <code>?+</code>と<code>?*</code> を作る方法も考えられますが、まずはジェネリクスで対応。

F#には型クラスがないので、型に応じた計算の関数を引き渡してるのがださいけど、まあ大目に見るとして。

<script src=""https://gist.github.com/matarillo/44d202fce5cfff16d4ca.js""></script>


[https://ideone.com/FzAgSV:title=実行結果はIdeoneで見れます]。

もとの記事のソースをよく読むと、内部的には<code>double</code>だけでOKだったっぽい。そしたらもっと楽ですね。後で書けたら書く。
",,"*1449027369*[F#]Re: コンピュータは「掛け算は足し算とする」を理解できるか
>http://d.hatena.ne.jp/m-hiyama/20151202/1449016930:title>
行列計算はともかくとして、min-plus半環そのものを定義します。
<<

複数のプリミティブ数値型に対応するには？と読みました。

新しい演算子、たとえば <code>?+</code>と<code>?*</code> を作る方法も考えられますが、まずはジェネリクスで対応。

F#には型クラスがないので、型に応じた計算の関数を引き渡してるのがださいけど、まあ大目に見るとして。

<script src=""https://gist.github.com/matarillo/44d202fce5cfff16d4ca.js""></script>


[https://ideone.com/FzAgSV:title=実行結果はIdeoneで見れます]。

もとの記事のソースをよく読むと、内部的には<code>double</code>だけでOKだったっぽい。そしたらもっと楽ですね。後で書けたら書く。
"
2015-12-01,,"*1448953326*[F#]Re: お手軽で実用的なジェネリックスへの道は遠い

>http://d.hatena.ne.jp/m-hiyama/20151130/1448843034:title>
「TypeScriptジェネリックス：可能性が見えると不満がつのる」において、クラス定義や関数定義に型パラメータを渡せるだけでは、ジェネリック・プログラミングは難しいと述べました。そのときの例題はリストの総和だったのですが、より簡単な累乗（ベキ乗、power）計算を例にしてもう一度問題点を説明します。
<<

>http://d.hatena.ne.jp/m-hiyama/20151130/1448843034:title>
最近のプログラミング言語はジェネリックス機能を持っているものが多いですが、言語の進化に伴って後から付けたものがほとんどで、最初からジェネリックスありきで設計したものって、（少なくともメジャーどころでは）ないんじゃないの。ジェネリックスと演算子オーバーロードと型クラスを中核にしたプログラミング言語が出てきたら面白いのにね。
<<

F# は[http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html:title=TIOBEランキングで31位] なのでメジャーどころとは言いにくいところですが、ジェネリックスがあって演算子オーバーロードもあって、型クラスはないけどインライン関数の力でポリモーフィックなべき乗を書くことができます。

<script src=""https://gist.github.com/matarillo/cd9aa111c29573e5576f.js""></script>

実行結果は[https://ideone.com/LFqeAg:title=IdeOne]で見ることができます。

<code>[https://msdn.microsoft.com/en-us/library/ee353503.aspx:title=LanguagePrimitives.GenericOne]</code>関数は、プリミティブな数値型、もしくは<code>One</code>という名前の静的メンバーが定義されている任意の型を引数にとって、その型の「1」を返すというもの。

インライン関数として定義した<code>pow</code>の引数や戻り値の型や型制約を省略しているのでよくわからないかもしれませんが、F#コンパイラが適切な型や型制約を推論してくれます。

たとえば<code>pow</code>の引数<code>x</code>の型については、
- 演算子 <code>*</code> がオーバーロード定義されていること
- <code>LanguagePrimitives.GenericOne</code>関数と同じ制約を持つこと、すなわち、プリミティブな数値型、もしくは<code>One</code>という名前の静的メンバーが定義されている任意の型であること
の2つが要請されます。

その上で、<code>pow</code>の呼び出し側で、実際にどんな型を引数として渡しているかが、コンパイル時にチェックされます。今回の例では<code>int</code>型と<code>float</code>型を渡していますが、どちらもプリミティブな数値型であり、<code>*</code>演算子がオーバーロード定義されているので、コンパイルに通ります。

「F#すごいじゃん」と思うかもしれませんが、実は注意点があって、F#では<strong>ジェネリクスと（多相）インライン関数は別の仕組みなのでシームレスに使うことはできない</strong>というところ。そのあたりのことが[https://msdn.microsoft.com/ja-jp/library/dd548046.aspx:title=MSDNに書いてあります]が、一言でいえば「インライン関数はコンパイル時に、ジェネリクスは実行時に型が解決される」という感じです。

（追記）ちなみにScalaの場合は「staticなんてものはないのだ。シングルトンオブジェクトがあるだけだ。」「型からシングルトンオブジェクトのインスタンスが決まる仕組みが整備されれば、それが型クラスになるのだ。」という感じの解決法で、（自分で好んで書きたいとはあまり思わないものの）興味深い仕掛けです。
",,"*1448953326*[F#]Re: お手軽で実用的なジェネリックスへの道は遠い

>http://d.hatena.ne.jp/m-hiyama/20151130/1448843034:title>
「TypeScriptジェネリックス：可能性が見えると不満がつのる」において、クラス定義や関数定義に型パラメータを渡せるだけでは、ジェネリック・プログラミングは難しいと述べました。そのときの例題はリストの総和だったのですが、より簡単な累乗（ベキ乗、power）計算を例にしてもう一度問題点を説明します。
<<

>http://d.hatena.ne.jp/m-hiyama/20151130/1448843034:title>
最近のプログラミング言語はジェネリックス機能を持っているものが多いですが、言語の進化に伴って後から付けたものがほとんどで、最初からジェネリックスありきで設計したものって、（少なくともメジャーどころでは）ないんじゃないの。ジェネリックスと演算子オーバーロードと型クラスを中核にしたプログラミング言語が出てきたら面白いのにね。
<<

F# は[http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html:title=TIOBEランキングで31位] なのでメジャーどころとは言いにくいところですが、ジェネリックスがあって演算子オーバーロードもあって、型クラスはないけどインライン関数の力でポリモーフィックなべき乗を書くことができます。

<script src=""https://gist.github.com/matarillo/cd9aa111c29573e5576f.js""></script>

実行結果は[https://ideone.com/LFqeAg:title=IdeOne]で見ることができます。

<code>[https://msdn.microsoft.com/en-us/library/ee353503.aspx:title=LanguagePrimitives.GenericOne]</code>関数は、プリミティブな数値型、もしくは<code>One</code>という名前の静的メンバーが定義されている任意の型を引数にとって、その型の「1」を返すというもの。

インライン関数として定義した<code>pow</code>の引数や戻り値の型や型制約を省略しているのでよくわからないかもしれませんが、F#コンパイラが適切な型や型制約を推論してくれます。

たとえば<code>pow</code>の引数<code>x</code>の型については、
- 演算子 <code>*</code> がオーバーロード定義されていること
- <code>LanguagePrimitives.GenericOne</code>関数と同じ制約を持つこと、すなわち、プリミティブな数値型、もしくは<code>One</code>という名前の静的メンバーが定義されている任意の型であること
の2つが要請されます。

その上で、<code>pow</code>の呼び出し側で、実際にどんな型を引数として渡しているかが、コンパイル時にチェックされます。今回の例では<code>int</code>型と<code>float</code>型を渡していますが、どちらもプリミティブな数値型であり、<code>*</code>演算子がオーバーロード定義されているので、コンパイルに通ります。

「F#すごいじゃん」と思うかもしれませんが、実は注意点があって、F#では<strong>ジェネリクスと（多相）インライン関数は別の仕組みなのでシームレスに使うことはできない</strong>というところ。そのあたりのことが[https://msdn.microsoft.com/ja-jp/library/dd548046.aspx:title=MSDNに書いてあります]が、一言でいえば「インライン関数はコンパイル時に、ジェネリクスは実行時に型が解決される」という感じです。

（追記）ちなみにScalaの場合は「staticなんてものはないのだ。シングルトンオブジェクトがあるだけだ。」「型からシングルトンオブジェクトのインスタンスが決まる仕組みが整備されれば、それが型クラスになるのだ。」という感じの解決法で、（自分で好んで書きたいとはあまり思わないものの）興味深い仕掛けです。
"
2015-09-28,,"*1443415063*[F#]本質ではない。
F# 不況側は何かと「C# はここがダメ！F# はC# よりイイ！」って言うけど、F#の成果がぜんぜんアピールされてないというのは真実。

ほかのはやりの言語は自身をわざわざC# なんかと比較したりしないし、そういうこというのF# ぐらいしかないよね。

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""http://twitter.com/tanakh"">
      <img src=""http://pbs.twimg.com/profile_images/603918430639521792/zZNtUnXN_normal.png"" alt=""tanakh"" height=""48"" width=""48""  this);"" >
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      F#からWindowsアプリ作るスケルトンはないんですかね
    </p>
    <p class=""twitter-detail-info"">
      <a href=""http://twitter.com/tanakh/status/642933802352943104"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2015-09-13</span> <span class=""twitter-detail-info-time"">14:32:18</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://about.twitter.com/products/tweetdeck"" rel=""nofollow"">TweetDeck</a></span>
    </p>
  </div>
</div><

F#はVisual Studio的に1st class languageじゃないんだけど、でもそっちを求めるのも個人的には違うなと思ってる。（VSエコシステム的には重要なんだろうけどね）どっちかというとクロプラ方面のほうがいいっす。VS Codeが機能向上しちゃうとそっちもC# が出てくるかもしれないけど。
",,"*1443415063*[F#]本質ではない。
F# 不況側は何かと「C# はここがダメ！F# はC# よりイイ！」って言うけど、F#の成果がぜんぜんアピールされてないというのは真実。

ほかのはやりの言語は自身をわざわざC# なんかと比較したりしないし、そういうこというのF# ぐらいしかないよね。

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""http://twitter.com/tanakh"">
      <img src=""http://pbs.twimg.com/profile_images/603918430639521792/zZNtUnXN_normal.png"" alt=""tanakh"" height=""48"" width=""48""  this);"" >
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      F#からWindowsアプリ作るスケルトンはないんですかね
    </p>
    <p class=""twitter-detail-info"">
      <a href=""http://twitter.com/tanakh/status/642933802352943104"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2015-09-13</span> <span class=""twitter-detail-info-time"">14:32:18</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://about.twitter.com/products/tweetdeck"" rel=""nofollow"">TweetDeck</a></span>
    </p>
  </div>
</div><

F#はVisual Studio的に1st class languageじゃないんだけど、でもそっちを求めるのも個人的には違うなと思ってる。（VSエコシステム的には重要なんだろうけどね）どっちかというとクロプラ方面のほうがいいっす。VS Codeが機能向上しちゃうとそっちもC# が出てくるかもしれないけど。
"
2015-08-30,,"*1440904176*[F#]F#のWebアプリケーションフレームワーク

[http://fsharp.org/guides/web/:title] に載ってる中でちょっと気になったやつをメモ。

Suave.IOはノンブロッキングでクロスプラットフォーム。ほうほう。結構作りこまれてる様子。
[http://suave.io/:title]

>|ocaml|
type SuaveTask<'a> = Async<'a option>
type WebPart = HttpContext -> SuaveTask<HttpContext>
||<

>|ocaml|
open Suave
open Suave.Http
open Suave.Http.Applicatives
open Suave.Http.Successful
open Suave.Web

let app =
  choose
    [ GET >>= choose
        [ path ""/hello"" >>= OK ""Hello GET""
          path ""/goodbye"" >>= OK ""Good bye GET"" ]
      POST >>= choose
        [ path ""/hello"" >>= OK ""Hello POST""
          path ""/goodbye"" >>= OK ""Good bye POST"" ] ]

startWebServer defaultConfig app
||<

Freyaはステートマシン。シンプルっぽい。
[https://github.com/freya-fs/freya:title]

>|ocaml|
type Freya<'a> = FreyaState -> Async<'a * FreyaState>
||<

>|ocaml|
let double x =
    freya {
        return x * 2 }
||<
",,"*1440904176*[F#]F#のWebアプリケーションフレームワーク

[http://fsharp.org/guides/web/:title] に載ってる中でちょっと気になったやつをメモ。

Suave.IOはノンブロッキングでクロスプラットフォーム。ほうほう。結構作りこまれてる様子。
[http://suave.io/:title]

>|ocaml|
type SuaveTask<'a> = Async<'a option>
type WebPart = HttpContext -> SuaveTask<HttpContext>
||<

>|ocaml|
open Suave
open Suave.Http
open Suave.Http.Applicatives
open Suave.Http.Successful
open Suave.Web

let app =
  choose
    [ GET >>= choose
        [ path ""/hello"" >>= OK ""Hello GET""
          path ""/goodbye"" >>= OK ""Good bye GET"" ]
      POST >>= choose
        [ path ""/hello"" >>= OK ""Hello POST""
          path ""/goodbye"" >>= OK ""Good bye POST"" ] ]

startWebServer defaultConfig app
||<

Freyaはステートマシン。シンプルっぽい。
[https://github.com/freya-fs/freya:title]

>|ocaml|
type Freya<'a> = FreyaState -> Async<'a * FreyaState>
||<

>|ocaml|
let double x =
    freya {
        return x * 2 }
||<
"
2015-08-29,,"*1440903664*[F#]演算子のオーバーロード #5(完結編)

ちょっと間が空いた。

さて、ここまでを踏まえれば、最初の記事に載せた

[http://stackoverflow.com/questions/11150947/f-overloaded-operater-with-floats-not-working-with-other-floats/11152288#11152288:title]

はほぼ理解できる。

- 組み込みの<code>float</code>とユーザー定義の<code>vector2</code>の両方で使えるように、2項演算子 <code>*=</code> をオーバーロードしたい
- しかし、<code>float</code>同士の<code>*=</code>演算を、後付けで定義することができない
- そこで、以下のハックを使う
-- 演算子オーバーロードのためだけに、新たなユーザー定義型 <code>Overloads</code>を定義する
-- ユーザー定義型 <code>Overloads</code>に、3項演算子 <code>?&lt;-</code>を定義する
-- その演算子は、<code>Overloads</code>型の値を1つ、<code>*=</code>演算子を適用したい型の値を2つ受け取るが、<code>Overloads</code>型の値は捨ててしまい、本来やりたかった<code>*=</code>演算だけを実装する
- 以上の準備ができたなら、グローバルレベルでのインライン演算子定義で、<code>*=</code>を実装し、<code>Overloads</code>型の<code>?&lt;-</code>演算子にぶん投げる
-- <code>Overloads</code>型の値は演算子オーバーロードの解決に使われた後は捨てられるので、unit的に値が1つしかない型で十分。よって、<code>Overloads</code>型は値が1つしかない判別共用体として定義してもいい。

なんとまあ。分かってしまえば何ということはなかった。<code>?&lt;-</code>を使っているのは単にそれが3項演算子だからってだけのようだし、<code>Overloads</code>型が値が1つしかない判別共用体であることにも大きな意味はなかった。","bleis-tiftwhttps://code.google.com/p/fsharp-typeclasses/<br>http://nut-cracker.azurewebsites.net/blog/2011/11/15/typeclasses-for-fsharp/<br><br>このあたりの話ですね。<br>このライブラリは現在はFsControlとして (?&lt;-) を使わない形でより使いやすく作り直されています。x
matarillow気づくのがすごーく遅くなりました。<br>https://twitter.com/lyrical_logical/status/667427660218413059 とか https://en.wikipedia.org/wiki/Ad_hoc_polymorphism を読んでて、頭のなかが少しつながりました。x
","*1440903664*[F#]演算子のオーバーロード #5(完結編)

ちょっと間が空いた。

さて、ここまでを踏まえれば、最初の記事に載せた

[http://stackoverflow.com/questions/11150947/f-overloaded-operater-with-floats-not-working-with-other-floats/11152288#11152288:title]

はほぼ理解できる。

- 組み込みの<code>float</code>とユーザー定義の<code>vector2</code>の両方で使えるように、2項演算子 <code>*=</code> をオーバーロードしたい
- しかし、<code>float</code>同士の<code>*=</code>演算を、後付けで定義することができない
- そこで、以下のハックを使う
-- 演算子オーバーロードのためだけに、新たなユーザー定義型 <code>Overloads</code>を定義する
-- ユーザー定義型 <code>Overloads</code>に、3項演算子 <code>?&lt;-</code>を定義する
-- その演算子は、<code>Overloads</code>型の値を1つ、<code>*=</code>演算子を適用したい型の値を2つ受け取るが、<code>Overloads</code>型の値は捨ててしまい、本来やりたかった<code>*=</code>演算だけを実装する
- 以上の準備ができたなら、グローバルレベルでのインライン演算子定義で、<code>*=</code>を実装し、<code>Overloads</code>型の<code>?&lt;-</code>演算子にぶん投げる
-- <code>Overloads</code>型の値は演算子オーバーロードの解決に使われた後は捨てられるので、unit的に値が1つしかない型で十分。よって、<code>Overloads</code>型は値が1つしかない判別共用体として定義してもいい。

なんとまあ。分かってしまえば何ということはなかった。<code>?&lt;-</code>を使っているのは単にそれが3項演算子だからってだけのようだし、<code>Overloads</code>型が値が1つしかない判別共用体であることにも大きな意味はなかった。"
2015-08-24,,"*1440409679*[F#]演算子のオーバーロード #4

グローバルレベルで定義された演算子が演算子のオーバーロードを隠してしまう。それはわかった。それならそれで、グローバルレベルで定義された演算子は多相（ジェネリック）にできないのだろうか。

結論から言うとできる。ただし気を付けなければならないことがある。

まず、関数の場合は山かっこ（<code>&lt;</code>および<code>&gt;</code>）を関数名の直後に置ける。

>|ocaml|
let addCount<'a when 'a :> System.Collections.ICollection>
    (x: 'a) (y: 'a) = x.Count + y.Count
||<

この書き方は演算子ではできない。代わりにこのように書く。

>|ocaml|
// 演算子の場合はこう書くしかない
let (+) (x: 'a) (y: 'a): int
    when 'a :> System.Collections.ICollection =
    x.Count + y.Count

// なお関数なら両方の書き方が許される
let addCount (x: 'a) (y: 'a): int
    when 'a :> System.Collections.ICollection =
    x.Count + y.Count
||<

こうすればジェネリックな演算子ができるのだが、F#のジェネリクスは.NETのジェネリクスを基盤にしているから、F#の型制約も基本的にはその範囲でしか書けない。つまり、（new制約や構造体制約は別とすれば）指定したクラスやインターフェースを継承している場合に、その型のインスタンスメソッドが呼び出せる、という程度のことしかできない。オーバーロードされた演算子はスタティックメンバー扱いだからジェネリックなメソッドからは呼び出せない。したがって、グローバルレベルで定義されたジェネリックな演算子の実装から呼び出すこともできない。C#と一緒である((F#では列挙型制約やデリゲート制約をつけられるが、C#ではできないという違いはある))。

ただ、F#の強力なところは、インライン関数を使うことでその制限を超えることができることだ。インライン関数はコンパイル時に静的に型が解決されるため、明示的なメンバーの制約をかけることで、型階層によらず、また静的メンバーとインスタンスメンバーを問わず、あるメンバーを持っている型が使われることを要請できる。

VSで書くといまいちわかりづらいのでF# Intaractiveを使う。

>|ocaml|
> let inline (%*) x y = x * y;;

val inline ( %* ) :
  x: ^a -> y: ^b ->  ^c
    when ( ^a or  ^b) : (static member ( * ) :  ^a *  ^b ->  ^c)
||<

<code>%*</code>演算子の型が、通常のジェネリック型引数で使われる <code>'a</code>や<code>'b</code>ではなく、静的に解決される型を表す <code>^a</code>や<code>^b</code>になっている。<code>%*</code>演算子を使う際には、左項（<code>x</code>）または右項（<code>y</code>）のどちらかの型に対して<code>*</code>演算子のオーバーロードが定義されており、もう一方の項の型もその定義に適合するのであれば、どんな型であってもこの新しい演算子を適用できる。

もちろん、この演算子はコンパイル時にインライン展開（β変換）されるので、通常のジェネリックな型に適用することはできない。ジェネリックな型は実行時に解決されるものだからである。

（続く）
",,"*1440409679*[F#]演算子のオーバーロード #4

グローバルレベルで定義された演算子が演算子のオーバーロードを隠してしまう。それはわかった。それならそれで、グローバルレベルで定義された演算子は多相（ジェネリック）にできないのだろうか。

結論から言うとできる。ただし気を付けなければならないことがある。

まず、関数の場合は山かっこ（<code>&lt;</code>および<code>&gt;</code>）を関数名の直後に置ける。

>|ocaml|
let addCount<'a when 'a :> System.Collections.ICollection>
    (x: 'a) (y: 'a) = x.Count + y.Count
||<

この書き方は演算子ではできない。代わりにこのように書く。

>|ocaml|
// 演算子の場合はこう書くしかない
let (+) (x: 'a) (y: 'a): int
    when 'a :> System.Collections.ICollection =
    x.Count + y.Count

// なお関数なら両方の書き方が許される
let addCount (x: 'a) (y: 'a): int
    when 'a :> System.Collections.ICollection =
    x.Count + y.Count
||<

こうすればジェネリックな演算子ができるのだが、F#のジェネリクスは.NETのジェネリクスを基盤にしているから、F#の型制約も基本的にはその範囲でしか書けない。つまり、（new制約や構造体制約は別とすれば）指定したクラスやインターフェースを継承している場合に、その型のインスタンスメソッドが呼び出せる、という程度のことしかできない。オーバーロードされた演算子はスタティックメンバー扱いだからジェネリックなメソッドからは呼び出せない。したがって、グローバルレベルで定義されたジェネリックな演算子の実装から呼び出すこともできない。C#と一緒である((F#では列挙型制約やデリゲート制約をつけられるが、C#ではできないという違いはある))。

ただ、F#の強力なところは、インライン関数を使うことでその制限を超えることができることだ。インライン関数はコンパイル時に静的に型が解決されるため、明示的なメンバーの制約をかけることで、型階層によらず、また静的メンバーとインスタンスメンバーを問わず、あるメンバーを持っている型が使われることを要請できる。

VSで書くといまいちわかりづらいのでF# Intaractiveを使う。

>|ocaml|
> let inline (%*) x y = x * y;;

val inline ( %* ) :
  x: ^a -> y: ^b ->  ^c
    when ( ^a or  ^b) : (static member ( * ) :  ^a *  ^b ->  ^c)
||<

<code>%*</code>演算子の型が、通常のジェネリック型引数で使われる <code>'a</code>や<code>'b</code>ではなく、静的に解決される型を表す <code>^a</code>や<code>^b</code>になっている。<code>%*</code>演算子を使う際には、左項（<code>x</code>）または右項（<code>y</code>）のどちらかの型に対して<code>*</code>演算子のオーバーロードが定義されており、もう一方の項の型もその定義に適合するのであれば、どんな型であってもこの新しい演算子を適用できる。

もちろん、この演算子はコンパイル時にインライン展開（β変換）されるので、通常のジェネリックな型に適用することはできない。ジェネリックな型は実行時に解決されるものだからである。

（続く）
"
2015-08-23,,"*1440284355*[F#]演算子のオーバーロード #3

さて、<code>?&lt;-</code>はいったん置いておいて、演算子のオーバーロード解決を勉強した。

F# の演算子定義は2通りのパターンがある。

1つは(C#と同様に)クラスなどのスタティックメンバーとして書くもの。

>|ocaml|
type MyRecord = { x: int; y: int } with
    static member (+) (left: MyRecord, right: MyRecord) =
        { x = left.x + right.x;
          y = left.y + right.y }
||<

メソッドとして書くので、引数はタプルで受け取る。しかし実際には中置演算子として使える。

もう1つは、グローバルレベルで定義するもの。

>|ocaml|
let (+) (left: MyRecord) (right: MyRecord) =
    { x = left.x + right.x;
      y = left.y + right.y }
||<

こちらはF#の関数として書くので、引数はタプルにしない。こちらも中置演算子として使える。

これらの違いは何かというと、演算子がオーバーロード（多重定義）されるかどうかが違う。

グローバルレベルで定義された演算子は、演算子のオーバーロードを隠してしまう。

>|ocaml|
let (+) (left: MyRecord) (right: MyRecord) =
    { x = left.x + right.x;
      y = left.y + right.y }

let a = 1 + 2 // コンパイルエラー。MyRecord型の引数が期待されるところにint型の引数を渡している。
||<

演算子のオーバーロードが期待通りに動作するためには、演算子はグローバルレベルで定義するのではなく、引数の型のスタティックメンバーとして定義しておかなければならない。

演算子のオーバーロード解決は、まずグローバルレベルの定義を探し、それが見つからなかった場合だけ、引数の型のスタティックメンバーから適切な演算子定義を探す、という順番になっているからだ。

（続く）
",,"*1440284355*[F#]演算子のオーバーロード #3

さて、<code>?&lt;-</code>はいったん置いておいて、演算子のオーバーロード解決を勉強した。

F# の演算子定義は2通りのパターンがある。

1つは(C#と同様に)クラスなどのスタティックメンバーとして書くもの。

>|ocaml|
type MyRecord = { x: int; y: int } with
    static member (+) (left: MyRecord, right: MyRecord) =
        { x = left.x + right.x;
          y = left.y + right.y }
||<

メソッドとして書くので、引数はタプルで受け取る。しかし実際には中置演算子として使える。

もう1つは、グローバルレベルで定義するもの。

>|ocaml|
let (+) (left: MyRecord) (right: MyRecord) =
    { x = left.x + right.x;
      y = left.y + right.y }
||<

こちらはF#の関数として書くので、引数はタプルにしない。こちらも中置演算子として使える。

これらの違いは何かというと、演算子がオーバーロード（多重定義）されるかどうかが違う。

グローバルレベルで定義された演算子は、演算子のオーバーロードを隠してしまう。

>|ocaml|
let (+) (left: MyRecord) (right: MyRecord) =
    { x = left.x + right.x;
      y = left.y + right.y }

let a = 1 + 2 // コンパイルエラー。MyRecord型の引数が期待されるところにint型の引数を渡している。
||<

演算子のオーバーロードが期待通りに動作するためには、演算子はグローバルレベルで定義するのではなく、引数の型のスタティックメンバーとして定義しておかなければならない。

演算子のオーバーロード解決は、まずグローバルレベルの定義を探し、それが見つからなかった場合だけ、引数の型のスタティックメンバーから適切な演算子定義を探す、という順番になっているからだ。

（続く）
"
2015-08-18,,"*1439831255*[F#]演算子のオーバーロード #2
F#の <code>?&lt;-</code> 演算子（動的プロパティに値を設定する演算子）はわりとキモいことがわかってきた。

まずはこんな感じでグローバルな演算子を定義してみる。
>|ocaml|
let (?<-) (d:#IDictionary<'K, 'V>) k v = d.[k] <- v
||<

まず、キーとして適当な判別共用体を食わせてみる。
>|ocaml|
type MyUnion = A | B | C of int

let testUnion =
    let d = new Dictionary<MyUnion, int>()
    let k = C 12
    d.[k] <- 1

    d?(k) <- 2
    d?(C 12) <- 3

    printfn ""%A"" (d.[k])
||<
出力は想像通り、 <code>3</code> になる。
まあそれはいい。

次に、キーとして文字列を食わせてみる。
>|ocaml|
let testString = 
    let d = new Dictionary<string, int>()
    let k = ""foo""
    d.[k] <- 1

    d?(k) <- 2
    d?foo <- 3

    printfn ""%A"" (d.[k])
||<

エラーは出ず、出力は <code>3</code> になる。

<code>d?foo</code> は、C#で言うところの<code>dynamic</code>型みたいな感じで、文字列として書いてなくても文字列としてコンパイルされるということのようだ。キモいけど、なんとかわかった。
（続く）
",,"*1439831255*[F#]演算子のオーバーロード #2
F#の <code>?&lt;-</code> 演算子（動的プロパティに値を設定する演算子）はわりとキモいことがわかってきた。

まずはこんな感じでグローバルな演算子を定義してみる。
>|ocaml|
let (?<-) (d:#IDictionary<'K, 'V>) k v = d.[k] <- v
||<

まず、キーとして適当な判別共用体を食わせてみる。
>|ocaml|
type MyUnion = A | B | C of int

let testUnion =
    let d = new Dictionary<MyUnion, int>()
    let k = C 12
    d.[k] <- 1

    d?(k) <- 2
    d?(C 12) <- 3

    printfn ""%A"" (d.[k])
||<
出力は想像通り、 <code>3</code> になる。
まあそれはいい。

次に、キーとして文字列を食わせてみる。
>|ocaml|
let testString = 
    let d = new Dictionary<string, int>()
    let k = ""foo""
    d.[k] <- 1

    d?(k) <- 2
    d?foo <- 3

    printfn ""%A"" (d.[k])
||<

エラーは出ず、出力は <code>3</code> になる。

<code>d?foo</code> は、C#で言うところの<code>dynamic</code>型みたいな感じで、文字列として書いてなくても文字列としてコンパイルされるということのようだ。キモいけど、なんとかわかった。
（続く）
"
2015-08-17,,"*1439787013*[F#]演算子のオーバーロード #1
[http://stackoverflow.com/questions/11150947/f-overloaded-operater-with-floats-not-working-with-other-floats/11152288#11152288:title]

F#の <code>?&lt;-</code> 演算子は「動的プロパティに値を設定する演算子」なんですが、なんでそれがここに？
しかも、
>|ocaml|
type Overloads = Overloads
||<
って、値が1つしかない判別共用体ですよね。なんでそれがここに？

F#の演算子のことをよくわかっていないことに気づいたので、改めて勉強していこうと思います。
",,"*1439787013*[F#]演算子のオーバーロード #1
[http://stackoverflow.com/questions/11150947/f-overloaded-operater-with-floats-not-working-with-other-floats/11152288#11152288:title]

F#の <code>?&lt;-</code> 演算子は「動的プロパティに値を設定する演算子」なんですが、なんでそれがここに？
しかも、
>|ocaml|
type Overloads = Overloads
||<
って、値が1つしかない判別共用体ですよね。なんでそれがここに？

F#の演算子のことをよくわかっていないことに気づいたので、改めて勉強していこうと思います。
"
2015-07-09,,"*1436412055*[F#]Minority's hello, worldにF#で挑戦

CodeIQに[https://codeiq.jp/q/1579:title=Minority's hello, world]という問題が出ていました。

問題が見れなくなっているので引用すると、こういうもの。
>>
<h4>■問題の概要</h4>
「hello, world」と出力するプログラムを提出して下さい。
提出されたプログラムで使われている文字を、全挑戦者について集計します。
各文字には「(その文字を利用した挑戦者の人数)の2乗」というポイントが割り当てられます。
提出されたプログラムのポイントは、そのプログラムで使われている文字のポイントの合計となります。
提出コードのポイントが少ない順に順位をつけます。最小ポイントの方が優勝です。
<<

出題者の鍋谷さんによる結果発表と解説がこちら。

[http://nabetani.sakura.ne.jp/codeiq/hwbattle2/]

で、私はF#で適当に（あまり考えずに）下のようなコードをぶっこんで

>|cs|
System.Console.Write(""hello, world"")
||<

結果、スコアは29,198点、順位は58位となり、当然上位には入れませんでした。

で、ここからがコードゴルフ。

じゃあ、どういうコードだったらもっとスコアが良かった（低くなった）か？ということで再考したのがこちら。

>|cs|
printf<|""%s""<|""hello,\u0020world""
||<

これだと何点取れてたかを計算し直したコードがこちら。

>|ocaml|
let addCount (xs: (char*int) seq) (ys: (char*int) seq) =
    Seq.append xs ys
    |> Seq.groupBy fst
    |> Seq.map (fun (c,zs) -> c,(Seq.sumBy snd zs))

let calc (xs: (char*int) seq) (ys: char seq) =
    ys
    |> Seq.map (fun c -> Seq.find (fun (c',_) -> c=c') xs)
    |> Seq.sumBy (fun (_,v) -> v*v)

[<EntryPoint>]
let main argv = 
    let othersCount =
        [(' ', 42); ('!', 9); ('""', 24); ('#', 10); ('$', 12); ('%', 10); ('&', 10);
         ('\'', 19); ('(', 28); (')', 26); ('*', 6); ('+', 8); (',', 36); ('-', 17);
         ('.', 24); ('/', 7); ('0', 17); ('1', 11); ('2', 15); ('3', 9); ('4', 18);
         ('5', 14); ('6', 11); ('7', 8); ('8', 12); ('9', 8); (':', 11); (';', 19);
         ('<', 20); ('=', 16); ('>', 15); ('?', 11); ('@', 4); ('A', 5); ('B', 4);
         ('C', 11); ('D', 13); ('E', 16); ('F', 9); ('G', 4); ('H', 16); ('I', 5);
         ('J', 5); ('K', 5); ('L', 16); ('M', 6); ('N', 5); ('O', 16); ('P', 4);
         ('Q', 7); ('R', 14); ('S', 5); ('T', 8); ('U', 4); ('V', 5); ('W', 13);
         ('X', 3); ('Y', 2); ('Z', 4); ('[', 11); ('\\', 14); (']', 13); ('^', 10);
         ('_', 8); ('`', 4); ('a', 20); ('b', 9); ('c', 26); ('d', 30); ('e', 33);
         ('f', 9); ('g', 6); ('h', 31); ('i', 21); ('j', 9); ('k', 9); ('l', 26);
         ('m', 8); ('n', 19); ('o', 33); ('p', 26); ('q', 8); ('r', 37); ('s', 23);
         ('t', 28); ('u', 17); ('v', 8); ('w', 22); ('x', 9); ('y', 12); ('z', 4);
         ('{', 10); ('|', 7); ('}', 12); ('~', 9)]

    //let myCode = ""System.Console.Write(\""hello, world\"")""
    let myCode = ""printf<|\""%s\""<|\""hello,\\u0020world\""""
    let myCount = myCode |> Seq.distinct |> Seq.countBy id
    let count = addCount othersCount myCount

    printfn ""%s"" myCode
    printfn ""%d"" (calc count myCode)
    0
||<

実行結果は、20,964点。もしかしたら50位以内には入れたかもしれないけど、他の人のスコアも変動するので、実際はどうでしょうね。（計算すれば出ると思いますが、面倒なのでコードに落としていません）
",,"*1436412055*[F#]Minority's hello, worldにF#で挑戦

CodeIQに[https://codeiq.jp/q/1579:title=Minority's hello, world]という問題が出ていました。

問題が見れなくなっているので引用すると、こういうもの。
>>
<h4>■問題の概要</h4>
「hello, world」と出力するプログラムを提出して下さい。
提出されたプログラムで使われている文字を、全挑戦者について集計します。
各文字には「(その文字を利用した挑戦者の人数)の2乗」というポイントが割り当てられます。
提出されたプログラムのポイントは、そのプログラムで使われている文字のポイントの合計となります。
提出コードのポイントが少ない順に順位をつけます。最小ポイントの方が優勝です。
<<

出題者の鍋谷さんによる結果発表と解説がこちら。

[http://nabetani.sakura.ne.jp/codeiq/hwbattle2/]

で、私はF#で適当に（あまり考えずに）下のようなコードをぶっこんで

>|cs|
System.Console.Write(""hello, world"")
||<

結果、スコアは29,198点、順位は58位となり、当然上位には入れませんでした。

で、ここからがコードゴルフ。

じゃあ、どういうコードだったらもっとスコアが良かった（低くなった）か？ということで再考したのがこちら。

>|cs|
printf<|""%s""<|""hello,\u0020world""
||<

これだと何点取れてたかを計算し直したコードがこちら。

>|ocaml|
let addCount (xs: (char*int) seq) (ys: (char*int) seq) =
    Seq.append xs ys
    |> Seq.groupBy fst
    |> Seq.map (fun (c,zs) -> c,(Seq.sumBy snd zs))

let calc (xs: (char*int) seq) (ys: char seq) =
    ys
    |> Seq.map (fun c -> Seq.find (fun (c',_) -> c=c') xs)
    |> Seq.sumBy (fun (_,v) -> v*v)

[<EntryPoint>]
let main argv = 
    let othersCount =
        [(' ', 42); ('!', 9); ('""', 24); ('#', 10); ('$', 12); ('%', 10); ('&', 10);
         ('\'', 19); ('(', 28); (')', 26); ('*', 6); ('+', 8); (',', 36); ('-', 17);
         ('.', 24); ('/', 7); ('0', 17); ('1', 11); ('2', 15); ('3', 9); ('4', 18);
         ('5', 14); ('6', 11); ('7', 8); ('8', 12); ('9', 8); (':', 11); (';', 19);
         ('<', 20); ('=', 16); ('>', 15); ('?', 11); ('@', 4); ('A', 5); ('B', 4);
         ('C', 11); ('D', 13); ('E', 16); ('F', 9); ('G', 4); ('H', 16); ('I', 5);
         ('J', 5); ('K', 5); ('L', 16); ('M', 6); ('N', 5); ('O', 16); ('P', 4);
         ('Q', 7); ('R', 14); ('S', 5); ('T', 8); ('U', 4); ('V', 5); ('W', 13);
         ('X', 3); ('Y', 2); ('Z', 4); ('[', 11); ('\\', 14); (']', 13); ('^', 10);
         ('_', 8); ('`', 4); ('a', 20); ('b', 9); ('c', 26); ('d', 30); ('e', 33);
         ('f', 9); ('g', 6); ('h', 31); ('i', 21); ('j', 9); ('k', 9); ('l', 26);
         ('m', 8); ('n', 19); ('o', 33); ('p', 26); ('q', 8); ('r', 37); ('s', 23);
         ('t', 28); ('u', 17); ('v', 8); ('w', 22); ('x', 9); ('y', 12); ('z', 4);
         ('{', 10); ('|', 7); ('}', 12); ('~', 9)]

    //let myCode = ""System.Console.Write(\""hello, world\"")""
    let myCode = ""printf<|\""%s\""<|\""hello,\\u0020world\""""
    let myCount = myCode |> Seq.distinct |> Seq.countBy id
    let count = addCount othersCount myCount

    printfn ""%s"" myCode
    printfn ""%d"" (calc count myCode)
    0
||<

実行結果は、20,964点。もしかしたら50位以内には入れたかもしれないけど、他の人のスコアも変動するので、実際はどうでしょうね。（計算すれば出ると思いますが、面倒なのでコードに落としていません）
"
2015-05-23,,"*1432375082*猫かわいい

[http://www.meetup.com/FunctionalKats/:image=http://photos1.meetupstatic.com/photos/theme_head/e/8/d/d/full_6779613.jpeg]
[http://www.meetup.com/FunctionalKats/:title]",,"*1432375082*猫かわいい

[http://www.meetup.com/FunctionalKats/:image=http://photos1.meetupstatic.com/photos/theme_head/e/8/d/d/full_6779613.jpeg]
[http://www.meetup.com/FunctionalKats/:title]"
2015-05-01,,"*1430436615*kenokabeさん

kenokabeさんは、自説の組み立て方、参照する先行研究や書籍が普通ではないので突っ込まれやすいにも拘わらず自説が正しいという態度を崩さない、知人だったらわりと面倒なお方だなという印象なんだけど、ここに書いてたことにはそんなに違和感ないな。

http://kenokabe-techwriting.blogspot.jp/2015/04/amazon102-93.html

むしろ書評を書いた人が、ラムダ式とクロージャを混同してるんじゃないのか。",,"*1430436615*kenokabeさん

kenokabeさんは、自説の組み立て方、参照する先行研究や書籍が普通ではないので突っ込まれやすいにも拘わらず自説が正しいという態度を崩さない、知人だったらわりと面倒なお方だなという印象なんだけど、ここに書いてたことにはそんなに違和感ないな。

http://kenokabe-techwriting.blogspot.jp/2015/04/amazon102-93.html

むしろ書評を書いた人が、ラムダ式とクロージャを混同してるんじゃないのか。"
2015-03-31,,"*1427782496*[Haskell]モナド構文糖

モナドが便利で、モナド構文糖が便利だってことには特に異論がないんだけど、
それならそれでHaskellのdo-returnみたいに逐次実行に似せるほうが絶対にいいと思う。
そうでなければ、もっとこう、bindとかunitとかそういう語彙を前面に出してほしい。

つまり、Scalaのように、for-yieldとかflatMapというリスト中心の語彙でモナドを扱うのは、どう考えてもキモイ。
（LINQのfrom-selectとかSelectManyとかのあれでモナドを扱うのは、さらにキモイ）

という感覚は、Scalaユーザーと共有することはできないだろうなあ……

（2016/7追記）

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr"">scala 界隈でも for はちょっと…という意見はたまに見るし、F# の方が筋いいよねみたいな話 rpscala の懇親会でやった記憶ある。</p>&mdash; りりかるろじかる (@lyrical_logical) <a href=""https://twitter.com/lyrical_logical/status/758498297682145280"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr"">いやまあ、Scalaのforは最後がmapじゃないといけない縛りとかあって不便なので当然Haskellのdoの方がいいに決まってますよ。 <a href=""https://t.co/NAt2oVzi35"">https://t.co/NAt2oVzi35</a></p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758512390602264576"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr"">&quot;モナド構文糖 - 猫とC#について書く代わりにHaskellとF#について書くmatarilloの日記 (id:matarillo / <a href=""https://twitter.com/matarillo"">@matarillo</a>) <a href=""https://t.co/zmh9pxz7cr"">https://t.co/zmh9pxz7cr</a>&quot; については、Scalaユーザとは十分共有できる感覚だと思いますよ</p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758513589854449664"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

lyrical_logicalさんのツイートを見て、お、追記しておこう、と思ったら、kmizuさんもツイートしてた。

Scalaのfor式が不便(Haskellのdoとreturnみたいに独立してない)というのはそう思うんだけど、言いたかったのはそういうとこじゃないんですよね。

どっちかというと

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr""><a href=""https://twitter.com/kmizu"">@kmizu</a> Haskellとか知ってる人には、flatMapはbindだしfor式はdo式の不便なものという感じで説明できるし、そういうの知らない人向けには、コレクションをfor式でまず扱えて、それに加えてflatMap, mapを実装した任意の型に適用できるので</p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758685993528471554"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr""><a href=""https://twitter.com/kmizu"">@kmizu</a> implicit parameter≒型クラスということ、研究関係以外では最初は全然言ってなかったの（今はもう知られてるからそうでもないかもだけど）もそうだけど、小難しい（そうな）概念をそのままの語彙で導入していない点はOdersky先生のバランス感覚だと思ってる。</p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758687045988392960"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

このあたりが感覚を共有できないと思うあたりで。「コレクションをfor式でまず扱えて」まではいいんだけど、そこから「それに加えてflatMap, mapを実装した任意の型に適用できる」には飛躍があるよね、とか、implicit parameterって結局型クラス以外で使わないんだったら他に名前なかったのか、とかなんですよね。Scala(および設計者のOdersky先生)の選択なんで間違いだとかダメだとかイケてないとかDisりたいわけじゃなくて感覚の問題。
",,"*1427782496*[Haskell]モナド構文糖

モナドが便利で、モナド構文糖が便利だってことには特に異論がないんだけど、
それならそれでHaskellのdo-returnみたいに逐次実行に似せるほうが絶対にいいと思う。
そうでなければ、もっとこう、bindとかunitとかそういう語彙を前面に出してほしい。

つまり、Scalaのように、for-yieldとかflatMapというリスト中心の語彙でモナドを扱うのは、どう考えてもキモイ。
（LINQのfrom-selectとかSelectManyとかのあれでモナドを扱うのは、さらにキモイ）

という感覚は、Scalaユーザーと共有することはできないだろうなあ……

（2016/7追記）

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr"">scala 界隈でも for はちょっと…という意見はたまに見るし、F# の方が筋いいよねみたいな話 rpscala の懇親会でやった記憶ある。</p>&mdash; りりかるろじかる (@lyrical_logical) <a href=""https://twitter.com/lyrical_logical/status/758498297682145280"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr"">いやまあ、Scalaのforは最後がmapじゃないといけない縛りとかあって不便なので当然Haskellのdoの方がいいに決まってますよ。 <a href=""https://t.co/NAt2oVzi35"">https://t.co/NAt2oVzi35</a></p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758512390602264576"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr"">&quot;モナド構文糖 - 猫とC#について書く代わりにHaskellとF#について書くmatarilloの日記 (id:matarillo / <a href=""https://twitter.com/matarillo"">@matarillo</a>) <a href=""https://t.co/zmh9pxz7cr"">https://t.co/zmh9pxz7cr</a>&quot; については、Scalaユーザとは十分共有できる感覚だと思いますよ</p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758513589854449664"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

lyrical_logicalさんのツイートを見て、お、追記しておこう、と思ったら、kmizuさんもツイートしてた。

Scalaのfor式が不便(Haskellのdoとreturnみたいに独立してない)というのはそう思うんだけど、言いたかったのはそういうとこじゃないんですよね。

どっちかというと

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr""><a href=""https://twitter.com/kmizu"">@kmizu</a> Haskellとか知ってる人には、flatMapはbindだしfor式はdo式の不便なものという感じで説明できるし、そういうの知らない人向けには、コレクションをfor式でまず扱えて、それに加えてflatMap, mapを実装した任意の型に適用できるので</p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758685993528471554"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

<blockquote class=""twitter-tweet"" data-lang=""ja""><p lang=""ja"" dir=""ltr""><a href=""https://twitter.com/kmizu"">@kmizu</a> implicit parameter≒型クラスということ、研究関係以外では最初は全然言ってなかったの（今はもう知られてるからそうでもないかもだけど）もそうだけど、小難しい（そうな）概念をそのままの語彙で導入していない点はOdersky先生のバランス感覚だと思ってる。</p>&mdash; 水島宏太（証明力強化月間） (@kmizu) <a href=""https://twitter.com/kmizu/status/758687045988392960"">2016年7月28日</a></blockquote>
<script async src=""//platform.twitter.com/widgets.js"" charset=""utf-8""></script>

このあたりが感覚を共有できないと思うあたりで。「コレクションをfor式でまず扱えて」まではいいんだけど、そこから「それに加えてflatMap, mapを実装した任意の型に適用できる」には飛躍があるよね、とか、implicit parameterって結局型クラス以外で使わないんだったら他に名前なかったのか、とかなんですよね。Scala(および設計者のOdersky先生)の選択なんで間違いだとかダメだとかイケてないとかDisりたいわけじゃなくて感覚の問題。
"
2015-03-14,,"*1426349452*[Haskell]遅延評価とfoldr/foldl
Haskellの遅延評価のイメージは「まず式を立てる（サンクを作る）けど、値の評価はまた別の話」。

<code>foldr</code>は

>|haskell|
  foldr f acc [x0, x1, x2, x3, ... , xn]
= x0 `f` (foldr f acc [x1, x2, x3, ... , xn])

= x0 `f` (x1 `f` (x2 `f` (x3 `f` ... `f` (xn `f` acc) ... )))
||<

こんな感じで、カッコの内側である右から計算するように見える式を立てるというイメージ。

が、評価は遅延評価なのでカッコの外側つまり左から評価するので、そのたびごとにリスト [x0, x1, ... , xn] を1つづつバラしていくことが可能。よって途中で打ち切る場合なら無限リストでも問題にならない。

<code>foldl</code>は

>|haskell|
  foldl f acc [x0, x1, x2, x3, ... , xn]
= foldl f (acc `f` x0) [x1, x2, x3, ... , xn]

= ... ((((acc `f` x0) `f` x1) `f` x2) `f` x3) `f` ...  `f` xn
||<

こんな感じで、カッコの内側である左から計算するように見える式を立てるいうイメージ。

が、評価は遅延評価なのでカッコの外側つまり右から評価するので、リスト [x0, x1, ... , xn] は全部バラさないといけないから、無限リストだと計算が終わらなくなるし、有限リストでもメモリをたくさん必要とする（メモリについては<code>foldl'</code>を使うという手があるが）。
",,"*1426349452*[Haskell]遅延評価とfoldr/foldl
Haskellの遅延評価のイメージは「まず式を立てる（サンクを作る）けど、値の評価はまた別の話」。

<code>foldr</code>は

>|haskell|
  foldr f acc [x0, x1, x2, x3, ... , xn]
= x0 `f` (foldr f acc [x1, x2, x3, ... , xn])

= x0 `f` (x1 `f` (x2 `f` (x3 `f` ... `f` (xn `f` acc) ... )))
||<

こんな感じで、カッコの内側である右から計算するように見える式を立てるというイメージ。

が、評価は遅延評価なのでカッコの外側つまり左から評価するので、そのたびごとにリスト [x0, x1, ... , xn] を1つづつバラしていくことが可能。よって途中で打ち切る場合なら無限リストでも問題にならない。

<code>foldl</code>は

>|haskell|
  foldl f acc [x0, x1, x2, x3, ... , xn]
= foldl f (acc `f` x0) [x1, x2, x3, ... , xn]

= ... ((((acc `f` x0) `f` x1) `f` x2) `f` x3) `f` ...  `f` xn
||<

こんな感じで、カッコの内側である左から計算するように見える式を立てるいうイメージ。

が、評価は遅延評価なのでカッコの外側つまり右から評価するので、リスト [x0, x1, ... , xn] は全部バラさないといけないから、無限リストだと計算が終わらなくなるし、有限リストでもメモリをたくさん必要とする（メモリについては<code>foldl'</code>を使うという手があるが）。
"
2014-04-29,,"*1398744070*[F#]貧者の型クラス

去年、こんなのをメモしてた。

- [http://haskell.g.hatena.ne.jp/matarillo/20130524/1369369774:title]
- [http://haskell.g.hatena.ne.jp/matarillo/20130527/1369636675:title]

これってオダスキー先生のこれ↓がベースなのか！

[http://lampwww.epfl.ch/~odersky/talks/wg2.8-boston06.pdf]

（追記）というわけで、[http://d.hatena.ne.jp/matarillo/20140429:title=C#で書いてみた]。",,"*1398744070*[F#]貧者の型クラス

去年、こんなのをメモしてた。

- [http://haskell.g.hatena.ne.jp/matarillo/20130524/1369369774:title]
- [http://haskell.g.hatena.ne.jp/matarillo/20130527/1369636675:title]

これってオダスキー先生のこれ↓がベースなのか！

[http://lampwww.epfl.ch/~odersky/talks/wg2.8-boston06.pdf]

（追記）というわけで、[http://d.hatena.ne.jp/matarillo/20140429:title=C#で書いてみた]。"
2014-02-17,,"*1392632700*[Haskell]OKWaveの質問

><blockquote cite=""http://okwave.jp/qa/q8468578.html"" title=""プログラミングHaskell 第8章関数型パーサー | その他(プログラミング)のQ&amp;A【OKWave】"">
<p>Graham Hutton著「プログラミングHaskell」の第8章関数型パーサーを勉強しています。
本の中にあるソースコードではdo記法などが使えないため、動きません。
サポートページにプログラムがあります。そのプログラムの意味がよくわかりません。
教えていただけないでしょうか。<p>
</blockquote><

プログラミングHaskellでHaskellを学んだ私が来ましたよ。
OKWaveにアカウントを作るつもりはないですが。

><blockquote>
<p>まず、newtypeで新しい型を定義していると思うのですが、右辺のPというのがなにかわかりません。<br />
また、instance Monad Parser whereやinstance MonadPlus Parser whereの意味もわかりません。
その下で、return, >=, mzero, mplusといった関数を定義する意味もわかりません。
よろしくおねがいします。</p>
</blockquote><

この本は、コードを写経して動かしながら学ぼうという向きにはつらくて、「第8章 関数型パーサー」の中に >>= とか return とか do記法とかが出てくるのだけど、そこには嘘があって、<strong>きちんとモナドとして定義された型でしかdo記法は使えない</strong>はずなのに、モナドとして型を定義する話は第8章にはぜんぜん出てこない。

第8章の頭には
>|haskell|
type Parser a = String -> [(a, String)]
||<
って書いてあるけど、<strong>これではdo記法は使えない</strong>のだ。

じゃあどう定義すればParser型でdo記法が使えるのか、というと、それがダウンロードできるサンプルコードでの定義のやり方なのだけど、この方法は第8章まで読んだだけでは理解できない。なぜなら、型クラスの話は「10.6 クラスとインスタンスの宣言」まで出てこないからだ。

その代わり、第10章まで読めば、

><blockquote>
<p>instance Monad Parser whereやinstance MonadPlus Parser whereの意味</p>
</blockquote><

とか、

><blockquote>
<p>その下で、return, >=, mzero, mplusといった関数を定義する意味</p>
</blockquote><

については理解できると思う。

とはいえ、

<strong>この本にはMonadPlusの説明なんか1行もでてこないけどな！</strong>

しかもしかも、サンプルコードには
>|haskell|
newtype Parser a = P (String -> [(a,String)])
||<
って書いてあるけど、

<strong>この本にはnewtypeキーワードの説明なんか1行もでてこないけどな！</strong>

というわけで、質問者のあなたがわからないのも当然ですわ。この本以外を使って自学するしかないです。

それではあんまりなので、少しだけ説明しましょうか。

:MonadPlus:モノイドの性質をあわせ持つモナドを表す型クラス。ざっくりいうと、足し算ができるモナド。この本のParser型では、パーサー同士を連結できるという意味。
:newtypeキーワード:dataキーワードに似た、新しい型を定義する文法。Pは値コンストラクタ。dataキーワードとの違いは、newtypeで定義された値コンストラクタは正格なこと。パターンマッチの動きも違ってくる。

とはいえ、ぶっちゃけこのあたりのことは、この本を読み進める上ではわからなくてもいいです。
",,"*1392632700*[Haskell]OKWaveの質問

><blockquote cite=""http://okwave.jp/qa/q8468578.html"" title=""プログラミングHaskell 第8章関数型パーサー | その他(プログラミング)のQ&amp;A【OKWave】"">
<p>Graham Hutton著「プログラミングHaskell」の第8章関数型パーサーを勉強しています。
本の中にあるソースコードではdo記法などが使えないため、動きません。
サポートページにプログラムがあります。そのプログラムの意味がよくわかりません。
教えていただけないでしょうか。<p>
</blockquote><

プログラミングHaskellでHaskellを学んだ私が来ましたよ。
OKWaveにアカウントを作るつもりはないですが。

><blockquote>
<p>まず、newtypeで新しい型を定義していると思うのですが、右辺のPというのがなにかわかりません。<br />
また、instance Monad Parser whereやinstance MonadPlus Parser whereの意味もわかりません。
その下で、return, >=, mzero, mplusといった関数を定義する意味もわかりません。
よろしくおねがいします。</p>
</blockquote><

この本は、コードを写経して動かしながら学ぼうという向きにはつらくて、「第8章 関数型パーサー」の中に >>= とか return とか do記法とかが出てくるのだけど、そこには嘘があって、<strong>きちんとモナドとして定義された型でしかdo記法は使えない</strong>はずなのに、モナドとして型を定義する話は第8章にはぜんぜん出てこない。

第8章の頭には
>|haskell|
type Parser a = String -> [(a, String)]
||<
って書いてあるけど、<strong>これではdo記法は使えない</strong>のだ。

じゃあどう定義すればParser型でdo記法が使えるのか、というと、それがダウンロードできるサンプルコードでの定義のやり方なのだけど、この方法は第8章まで読んだだけでは理解できない。なぜなら、型クラスの話は「10.6 クラスとインスタンスの宣言」まで出てこないからだ。

その代わり、第10章まで読めば、

><blockquote>
<p>instance Monad Parser whereやinstance MonadPlus Parser whereの意味</p>
</blockquote><

とか、

><blockquote>
<p>その下で、return, >=, mzero, mplusといった関数を定義する意味</p>
</blockquote><

については理解できると思う。

とはいえ、

<strong>この本にはMonadPlusの説明なんか1行もでてこないけどな！</strong>

しかもしかも、サンプルコードには
>|haskell|
newtype Parser a = P (String -> [(a,String)])
||<
って書いてあるけど、

<strong>この本にはnewtypeキーワードの説明なんか1行もでてこないけどな！</strong>

というわけで、質問者のあなたがわからないのも当然ですわ。この本以外を使って自学するしかないです。

それではあんまりなので、少しだけ説明しましょうか。

:MonadPlus:モノイドの性質をあわせ持つモナドを表す型クラス。ざっくりいうと、足し算ができるモナド。この本のParser型では、パーサー同士を連結できるという意味。
:newtypeキーワード:dataキーワードに似た、新しい型を定義する文法。Pは値コンストラクタ。dataキーワードとの違いは、newtypeで定義された値コンストラクタは正格なこと。パターンマッチの動きも違ってくる。

とはいえ、ぶっちゃけこのあたりのことは、この本を読み進める上ではわからなくてもいいです。
"
2013-11-22,,"*1385131413*[F#]F#の立ち位置
<del datetime=""2013-11-24T22:55:35+09:00"">いげ太さんがときどきぼやいてたかと思いますが</del>（追記: 不正確でした。いげ太さんからのコメントは下に）、「F#はなーんかMSに冷遇されてねえ？そのせいか、C#からF#に乗り換える人も少なくね？」みたいな話があります。
それは正しいといえば正しいのですが、コインの裏表のようにも思われて。

C#は、いろんな機能を貪欲にぶっこんできているわけじゃないですか。LINQみたいな関数型プログラミング由来の機能とか。asyncとか。

で、そのぶっこみかたというのが、割とコンパイラががんばるタイプの、キーワードが増えていくやつじゃないですか。

そんで、その様を「[http://bleis-tift.hatenablog.com/entry/asyncawaitdis:title=専用の構文をどんどん追加していくと、その言語にはどんどんゴミの山が積みあがっていきます。]」と厳しく指摘されたりするわけじゃないですか。

で、なんでC#はそういう（言わば、ダサい）方針なのかというと、言語仕様についてもユーザービリティテストを実施して、その結果がおれらみたいなボンクラにとって難しすぎるとわかると却下していたりするからなんだけど、その中に含まれる1要因として、IDE、というかVisual Studioで開発したりデバッグ時にステップ実行したりするときにわかりやすいかどうか、というのもあるんじゃないかなと。

イメージしてるのはC++のテンプレート機能なんだけど、あれ、エラーメッセージが宇宙レベルでヤバイって話があるじゃないですか。そんな機能、C#には絶対入らないですよ。まああれはコンパイル時のエラーですが……

C#に新機能が入るときは、VSの方も更新しないといけないことが多くて。逆に、VSの方で対応できない（つまり、「わかりやすく」見せることができない）ような機能は却下されたり、違う形に変更されたりするわけで。

F#の言語仕様はそこまでVSにべったりにならないのが、自由で良いところでもあり、C#ユーザーが移行してこないという意味で悪いところでもあるという。

あとはあれだ、VBな。そういうIDEべったりの言語の面倒は2つで十分ですよ！という。（それがしんどくてかどうかはわからないが、Roslynはどちらの言語もカバーするようになっている）

（追記）いげ太さんのツイート。

https://twitter.com/igeta/status/404427081200578560

https://twitter.com/igeta/status/404427405898432513

",,"*1385131413*[F#]F#の立ち位置
<del datetime=""2013-11-24T22:55:35+09:00"">いげ太さんがときどきぼやいてたかと思いますが</del>（追記: 不正確でした。いげ太さんからのコメントは下に）、「F#はなーんかMSに冷遇されてねえ？そのせいか、C#からF#に乗り換える人も少なくね？」みたいな話があります。
それは正しいといえば正しいのですが、コインの裏表のようにも思われて。

C#は、いろんな機能を貪欲にぶっこんできているわけじゃないですか。LINQみたいな関数型プログラミング由来の機能とか。asyncとか。

で、そのぶっこみかたというのが、割とコンパイラががんばるタイプの、キーワードが増えていくやつじゃないですか。

そんで、その様を「[http://bleis-tift.hatenablog.com/entry/asyncawaitdis:title=専用の構文をどんどん追加していくと、その言語にはどんどんゴミの山が積みあがっていきます。]」と厳しく指摘されたりするわけじゃないですか。

で、なんでC#はそういう（言わば、ダサい）方針なのかというと、言語仕様についてもユーザービリティテストを実施して、その結果がおれらみたいなボンクラにとって難しすぎるとわかると却下していたりするからなんだけど、その中に含まれる1要因として、IDE、というかVisual Studioで開発したりデバッグ時にステップ実行したりするときにわかりやすいかどうか、というのもあるんじゃないかなと。

イメージしてるのはC++のテンプレート機能なんだけど、あれ、エラーメッセージが宇宙レベルでヤバイって話があるじゃないですか。そんな機能、C#には絶対入らないですよ。まああれはコンパイル時のエラーですが……

C#に新機能が入るときは、VSの方も更新しないといけないことが多くて。逆に、VSの方で対応できない（つまり、「わかりやすく」見せることができない）ような機能は却下されたり、違う形に変更されたりするわけで。

F#の言語仕様はそこまでVSにべったりにならないのが、自由で良いところでもあり、C#ユーザーが移行してこないという意味で悪いところでもあるという。

あとはあれだ、VBな。そういうIDEべったりの言語の面倒は2つで十分ですよ！という。（それがしんどくてかどうかはわからないが、Roslynはどちらの言語もカバーするようになっている）

（追記）いげ太さんのツイート。

https://twitter.com/igeta/status/404427081200578560

https://twitter.com/igeta/status/404427405898432513

"
2013-06-21,,"*1371780388*[Haskell][F#]関数適用と関数合成

>http://d.hatena.ne.jp/toromoti/20130619/1371649079:title>
では、こんな関数があったとき
><pre>
 replicate 2 (product (map (*3) (zipWith max [1,2] [4,5])))
</pre><
関数合成をして、まっとうな記述をするとこう書けるらしい。
><pre>
 replicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]
</pre><
<<

Haskell学びたてのころは、どういう発想するとこうなるのか（そしてこの書き方の何が嬉しいのか）あまりわかってなかった。

F#を学んだことによって、

>|haskell|
 (replicate 2 << product << map (*3)) <| (zipWith max [1,2] [4,5])
||<

という目で見ることができるようになった。
演算子の記号が違うだけでだいぶ雰囲気が変わるもんだ。

でもやっぱりF#みたいに左から書き、左から読みたいな。

>|haskell|
(zipWith max [1,2] [4,5]) |> (map (*3) >> product >> replicate 2)
||<

んで合成関数を再利用しないんだったらもういっそ
>|haskell|
zipWith max [1,2] [4,5])
  |> map (*3) 
  |> product 
  |> replicate 2
||<
",,"*1371780388*[Haskell][F#]関数適用と関数合成

>http://d.hatena.ne.jp/toromoti/20130619/1371649079:title>
では、こんな関数があったとき
><pre>
 replicate 2 (product (map (*3) (zipWith max [1,2] [4,5])))
</pre><
関数合成をして、まっとうな記述をするとこう書けるらしい。
><pre>
 replicate 2 . product . map (*3) $ zipWith max [1,2] [4,5]
</pre><
<<

Haskell学びたてのころは、どういう発想するとこうなるのか（そしてこの書き方の何が嬉しいのか）あまりわかってなかった。

F#を学んだことによって、

>|haskell|
 (replicate 2 << product << map (*3)) <| (zipWith max [1,2] [4,5])
||<

という目で見ることができるようになった。
演算子の記号が違うだけでだいぶ雰囲気が変わるもんだ。

でもやっぱりF#みたいに左から書き、左から読みたいな。

>|haskell|
(zipWith max [1,2] [4,5]) |> (map (*3) >> product >> replicate 2)
||<

んで合成関数を再利用しないんだったらもういっそ
>|haskell|
zipWith max [1,2] [4,5])
  |> map (*3) 
  |> product 
  |> replicate 2
||<
"
2013-05-27,,"*1369636189*[F#]ジェネリックレコード型

[http://haskell.g.hatena.ne.jp/matarillo/20130524/1369369774:title=前回の記事]のど頭のこれ

>|ocaml|
type 'a Num = { ... }
||<

はジェネリックレコード型の定義のようだ。<code>'a list</code>とか<code>'a option</code>みたいに<code>'a Num</code>を定義している。
ところで、<code>Num&lt;'a&gt;</code>と書くのと同じなんだろうけど、そう書かない理由は何だろう。何か使い分けでもあるのかな。

*1369636675*[F#]前回の記事

個々の型に適合する関数群の実装をレコードのいちインスタンスとして渡してるわけね。サンプルでは、intならint、floatならfloat用の実装を用意している。これって目的は果たすのかな？
",,"*1369636189*[F#]ジェネリックレコード型

[http://haskell.g.hatena.ne.jp/matarillo/20130524/1369369774:title=前回の記事]のど頭のこれ

>|ocaml|
type 'a Num = { ... }
||<

はジェネリックレコード型の定義のようだ。<code>'a list</code>とか<code>'a option</code>みたいに<code>'a Num</code>を定義している。
ところで、<code>Num&lt;'a&gt;</code>と書くのと同じなんだろうけど、そう書かない理由は何だろう。何か使い分けでもあるのかな。

*1369636675*[F#]前回の記事

個々の型に適合する関数群の実装をレコードのいちインスタンスとして渡してるわけね。サンプルでは、intならint、floatならfloat用の実装を用意している。これって目的は果たすのかな？
"
2013-05-24,,"*1369369774*[F#]Poor Mans' Type Classes
[http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2228766-add-higher-order-generics-to-f-type-classes-:title=.NETのCLRに高階ジェネリクス（型クラス、高カインド）を！という要望はMSから断られているわけだけども]。

回答にある「Steffenがコメント欄に書いたようなやり方でエンコードできるよ」というのが気になった。

<script src=""https://gist.github.com/forki/1400378.js""></script>

時間を見つけてこのコードを勉強してやろう。

（おまけ）
[https://code.google.com/p/fsharp-typeclasses/:title]
[http://ntypeclasses.codeplex.com/:title]
",,"*1369369774*[F#]Poor Mans' Type Classes
[http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2228766-add-higher-order-generics-to-f-type-classes-:title=.NETのCLRに高階ジェネリクス（型クラス、高カインド）を！という要望はMSから断られているわけだけども]。

回答にある「Steffenがコメント欄に書いたようなやり方でエンコードできるよ」というのが気になった。

<script src=""https://gist.github.com/forki/1400378.js""></script>

時間を見つけてこのコードを勉強してやろう。

（おまけ）
[https://code.google.com/p/fsharp-typeclasses/:title]
[http://ntypeclasses.codeplex.com/:title]
"
2013-05-14,,"*1368556507*[F#]Google Code Jam Japan 2011 予選問題B

日にちを逆から計算するというのは早めに気づいたのだけど、Largeを解けるようにするのにえらく時間がかかった。

ループをk回ずつまわさないようにするために、消費期限が長いものから順に何杯ずつ飲むのかを計算して掛け算する方針。

<script src=""https://gist.github.com/matarillo/5578222.js""></script>
",,"*1368556507*[F#]Google Code Jam Japan 2011 予選問題B

日にちを逆から計算するというのは早めに気づいたのだけど、Largeを解けるようにするのにえらく時間がかかった。

ループをk回ずつまわさないようにするために、消費期限が長いものから順に何杯ずつ飲むのかを計算して掛け算する方針。

<script src=""https://gist.github.com/matarillo/5578222.js""></script>
"
2013-04-26,,"*1366943761*[Haskell]Haskellのポイントフリー
読みにくいからやめてほしい。
自己満足以外に実用的な意味があるのかどうか。
そもそも、セクションとかflipとかを使いまくらないと実現できないわけでしょう？
unlambdaやlazy kは実用言語じゃないでしょう？",,"*1366943761*[Haskell]Haskellのポイントフリー
読みにくいからやめてほしい。
自己満足以外に実用的な意味があるのかどうか。
そもそも、セクションとかflipとかを使いまくらないと実現できないわけでしょう？
unlambdaやlazy kは実用言語じゃないでしょう？"
2013-04-24,,"*1366757866*[F#]バス代の計算（第9回オフラインリアルタイムどう書くの問題）

[http://qiita.com/items/84255ac417ef25069a3b:title]

[http://qiita.com/items/7385db8cce051cb499d7:title]

*1366757867*[F#]ビットボンバーマン（第8回オフラインリアルタイムどう書くの問題）

[http://qiita.com/items/709d61dff282cff7a890:title]

[http://qiita.com/items/463311ff1ce4dd2cc943:title]
",,"*1366757866*[F#]バス代の計算（第9回オフラインリアルタイムどう書くの問題）

[http://qiita.com/items/84255ac417ef25069a3b:title]

[http://qiita.com/items/7385db8cce051cb499d7:title]

*1366757867*[F#]ビットボンバーマン（第8回オフラインリアルタイムどう書くの問題）

[http://qiita.com/items/709d61dff282cff7a890:title]

[http://qiita.com/items/463311ff1ce4dd2cc943:title]
"
2013-04-22,,"*1366595635*[F#]ポーカーの役判定（第10回オフラインリアルタイムどう書くの参考問題）

haskellグループなのにF#のエントリ。大目に見てね。

F#の練習に
[http://qiita.com/items/d819d1e5f2378317511e:title]
の問題を解いてみた。
（横浜へなちょこプログラミング勉強会には参加したことないですが……横からすみません）

[http://qiita.com/items/80c2c22d3224cb7c448c:title]

以下、頭の中をトレース出力。

**型を用意

手は5枚のカードから構成され、カードはスート（絵柄マーク）とランク（番号）を持っている。

スートは列挙型でもいいんだけど、整数値を使うことはなさそうなので値を指定しない。こうするとSuit型は判別共用体になるのかな。

>|ocaml|
type Suit = Spade | Heart | Diamond | Club
||<

ランクを数値型や列挙型にするかどうかかなり悩んだが、今回はそうしなかった。なぜかというとAの存在。
Aって1にも14にもなるカードなのだが、そのロジックをどこに入れるかが悩ましい。
とりあえず Rank -> int list という変換関数があれば何とかなるかなと目星をつけ、こちらも判別共用体に。

>|ocaml|
type Rank = R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | RJ | RQ | RK | RA
||<

カードはタプルの別名。
そして、さっきの変換関数はカードに対して定義することにした。
Aの特別扱いはここに反映される。

>|ocaml|
type Card = Rank * Suit
let cardToNums (c:Card) =
  match fst c with
  | R2  -> [2]
  | R3  -> [3]
  | R4  -> [4]
  | R5  -> [5]
  | R6  -> [6]
  | R7  -> [7]
  | R8  -> [8]
  | R9  -> [9]
  | R10 -> [10]
  | RJ  -> [11]
  | RQ  -> [12]
  | RK  -> [13]
  | RA  -> [1;14]
||<

手はカード5枚。リストにするかどうか迷った（ロジック上はリストの方が扱いやすい）が、5枚というのを明確にしたかったのでタプルにしてみた。
なんだか無駄なような気はするが。

>|ocaml|
type Hand = Card * Card * Card * Card * Card
let toList (c0,c1,c2,c3,c4) = [c0;c1;c2;c3;c4]
||<

** 役の判定ロジック

最初は、役をCategory型として判別共用体で定義した上で、Card -> Category list という判定関数を書こうかなと考えた。
次に、if文を並べて Card -> Category にしてもいいやと考え、実際に実装してみた。
しかし、最後に求められる出力は ""RF"" とか ""-"" といった文字列なので、Category -> string も必要になった。
なんだかばからしくなったので、Category型を排除して、
その代わりにアクティブパターンで役を判定し、文字列に変換するようにした。

>|ocaml|
let (|Flush|_|)             : Hand -> unit option = ????
let (|Straight|_|)          : Hand -> unit option = ????
let (|StraightFlush|_|)     : Hand -> unit option = ????
let (|RoyalFlush|_|)        : Hand -> unit option = ????
let (|FourFlush|_|)         : Hand -> unit option = ????
let (|FourStraight|_|)      : Hand -> unit option = ????
let (|FourStraightFlush|_|) : Hand -> unit option = ????

let show (h:Hand) =
  match h with
  | RoyalFlush        -> ""RF""
  | StraightFlush     -> ""SF""
  | Flush             -> ""FL""
  | Straight          -> ""ST""
  | FourStraightFlush -> ""4SF""
  | FourFlush         -> ""4F""
  | FourStraight      -> ""4S""
  | _                 -> ""-""
||<

役の強さはこの show 関数に埋め込まれている（上から順に強い）。

（書き途中）
",,"*1366595635*[F#]ポーカーの役判定（第10回オフラインリアルタイムどう書くの参考問題）

haskellグループなのにF#のエントリ。大目に見てね。

F#の練習に
[http://qiita.com/items/d819d1e5f2378317511e:title]
の問題を解いてみた。
（横浜へなちょこプログラミング勉強会には参加したことないですが……横からすみません）

[http://qiita.com/items/80c2c22d3224cb7c448c:title]

以下、頭の中をトレース出力。

**型を用意

手は5枚のカードから構成され、カードはスート（絵柄マーク）とランク（番号）を持っている。

スートは列挙型でもいいんだけど、整数値を使うことはなさそうなので値を指定しない。こうするとSuit型は判別共用体になるのかな。

>|ocaml|
type Suit = Spade | Heart | Diamond | Club
||<

ランクを数値型や列挙型にするかどうかかなり悩んだが、今回はそうしなかった。なぜかというとAの存在。
Aって1にも14にもなるカードなのだが、そのロジックをどこに入れるかが悩ましい。
とりあえず Rank -> int list という変換関数があれば何とかなるかなと目星をつけ、こちらも判別共用体に。

>|ocaml|
type Rank = R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 | R10 | RJ | RQ | RK | RA
||<

カードはタプルの別名。
そして、さっきの変換関数はカードに対して定義することにした。
Aの特別扱いはここに反映される。

>|ocaml|
type Card = Rank * Suit
let cardToNums (c:Card) =
  match fst c with
  | R2  -> [2]
  | R3  -> [3]
  | R4  -> [4]
  | R5  -> [5]
  | R6  -> [6]
  | R7  -> [7]
  | R8  -> [8]
  | R9  -> [9]
  | R10 -> [10]
  | RJ  -> [11]
  | RQ  -> [12]
  | RK  -> [13]
  | RA  -> [1;14]
||<

手はカード5枚。リストにするかどうか迷った（ロジック上はリストの方が扱いやすい）が、5枚というのを明確にしたかったのでタプルにしてみた。
なんだか無駄なような気はするが。

>|ocaml|
type Hand = Card * Card * Card * Card * Card
let toList (c0,c1,c2,c3,c4) = [c0;c1;c2;c3;c4]
||<

** 役の判定ロジック

最初は、役をCategory型として判別共用体で定義した上で、Card -> Category list という判定関数を書こうかなと考えた。
次に、if文を並べて Card -> Category にしてもいいやと考え、実際に実装してみた。
しかし、最後に求められる出力は ""RF"" とか ""-"" といった文字列なので、Category -> string も必要になった。
なんだかばからしくなったので、Category型を排除して、
その代わりにアクティブパターンで役を判定し、文字列に変換するようにした。

>|ocaml|
let (|Flush|_|)             : Hand -> unit option = ????
let (|Straight|_|)          : Hand -> unit option = ????
let (|StraightFlush|_|)     : Hand -> unit option = ????
let (|RoyalFlush|_|)        : Hand -> unit option = ????
let (|FourFlush|_|)         : Hand -> unit option = ????
let (|FourStraight|_|)      : Hand -> unit option = ????
let (|FourStraightFlush|_|) : Hand -> unit option = ????

let show (h:Hand) =
  match h with
  | RoyalFlush        -> ""RF""
  | StraightFlush     -> ""SF""
  | Flush             -> ""FL""
  | Straight          -> ""ST""
  | FourStraightFlush -> ""4SF""
  | FourFlush         -> ""4F""
  | FourStraight      -> ""4S""
  | _                 -> ""-""
||<

役の強さはこの show 関数に埋め込まれている（上から順に強い）。

（書き途中）
"
2013-04-09,,"*1365517066*[Haskell][F#]HaskellとF#の適当な比較

<script src=""https://gist.github.com/matarillo/5345227.js""></script>",,"*1365517066*[Haskell][F#]HaskellとF#の適当な比較

<script src=""https://gist.github.com/matarillo/5345227.js""></script>"
2013-04-03,,"*1364882565*[F#]サンク メモ3

何度も書いているのは、[http://d.hatena.ne.jp/itchyny/20130209/1360417348:title]を読んだから。

>|ocaml|
let rec foldr = T (fun _ (k : Thunk<Thunk<'a> -> Thunk<'b> -> 'b>) (z : Thunk<'b>) (list : Thunk<TList<'a>>) ->
    let rec go xs =
        match eval xs with
        | Nil -> z
        | Cons (y, ys) -> apply (apply k y) (go ys)
    eval (go list))

let k = T (fun _ x ys -> (eval x) :: (eval ys))
let z = T (fun _ -> [])
let list3 = eval (apply (apply (apply foldr k) z) list2)
printfn ""%A"" list3
||<
",,"*1364882565*[F#]サンク メモ3

何度も書いているのは、[http://d.hatena.ne.jp/itchyny/20130209/1360417348:title]を読んだから。

>|ocaml|
let rec foldr = T (fun _ (k : Thunk<Thunk<'a> -> Thunk<'b> -> 'b>) (z : Thunk<'b>) (list : Thunk<TList<'a>>) ->
    let rec go xs =
        match eval xs with
        | Nil -> z
        | Cons (y, ys) -> apply (apply k y) (go ys)
    eval (go list))

let k = T (fun _ x ys -> (eval x) :: (eval ys))
let z = T (fun _ -> [])
let list3 = eval (apply (apply (apply foldr k) z) list2)
printfn ""%A"" list3
||<
"
2013-04-02,,"*1364857700*[F#]F#の範囲演算子が遅かった

コードは、「[http://d.hatena.ne.jp/sumim/20130210/p1:title=セクシー素数ベンチ（の非効率な実装）]」を移植したもの。

>|ocaml|
open System.Linq

let isPrime n =  Enumerable.Range(2, n - 2) // {2..n-1}
              |> Seq.forall (fun i -> n % i <> 0)

let sexyPrimes n =  Enumerable.Range(9, n - 8) // {9..n}
                 |> Seq.map (fun i -> [|i-6; i|])
                 |> Seq.filter (fun i -> Array.forall isPrime i)

[<EntryPoint>]
let main args =
    let sw = new System.Diagnostics.Stopwatch()
    sw.Start()
    let c = sexyPrimes 100000 |> Seq.length
    sw.Stop()
    printfn ""%A"" sw.Elapsed
    printfn ""%A"" c
    0
||<

<code>Enumerable.Range</code>を使うと6秒強で終わる処理なのに、<code>{..}</code>を使うと46秒程度かかってしまう。

rst76が
>>
自分の中で、F#の内包表記は使わないというルールができつつあります。
<<
と書いてたけど、シーケンスの範囲演算子も使わないほうがいいのかな……
どうも、F#が作ってくれるシーケンスが重そうだ（シーケンスが返すEnumeratorが重そう）。

（追記）などとぼやいていたら、殺伐としたTLにMSMVP for <s>VBA</s>F#が登場!

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      そうか F# のシーケンス（が返すEnumerator）がぽっちゃり実装なんだな。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/318990829542838272"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">16:38:34</span></a> <span class=""twitter-detail-info-source"">via web</span>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      自己解決にめげずにコメント付けに行くべきかどうか。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319006910860902401"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">17:42:29</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"" target=""_top"">igeta</a> R!F!C! R!F!C!
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/319007723230490624"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">17:45:42</span></a> <span class=""twitter-detail-info-source"">via web</span> to @<a href=""https://twitter.com/igeta/status/319006910860902401"" class=""twitter-user-screen-name"">igeta</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"" target=""_top"">matarillo</a> let range n len = Seq.init len ((+) n) とかでやってみるとまた一段と遅くなるのでマジオヌヌメ。 #取り急ぎご報告まで
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319015526443667456"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">18:16:43</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span> to @<a href=""https://twitter.com/matarillo/status/319007723230490624"" class=""twitter-user-screen-name"">matarillo</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"" target=""_top"">igeta</a> 120秒を超えました!
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/319028811016593409"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:09:30</span></a> <span class=""twitter-detail-info-source"">via web</span> to @<a href=""https://twitter.com/igeta/status/319015526443667456"" class=""twitter-user-screen-name"">igeta</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"" target=""_top"">matarillo</a> そして let range n m = Seq.unfold (fun n -&gt; if n &lt;= m then Some (n, n+1) else None) n にするとちょっとマシになるっていう。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319030208957128704"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:15:03</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span> to @<a href=""https://twitter.com/matarillo/status/319028811016593409"" class=""twitter-user-screen-name"">matarillo</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"" target=""_top"">igeta</a> 18秒を切りました!
結構変わるものですね。なんか遅いなーと思ったらプロファイル取ったりfscのソースを眺めたりして、自分のコードを書き換えないといけませんね (fscを改造して賢くできるような技能は持ってないので)
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/319036006609321985"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:38:06</span></a> <span class=""twitter-detail-info-source"">via web</span> to @<a href=""https://twitter.com/igeta/status/319030208957128704"" class=""twitter-user-screen-name"">igeta</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"" target=""_top"">matarillo</a> シーケンス式イコール悪ってわけでもないんですよーと言いたかったのです！　むしろ根深い。。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319037337130647552"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:43:23</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span> to @<a href=""https://twitter.com/matarillo/status/319036006609321985"" class=""twitter-user-screen-name"">matarillo</a>
    </p>
  </div>
</div><

大変参考になりました。ありがとうございましたいげ太さん！
",,"*1364857700*[F#]F#の範囲演算子が遅かった

コードは、「[http://d.hatena.ne.jp/sumim/20130210/p1:title=セクシー素数ベンチ（の非効率な実装）]」を移植したもの。

>|ocaml|
open System.Linq

let isPrime n =  Enumerable.Range(2, n - 2) // {2..n-1}
              |> Seq.forall (fun i -> n % i <> 0)

let sexyPrimes n =  Enumerable.Range(9, n - 8) // {9..n}
                 |> Seq.map (fun i -> [|i-6; i|])
                 |> Seq.filter (fun i -> Array.forall isPrime i)

[<EntryPoint>]
let main args =
    let sw = new System.Diagnostics.Stopwatch()
    sw.Start()
    let c = sexyPrimes 100000 |> Seq.length
    sw.Stop()
    printfn ""%A"" sw.Elapsed
    printfn ""%A"" c
    0
||<

<code>Enumerable.Range</code>を使うと6秒強で終わる処理なのに、<code>{..}</code>を使うと46秒程度かかってしまう。

rst76が
>>
自分の中で、F#の内包表記は使わないというルールができつつあります。
<<
と書いてたけど、シーケンスの範囲演算子も使わないほうがいいのかな……
どうも、F#が作ってくれるシーケンスが重そうだ（シーケンスが返すEnumeratorが重そう）。

（追記）などとぼやいていたら、殺伐としたTLにMSMVP for <s>VBA</s>F#が登場!

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      そうか F# のシーケンス（が返すEnumerator）がぽっちゃり実装なんだな。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/318990829542838272"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">16:38:34</span></a> <span class=""twitter-detail-info-source"">via web</span>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      自己解決にめげずにコメント付けに行くべきかどうか。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319006910860902401"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">17:42:29</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"" target=""_top"">igeta</a> R!F!C! R!F!C!
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/319007723230490624"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">17:45:42</span></a> <span class=""twitter-detail-info-source"">via web</span> to @<a href=""https://twitter.com/igeta/status/319006910860902401"" class=""twitter-user-screen-name"">igeta</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"" target=""_top"">matarillo</a> let range n len = Seq.init len ((+) n) とかでやってみるとまた一段と遅くなるのでマジオヌヌメ。 #取り急ぎご報告まで
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319015526443667456"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">18:16:43</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span> to @<a href=""https://twitter.com/matarillo/status/319007723230490624"" class=""twitter-user-screen-name"">matarillo</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"" target=""_top"">igeta</a> 120秒を超えました!
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/319028811016593409"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:09:30</span></a> <span class=""twitter-detail-info-source"">via web</span> to @<a href=""https://twitter.com/igeta/status/319015526443667456"" class=""twitter-user-screen-name"">igeta</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"" target=""_top"">matarillo</a> そして let range n m = Seq.unfold (fun n -&gt; if n &lt;= m then Some (n, n+1) else None) n にするとちょっとマシになるっていう。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319030208957128704"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:15:03</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span> to @<a href=""https://twitter.com/matarillo/status/319028811016593409"" class=""twitter-user-screen-name"">matarillo</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-right"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"">
      <img src=""https://si0.twimg.com/profile_images/3441716366/72180e0f757b0530feaeb9190e9b585d_normal.jpeg"" alt=""matarillo"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"" target=""_top"">igeta</a> 18秒を切りました!
結構変わるものですね。なんか遅いなーと思ったらプロファイル取ったりfscのソースを眺めたりして、自分のコードを書き換えないといけませんね (fscを改造して賢くできるような技能は持ってないので)
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/matarillo/status/319036006609321985"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:38:06</span></a> <span class=""twitter-detail-info-source"">via web</span> to @<a href=""https://twitter.com/igeta/status/319030208957128704"" class=""twitter-user-screen-name"">igeta</a>
    </p>
  </div>
</div><

><div class=""twitter-detail twitter-detail-left"">
  <div class=""twitter-detail-user"">
    <a class=""twitter-user-screen-name"" href=""https://twitter.com/igeta"">
      <img src=""https://si0.twimg.com/profile_images/3461222648/6876a2f0f92a5bded199f4cf620ca904_normal.png"" alt=""igeta"" height=""48"" width=""48"">
    </a>
  </div>
  <div class=""twitter-detail-tweet"">
    <p class=""twitter-detail-text"">
      @<a class=""twitter-user-screen-name"" href=""https://twitter.com/matarillo"" target=""_top"">matarillo</a> シーケンス式イコール悪ってわけでもないんですよーと言いたかったのです！　むしろ根深い。。
    </p>
    <p class=""twitter-detail-info"">
      <a href=""https://twitter.com/igeta/status/319037337130647552"" class=""twitter-detail-info-permalink""><span class=""twitter-detail-info-date"">2013-04-02</span> <span class=""twitter-detail-info-time"">19:43:23</span></a> <span class=""twitter-detail-info-source"">via <a href=""https://twitter.com/download/iphone"" rel=""nofollow"">Twitter for iPhone</a></span> to @<a href=""https://twitter.com/matarillo/status/319036006609321985"" class=""twitter-user-screen-name"">matarillo</a>
    </p>
  </div>
</div><

大変参考になりました。ありがとうございましたいげ太さん！
"
2013-04-01,,"*1364803295*[F#]サンク メモ2

>|ocaml|
type Thunk<'a> = T of (unit -> 'a) 

let eval (T x) = x ()
let apply f (x : Thunk<'a>) = T (fun _ -> (eval f) x)

let one = T (fun _ -> 1)
let two = T (fun _ -> 2)
let add = T (fun _ x  y -> eval x + eval y)

let three = apply (apply add one) two
printfn ""%A"" (eval three)

type TList<'a> =
    | Nil
    | Cons of Thunk<'a> * Thunk<TList<'a>>
let nil = T (fun _ -> Nil)
let cons = T (fun _ x xs -> Cons (x, xs))

let zero = T (fun _ -> 0)
let list1 = apply (apply cons zero) nil
printfn ""%A"" (eval list1)

let rec inf1 = T (fun _ -> Cons (zero, inf1))
printfn ""%A"" (eval inf1)

let rec map = T (fun _ f list ->
    match eval list with
    | Cons (x, xs) -> Cons ((apply f x), (apply (apply map f) xs))
    | Nil          -> Nil)

let rec take = T (fun _ n list ->
    match eval list with
    | Cons (x, xs) -> let n' = eval n
                      if n' <= 0
                          then Nil
                          else Cons (x, apply (apply take (T (fun _ -> n' - 1))) xs)
    | Nil          -> Nil)

let addOne = apply add one
let rec inf2 = T (fun _ -> Cons (zero, apply (apply map addOne) inf2))
let twenty = T (fun _ -> 20)
let list2 = apply (apply take twenty) inf2

let rec evalList list =
    match eval list with
    | Cons (x, xs) -> (eval x) :: (evalList xs)
    | Nil          -> []
printfn ""%A"" (evalList list2)
||<
",,"*1364803295*[F#]サンク メモ2

>|ocaml|
type Thunk<'a> = T of (unit -> 'a) 

let eval (T x) = x ()
let apply f (x : Thunk<'a>) = T (fun _ -> (eval f) x)

let one = T (fun _ -> 1)
let two = T (fun _ -> 2)
let add = T (fun _ x  y -> eval x + eval y)

let three = apply (apply add one) two
printfn ""%A"" (eval three)

type TList<'a> =
    | Nil
    | Cons of Thunk<'a> * Thunk<TList<'a>>
let nil = T (fun _ -> Nil)
let cons = T (fun _ x xs -> Cons (x, xs))

let zero = T (fun _ -> 0)
let list1 = apply (apply cons zero) nil
printfn ""%A"" (eval list1)

let rec inf1 = T (fun _ -> Cons (zero, inf1))
printfn ""%A"" (eval inf1)

let rec map = T (fun _ f list ->
    match eval list with
    | Cons (x, xs) -> Cons ((apply f x), (apply (apply map f) xs))
    | Nil          -> Nil)

let rec take = T (fun _ n list ->
    match eval list with
    | Cons (x, xs) -> let n' = eval n
                      if n' <= 0
                          then Nil
                          else Cons (x, apply (apply take (T (fun _ -> n' - 1))) xs)
    | Nil          -> Nil)

let addOne = apply add one
let rec inf2 = T (fun _ -> Cons (zero, apply (apply map addOne) inf2))
let twenty = T (fun _ -> 20)
let list2 = apply (apply take twenty) inf2

let rec evalList list =
    match eval list with
    | Cons (x, xs) -> (eval x) :: (evalList xs)
    | Nil          -> []
printfn ""%A"" (evalList list2)
||<
"
2013-03-29,,"*1364542170*[Haskell]サンク メモ

Haskellで書いてもしょうがないのであとでF#にするか？
正格評価の言語だとunitがアウトだなきっと。最初から() -> a で渡してやらないと。

>|haskell|
newtype Thunk a =  T (() -> a)
unit            :: a -> Thunk a
unit x          =  T (\y -> x)
eval            :: Thunk a -> a
eval (T x)      =  x ()
apply           :: (Thunk (Thunk a -> b)) -> Thunk a -> Thunk b
apply f x       =  unit (eval f x)

 1
two = unit 2
add = unit (\x -> \y -> eval x + eval y)
three = add `apply` one `apply` two
||<
",,"*1364542170*[Haskell]サンク メモ

Haskellで書いてもしょうがないのであとでF#にするか？
正格評価の言語だとunitがアウトだなきっと。最初から() -> a で渡してやらないと。

>|haskell|
newtype Thunk a =  T (() -> a)
unit            :: a -> Thunk a
unit x          =  T (\y -> x)
eval            :: Thunk a -> a
eval (T x)      =  x ()
apply           :: (Thunk (Thunk a -> b)) -> Thunk a -> Thunk b
apply f x       =  unit (eval f x)

 1
two = unit 2
add = unit (\x -> \y -> eval x + eval y)
three = add `apply` one `apply` two
||<
"
2012-12-02,,"*1354408848*[Haskell]参考になった
[http://d.hatena.ne.jp/notogawa/20121201/1354389374:title]
hoogleの使い方（型から引く）という技もそうだが、トップダウン思考が参考になった。",,"*1354408848*[Haskell]参考になった
[http://d.hatena.ne.jp/notogawa/20121201/1354389374:title]
hoogleの使い方（型から引く）という技もそうだが、トップダウン思考が参考になった。"
2012-11-28,,"*1354078409*[Haskell]モナド版ParserをApplicative Parserにしてみる

[http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html:title=Applicative]の勉強のため、[http://haskell.g.hatena.ne.jp/matarillo/20110620/1308581970:title=プログラミングHaskellのパーサー]をApplicativeに変更してみた。
書いていると、Applicativeというよりは[http://itpro.nikkeibp.co.jp/article/COLUMN/20120110/378061/?ST=develop&P=4:title=Alternative]にするべきと分かったので、そのように実装した。

>|haskell|
import Data.Char
import Control.Applicative

newtype Parser a              =  P (String -> [(a,String)])

instance Functor Parser where
   fmap f p                   =  P (\inp -> case parse p inp of
                                                []        -> []
                                                [(v,out)] -> [(f v, out)])
instance Applicative Parser where
   pure v                     =  P (\inp -> [(v,inp)])
   p <*> q                    =  P (\inp -> case parse p inp of
                                                []        -> []
                                                [(v,out)] -> parse (fmap v q) out)

instance Alternative Parser where
   empty                      =  P (const [])
   p <|> q                    =  P (\inp -> case parse p inp of
                                                []        -> parse q inp
                                                x         -> x)

parse                         :: Parser a -> String -> [(a,String)]
parse (P p) inp               =  p inp


-- モナド版だと sat は item + 条件分岐
-- しかし、Applicativeでは条件分岐できないので
-- itemの部分も合わせてsatを書くしかなさそう


sat                           :: (Char -> Bool) -> Parser Char
sat p                         =  P (\inp -> case inp of
                                                []     -> []
                                                (x:xs) -> if p x then [(x,xs)] else [])


digit                         :: Parser Char
digit                         =  sat isDigit

lower                         :: Parser Char
lower                         =  sat isLower

upper                         :: Parser Char
upper                         =  sat isUpper

letter                        :: Parser Char
letter                        =  sat isAlpha

alphanum                      :: Parser Char
alphanum                      =  sat isAlphaNum

char                          :: Char -> Parser Char
char x                        =  sat (== x)

string                        :: String -> Parser String
string []                     =  pure []
string (x:xs)                 =  (:) <$> char x <*> string xs


-- Alternativeの関数を使用するのでmanyとmany1は不要


ident                         :: Parser String
ident                         = (:) <$> lower <*> many alphanum

nat                           :: Parser Int
nat                           =  read <$> some digit

int                           :: Parser Int
int                           =  negate <$> (char '-' *> nat) <|> nat

space                         :: Parser ()
space                         =  many (sat isSpace) *> pure ()

token                         :: Parser a -> Parser a
token p                       =  space *> p <* space

identifier                    :: Parser String
identifier                    =  token ident

natural                       :: Parser Int
natural                       =  token nat

integer                       :: Parser Int
integer                       =  token int

symbol                        :: String -> Parser String
symbol xs                     =  token (string xs)
||<
",,"*1354078409*[Haskell]モナド版ParserをApplicative Parserにしてみる

[http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html:title=Applicative]の勉強のため、[http://haskell.g.hatena.ne.jp/matarillo/20110620/1308581970:title=プログラミングHaskellのパーサー]をApplicativeに変更してみた。
書いていると、Applicativeというよりは[http://itpro.nikkeibp.co.jp/article/COLUMN/20120110/378061/?ST=develop&P=4:title=Alternative]にするべきと分かったので、そのように実装した。

>|haskell|
import Data.Char
import Control.Applicative

newtype Parser a              =  P (String -> [(a,String)])

instance Functor Parser where
   fmap f p                   =  P (\inp -> case parse p inp of
                                                []        -> []
                                                [(v,out)] -> [(f v, out)])
instance Applicative Parser where
   pure v                     =  P (\inp -> [(v,inp)])
   p <*> q                    =  P (\inp -> case parse p inp of
                                                []        -> []
                                                [(v,out)] -> parse (fmap v q) out)

instance Alternative Parser where
   empty                      =  P (const [])
   p <|> q                    =  P (\inp -> case parse p inp of
                                                []        -> parse q inp
                                                x         -> x)

parse                         :: Parser a -> String -> [(a,String)]
parse (P p) inp               =  p inp


-- モナド版だと sat は item + 条件分岐
-- しかし、Applicativeでは条件分岐できないので
-- itemの部分も合わせてsatを書くしかなさそう


sat                           :: (Char -> Bool) -> Parser Char
sat p                         =  P (\inp -> case inp of
                                                []     -> []
                                                (x:xs) -> if p x then [(x,xs)] else [])


digit                         :: Parser Char
digit                         =  sat isDigit

lower                         :: Parser Char
lower                         =  sat isLower

upper                         :: Parser Char
upper                         =  sat isUpper

letter                        :: Parser Char
letter                        =  sat isAlpha

alphanum                      :: Parser Char
alphanum                      =  sat isAlphaNum

char                          :: Char -> Parser Char
char x                        =  sat (== x)

string                        :: String -> Parser String
string []                     =  pure []
string (x:xs)                 =  (:) <$> char x <*> string xs


-- Alternativeの関数を使用するのでmanyとmany1は不要


ident                         :: Parser String
ident                         = (:) <$> lower <*> many alphanum

nat                           :: Parser Int
nat                           =  read <$> some digit

int                           :: Parser Int
int                           =  negate <$> (char '-' *> nat) <|> nat

space                         :: Parser ()
space                         =  many (sat isSpace) *> pure ()

token                         :: Parser a -> Parser a
token p                       =  space *> p <* space

identifier                    :: Parser String
identifier                    =  token ident

natural                       :: Parser Int
natural                       =  token nat

integer                       :: Parser Int
integer                       =  token int

symbol                        :: String -> Parser String
symbol xs                     =  token (string xs)
||<
"
2012-10-14,,"*1350226760*[Haskell]C#/Java頭の私がHaskellに戸惑ったところ（ただしモナドを除く）

いろいろあるが、以下の3つかな。

**値コンストラクタは型ではない

たとえば、CircleとRectangleを含むShapeという独自のデータ型を定義するとする。Circleは半径を、Rectangleは幅と高さを持つとする。そういうデータ型はHaskellだとこんな感じで定義する。
>|haskell|
data Shape = Circle Float | Rectangle Float Float
||<
同じようなデータ型をたとえばC#で定義するとするなら

>|cs|
interface Shape {}

class Circle : Shape
{
    public float Radius;
}

class Rectangle : Shape
{
    public float Width;
    public float Height;
}
||<

みたいな感じになる（Haskellの場合フィールド名を定義しなくてもいいが、それはまあ気にしない）。

C#/Javaの場合、CircleやRectangleはクラス。クラスがフィールド定義をもつ。Haskellの場合、CircleやRectangleは値コンストラクタと呼ぶ。値コンストラクタがフィールド定義を持つ。

C#/Javaの場合、クラスも型なんだけど、Haskellの場合、型はあくまでShapeだけ。値コンストラクタは型ではない。

Haskellの場合CircleやRectangleは型じゃないんで、関数を定義するときは引数や戻り値の型はあくまでShape。とはいえ、Circleコンストラクタで生成された値とRectangleコンストラクタで生成された値はきちんと区別する（じゃないとフィールドにアクセスもできない）。区別する方法はパターンマッチ。

>|haskell|
area               :: Shape -> Float
area Circle r      =  pi * r * r
||<

上のように定義した関数 <code> area :: Shape -> Float</code>にRectangleで生成された値を渡してもコンパイルは通るが、実装が無いため実行時エラーになる。

** 型クラスのインスタンスは型

Haskellには型クラスというものがあって、型クラスのインスタンス（実例）は型。これはC#/Java頭だと用語がややこしい。

型が型クラスのインスタンスとなるとき、型クラスが宣言しているすべての関数の実装が定義されていなければならない。このあたりの雰囲気は、C#/Javaで言えば、interfaceで宣言されているメソッドの実装をclassが提供しなければならないところに似ている。

ただし、型クラスには関数のデフォルト実装を定義することができる。そういう観点ではC#/Javaのabstract classにも似ているかも。

さらに、ある型クラスは別の型クラスを継承することができる。C#/Javaで言えば、interfaceがinterfaceを継承するようなもの。

ともあれ、クラスとインスタンスの用語の使い方が違うことに注意しないと混乱の元。

Shape型がEq型クラスのインスタンスであることを表すHaskellのコード。Eq型クラスには<code>==</code>と<code>/=</code>のデフォルト実装が用意されているが、循環定義なので、Eq型クラスのインスタンスには少なくとも片方の実装を定義しないと実行時エラーになる((deriving節を使って自動実装させることもできる))。

>|haskell|
instance Eq Shape where
  Circle r1       == Circle r2       = r1 == r2
  Rectangle w1 h1 == Rectangle w2 h2 = w1 == w2 && h1 == h2
  Circle _        == Rectangle _ _   = False
||<

ところで、C#/Javaでは、interfaceもabstract classもclassも型なんだけど、Haskellでは、型クラスは型ではなく、型制約。

>||
Prelude> :t (==)
(==) :: (Eq a) => a -> a -> Bool
||<

<code>(==)</code>の型を見ると分かるが、型aが型クラスEqのインスタンスであるという制約がついている。なので、<code>==</code>の右辺と左辺に違う型を渡すと、もしそれらが両方ともEqのインスタンスだったとしてもコンパイルエラーになる。

**遅延評価（非正格評価）

これが腑に落ちるには時間がかかった。なお、C#の遅延シーケンス(IEnumerable&lt;T&gt;)ともまったく違う。

>||
False && (True && True)
||<
という式があったとして、C#/Javaのような正格評価をする言語はカッコの内側から評価する。したがって、<code>(True && True)</code>がTrueになることを評価した上で、<code>False && True</code>を評価して、結果を得る。

ところがHaskellは、カッコの外側から評価を始める。つまり、カッコの中身が定まらない状態で、<code>False && ?</code>を評価する。そうすると、<code>&&</code>の左側がFalseなので、右側を評価するまでもなく結果がFalseであることがわかる。

<code>foldr</code>関数が無限リストに適用できるのは、この遅延評価があるからこそだ。<code>foldr</code>はこんな感じの再帰定義になっている。

>|haskell|
foldr f z (x:xs) =  f x (foldr f z xs)
||<

したがって、<code>[x0, x1, x2, x3, ...]</code>に適用すると、

>|haskell|
f x0 (f x1 (f x2 (f x3 ( ... ) ) ) )
||<
となるわけだが、遅延評価によりカッコの外側から評価されるので、無限リストであっても有限要素の評価で値が定まる場合はきちんと計算できるというわけ。右からの畳み込み関数だから右から評価すると思った？残念！左からでした！
",,"*1350226760*[Haskell]C#/Java頭の私がHaskellに戸惑ったところ（ただしモナドを除く）

いろいろあるが、以下の3つかな。

**値コンストラクタは型ではない

たとえば、CircleとRectangleを含むShapeという独自のデータ型を定義するとする。Circleは半径を、Rectangleは幅と高さを持つとする。そういうデータ型はHaskellだとこんな感じで定義する。
>|haskell|
data Shape = Circle Float | Rectangle Float Float
||<
同じようなデータ型をたとえばC#で定義するとするなら

>|cs|
interface Shape {}

class Circle : Shape
{
    public float Radius;
}

class Rectangle : Shape
{
    public float Width;
    public float Height;
}
||<

みたいな感じになる（Haskellの場合フィールド名を定義しなくてもいいが、それはまあ気にしない）。

C#/Javaの場合、CircleやRectangleはクラス。クラスがフィールド定義をもつ。Haskellの場合、CircleやRectangleは値コンストラクタと呼ぶ。値コンストラクタがフィールド定義を持つ。

C#/Javaの場合、クラスも型なんだけど、Haskellの場合、型はあくまでShapeだけ。値コンストラクタは型ではない。

Haskellの場合CircleやRectangleは型じゃないんで、関数を定義するときは引数や戻り値の型はあくまでShape。とはいえ、Circleコンストラクタで生成された値とRectangleコンストラクタで生成された値はきちんと区別する（じゃないとフィールドにアクセスもできない）。区別する方法はパターンマッチ。

>|haskell|
area               :: Shape -> Float
area Circle r      =  pi * r * r
||<

上のように定義した関数 <code> area :: Shape -> Float</code>にRectangleで生成された値を渡してもコンパイルは通るが、実装が無いため実行時エラーになる。

** 型クラスのインスタンスは型

Haskellには型クラスというものがあって、型クラスのインスタンス（実例）は型。これはC#/Java頭だと用語がややこしい。

型が型クラスのインスタンスとなるとき、型クラスが宣言しているすべての関数の実装が定義されていなければならない。このあたりの雰囲気は、C#/Javaで言えば、interfaceで宣言されているメソッドの実装をclassが提供しなければならないところに似ている。

ただし、型クラスには関数のデフォルト実装を定義することができる。そういう観点ではC#/Javaのabstract classにも似ているかも。

さらに、ある型クラスは別の型クラスを継承することができる。C#/Javaで言えば、interfaceがinterfaceを継承するようなもの。

ともあれ、クラスとインスタンスの用語の使い方が違うことに注意しないと混乱の元。

Shape型がEq型クラスのインスタンスであることを表すHaskellのコード。Eq型クラスには<code>==</code>と<code>/=</code>のデフォルト実装が用意されているが、循環定義なので、Eq型クラスのインスタンスには少なくとも片方の実装を定義しないと実行時エラーになる((deriving節を使って自動実装させることもできる))。

>|haskell|
instance Eq Shape where
  Circle r1       == Circle r2       = r1 == r2
  Rectangle w1 h1 == Rectangle w2 h2 = w1 == w2 && h1 == h2
  Circle _        == Rectangle _ _   = False
||<

ところで、C#/Javaでは、interfaceもabstract classもclassも型なんだけど、Haskellでは、型クラスは型ではなく、型制約。

>||
Prelude> :t (==)
(==) :: (Eq a) => a -> a -> Bool
||<

<code>(==)</code>の型を見ると分かるが、型aが型クラスEqのインスタンスであるという制約がついている。なので、<code>==</code>の右辺と左辺に違う型を渡すと、もしそれらが両方ともEqのインスタンスだったとしてもコンパイルエラーになる。

**遅延評価（非正格評価）

これが腑に落ちるには時間がかかった。なお、C#の遅延シーケンス(IEnumerable&lt;T&gt;)ともまったく違う。

>||
False && (True && True)
||<
という式があったとして、C#/Javaのような正格評価をする言語はカッコの内側から評価する。したがって、<code>(True && True)</code>がTrueになることを評価した上で、<code>False && True</code>を評価して、結果を得る。

ところがHaskellは、カッコの外側から評価を始める。つまり、カッコの中身が定まらない状態で、<code>False && ?</code>を評価する。そうすると、<code>&&</code>の左側がFalseなので、右側を評価するまでもなく結果がFalseであることがわかる。

<code>foldr</code>関数が無限リストに適用できるのは、この遅延評価があるからこそだ。<code>foldr</code>はこんな感じの再帰定義になっている。

>|haskell|
foldr f z (x:xs) =  f x (foldr f z xs)
||<

したがって、<code>[x0, x1, x2, x3, ...]</code>に適用すると、

>|haskell|
f x0 (f x1 (f x2 (f x3 ( ... ) ) ) )
||<
となるわけだが、遅延評価によりカッコの外側から評価されるので、無限リストであっても有限要素の評価で値が定まる場合はきちんと計算できるというわけ。右からの畳み込み関数だから右から評価すると思った？残念！左からでした！
"
2012-09-10,,"*1347256728*[Haskell]Haskell脳

<code>flip const</code>と<code>const id</code>が等価だってことは、Haskellになじんでくると素直に思い浮かんでくるものなのか？

命令型でいうと、<code>for</code>が<code>while</code>で書ける、みたいな感じで、プログラマの常識なのか？

もしそうなら、まだぜんぜんHaskell脳になってないな、おれの頭。

や、落ち着いて考えれば理解はできるよ。ただし、自分の中から出てこない、天下り的。

（追記）スターをもらったので補足しておくと、Haskell脳というよりはコンビネータ脳なのかも。
どちらにせよ、関数合成に慣れが必要に思う。",,"*1347256728*[Haskell]Haskell脳

<code>flip const</code>と<code>const id</code>が等価だってことは、Haskellになじんでくると素直に思い浮かんでくるものなのか？

命令型でいうと、<code>for</code>が<code>while</code>で書ける、みたいな感じで、プログラマの常識なのか？

もしそうなら、まだぜんぜんHaskell脳になってないな、おれの頭。

や、落ち着いて考えれば理解はできるよ。ただし、自分の中から出てこない、天下り的。

（追記）スターをもらったので補足しておくと、Haskell脳というよりはコンビネータ脳なのかも。
どちらにせよ、関数合成に慣れが必要に思う。"
2012-09-07,,"*1346991745*[Haskell]FunctorとApplicativeとMonad

ファクンタ⇒アプリカティブ⇒モナドの順で力強くなってることを、リストを例に考えてみる。

:ファンクタ:1つのリストに対して、1引数の変換(map)ができる。
:アプリカティブ:複数のリストに対して直積をとって、多引数の変換ができる。
:モナド:変換だけじゃなく、結果としてリストに入れるか入れないかの選択もできる。
",,"*1346991745*[Haskell]FunctorとApplicativeとMonad

ファクンタ⇒アプリカティブ⇒モナドの順で力強くなってることを、リストを例に考えてみる。

:ファンクタ:1つのリストに対して、1引数の変換(map)ができる。
:アプリカティブ:複数のリストに対して直積をとって、多引数の変換ができる。
:モナド:変換だけじゃなく、結果としてリストに入れるか入れないかの選択もできる。
"
2012-08-30,,"*1346308889*ラムダ計算とラムダ式とC#

[twitter:241023819035316224:detail]

あまり厳密ではないけど、ざっくり書いてみる。

**計算理論
-「計算」を数学的に厳密に定義することで、「計算」に何ができて何ができないのかを解き明かす理論。

**ラムダ計算
-計算理論で使われる1つのモデル。
-ラムダ式（≒1引数無名高階関数の定義）と簡約（≒関数が返す値の評価）ですべての計算を表現できるというもの。
-複数の引数を持つ関数はカリー化によって1引数関数として扱われる。
-ラムダ式がラムダ式を受け取ったりラムダ式を返したりできないと、理論が成立しない。
-型のないラムダ計算と、型付きラムダ計算の両方が研究されている。

**関数型言語
-ラムダ計算を理論的基盤としたプログラミング言語。
-ラムダ式という名前の無名関数を記述できる。たいてい複数の引数を持つラムダ式を定義できるが、常にカリー化されるかどうかは言語による。
-すべてをラムダ式で扱うのは冗長だし効率も悪いので、関数や変数やリテラルなど、ラムダ式以外の要素も使うことができる。
-とはいえ、ラムダ式に限らず、ほとんどあらゆるものが式である。
-あらゆるものが式なので、returnが不要。
-式を組み合わせることで計算手順を記述する。gotoが不要。
-高階関数（引数や戻り値として関数を扱う関数）を使ってプログラムを書くのが普通。
-プログラムの実行は式の評価とほぼ同義。


**C#やVB.NETのラムダ式
-関数型言語のラムダ式を参考にして取り込んだ、匿名メソッドを簡易に定義する機能。（式木も定義できるけど、そこは省略）
-カリー化はない。
-式として記述するならreturnを書かなくても値を返せる。
-関数型言語を参考にしたLINQで活躍。
-引数としてデリゲートを受け取るメソッドに渡すのに便利。そのようなメソッドは高階関数とみなせるが、それを意識する必要はほとんどない。
",,"*1346308889*ラムダ計算とラムダ式とC#

[twitter:241023819035316224:detail]

あまり厳密ではないけど、ざっくり書いてみる。

**計算理論
-「計算」を数学的に厳密に定義することで、「計算」に何ができて何ができないのかを解き明かす理論。

**ラムダ計算
-計算理論で使われる1つのモデル。
-ラムダ式（≒1引数無名高階関数の定義）と簡約（≒関数が返す値の評価）ですべての計算を表現できるというもの。
-複数の引数を持つ関数はカリー化によって1引数関数として扱われる。
-ラムダ式がラムダ式を受け取ったりラムダ式を返したりできないと、理論が成立しない。
-型のないラムダ計算と、型付きラムダ計算の両方が研究されている。

**関数型言語
-ラムダ計算を理論的基盤としたプログラミング言語。
-ラムダ式という名前の無名関数を記述できる。たいてい複数の引数を持つラムダ式を定義できるが、常にカリー化されるかどうかは言語による。
-すべてをラムダ式で扱うのは冗長だし効率も悪いので、関数や変数やリテラルなど、ラムダ式以外の要素も使うことができる。
-とはいえ、ラムダ式に限らず、ほとんどあらゆるものが式である。
-あらゆるものが式なので、returnが不要。
-式を組み合わせることで計算手順を記述する。gotoが不要。
-高階関数（引数や戻り値として関数を扱う関数）を使ってプログラムを書くのが普通。
-プログラムの実行は式の評価とほぼ同義。


**C#やVB.NETのラムダ式
-関数型言語のラムダ式を参考にして取り込んだ、匿名メソッドを簡易に定義する機能。（式木も定義できるけど、そこは省略）
-カリー化はない。
-式として記述するならreturnを書かなくても値を返せる。
-関数型言語を参考にしたLINQで活躍。
-引数としてデリゲートを受け取るメソッドに渡すのに便利。そのようなメソッドは高階関数とみなせるが、それを意識する必要はほとんどない。
"
2012-08-09,,"*1344466035*プログラミングHaskellついに完了

16ヶ月もかけてしまったが、ついに全章の写経と練習問題を終えた！

この先も本で学ぶとすれば、「すごいH」本か、もしくは「Real World Haskell」だろうか？

でも、まずはrst76が紹介していた確率プログラミングかな。

例題だと、「雨が降る確率が0.3、その場合に芝が濡れる条件付き確率が0.9、スプリンクラーが回る確率が0.5、その場合に芝が濡れる条件付き確率が0.8、雨も降らずスプリンクラーも回らなかった場合に（何らかの理由で）芝が濡れる条件付き確率が0.1としたときに、『芝が濡れていた場合に雨が降った条件付き確率』を求める」というもの。

図示するとこんな感じ、のはず（理解が間違っていなければ）。

[http://dl.dropbox.com/u/130665/blog/2012-08-08Rain.jpg:image]

図から見れば

 Pw(R) = P(W∩R)/P(W)
 
 P(W) = P(Wr) + P(Ws) - P(Wr∩Ws) + P(Wo)

とかなんとかやって式を出せるんだろうけど、それをせずにHaskellに解かせたい、ということのはず（理解が間違っていなければ）。

（追記）Woには「雨も降らずスプリンクラーも回らなかった場合」なんていう条件はつかないかも……そうするとWrやWsとの交わりも考えないといけないのかな……",,"*1344466035*プログラミングHaskellついに完了

16ヶ月もかけてしまったが、ついに全章の写経と練習問題を終えた！

この先も本で学ぶとすれば、「すごいH」本か、もしくは「Real World Haskell」だろうか？

でも、まずはrst76が紹介していた確率プログラミングかな。

例題だと、「雨が降る確率が0.3、その場合に芝が濡れる条件付き確率が0.9、スプリンクラーが回る確率が0.5、その場合に芝が濡れる条件付き確率が0.8、雨も降らずスプリンクラーも回らなかった場合に（何らかの理由で）芝が濡れる条件付き確率が0.1としたときに、『芝が濡れていた場合に雨が降った条件付き確率』を求める」というもの。

図示するとこんな感じ、のはず（理解が間違っていなければ）。

[http://dl.dropbox.com/u/130665/blog/2012-08-08Rain.jpg:image]

図から見れば

 Pw(R) = P(W∩R)/P(W)
 
 P(W) = P(Wr) + P(Ws) - P(Wr∩Ws) + P(Wo)

とかなんとかやって式を出せるんだろうけど、それをせずにHaskellに解かせたい、ということのはず（理解が間違っていなければ）。

（追記）Woには「雨も降らずスプリンクラーも回らなかった場合」なんていう条件はつかないかも……そうするとWrやWsとの交わりも考えないといけないのかな……"
2012-08-08,,"*1344405920*第13章 プログラムの論証 #7

**13.9 練習問題

><blockquote><ol>
<li value=""7"">以下の定義が与えられているとする。<br />
<pre>
map f &#91;]     = &#91;]
map f (x:xs) = f x : map f xs
(f.g) x      = f (g x)
</pre>
<code>map f (map g xs) = map (f.g) xs</code>であることを、xsに対する数学的帰納法で証明せよ。</li>
</ol></blockquote><

><dl>
<dt><code>xs = &#91;]</code>の場合</dt>
<dd><pre>  左辺
= map f (map g &#91;])
= map f &#91;]
= &#91;]

  右辺
= map (f.g) &#91;]
= &#91;]</pre></dd>
<dt><code>xs = ns</code> のときに式が成り立つと仮定して、 <code>xs = n:ns</code> の場合</dt>
<dd><pre>  左辺
= map f (map g (n:ns))
= map f (g n : map g ns)
= f (g n) : map f (map g ns)
= (f.g) n : map (f.g) ns

  右辺
= map (f.g) (n:ns)
= (f.g) n : map (f.g) ns</pre></dd>
</dl><



><blockquote><ol>
<li value=""8"">以下の定義が与えられているとする。<br />
<pre>
take 0 _          = &#91;]
take (n+1) &#91;]     = &#91;]
take (n+1) (x:xs) = x : take n xs

drop 0 xs         = xs
drop (n+1) &#91;]     = &#91;]
drop (n+1) (_:xs) = drop n xs
</pre>
この定義と上記の<code>++</code>の定義を使って、<code>take n xs ++ drop n xs = xs</code>を証明せよ。
その際、0以上の整数nとリストxsに対して同時に数学的帰納法を用いよ。<br />
ヒント：関数 <code>take</code> と <code>drop</code> の定義は、それぞれ三つの場合分けがあることに注意。</li>
</ol></blockquote><

><dl>
<dt><code>n = 0</code>の場合</dt>
<dd><pre>  左辺
= take 0 xs ++ drop 0 xs
= [] ++ xs
= xs
= 右辺</pre></dd>

<dt><code>n > 0, xs = []</code>の場合</dt>
<dd><pre>  左辺
= take n [] ++ drop n []
= [] ++ []
= []
= 右辺</pre></dd>

<dt><code>n = m, xs = ys</code>で式が成り立つと仮定して、<code>n = m+1, xs = y:ys</code>の場合</dt>
<dd><pre>  左辺
= take (m+1) (y:ys) ++ drop (m+1) (y:ys)
= (y: take m ys) ++ (drop m ys)
= y : (take m ys ++ drop m ys)
= y:ys
= 右辺</pre></dd>
</dl><



><blockquote><ol>
<li value=""9"">以下の型が与えられているとする。<br />
<pre>
data Tree = Leaf Int | Node Tree Tree
</pre>
この木の葉の個数は、節の個数よりも、常に1多いことを数学的帰納法で示せ。<br />
ヒント：木の葉と節の個数を数える関数を定義するところから始めよ。</li>
</ol></blockquote><

ヒント通り、木の葉と節の個数を数える関数を定義する。

>|haskell|
countLeaf :: Tree -> Int
countLeaf Leaf _   = 1
countLeaf Node l r = countLeaf l + countLeaf r

countNode :: Tree -> Int
countNode Leaf _ = 0
countNode Node l r = 1 + countNode l + countNode r
||<

その上で、<code>countLeaf t = countNode t + 1</code>が常に成り立つことをを証明する。

><dl>
<dt><code>t = Leaf n</code>の場合</dt>
<dd><pre>  左辺
= countLeaf Leaf n
= 1

  右辺
= countNode Leaf n + 1
= 0 + 1
= 1</pre></dd>

<dt><code>t = l</code> および  <code>t = r</code> で式が成り立つと仮定して <code>t = Node l r</code> の場合
<dd><pre>  左辺
= countLeaf Node l r
= countLeaf l + countLeaf r
= (countNode l + 1) + (countNode r + 1)
= 2 + countNode l + countNode r

  右辺
= countNode Node l r + 1
= 1 + countNode l + countNode r + 1
= 2 + countNode l + countNode r</pre></dd>
</dl><



><blockquote><ol>
<li value=""10"">等式 <code>comp' e c = comp e ++ c</code> が与えられたとき、数学的帰納法に似た手法をeに対して用いることで、関数 <code>comp'</code>の再帰的な定義を求めよ。</li>
</ol></blockquote><

<code>comp</code>の定義を再掲しておく。

>|haskell|
comp           :: Expr -> Code
comp (Val n)   =  [Push n]
comp (Add x y) =  comp x ++ comp y ++ [ADD]
||<

><dl>
<dt><code>e = Val n</code>の場合</dt>
<dd><pre>  comp' (Val n) c
= [Push n] ++ c
= Push n : c</pre></dd>

<dt><code>e = x</code> および  <code>e = y</code> で <code>comp' e c = comp e ++ c</code> が成り立つと仮定して <code>e = Add x y</code> の場合
<dd><pre>  comp' (Add x y) c
= comp x ++ comp y ++ [ADD] ++ c
= comp' x (comp y ++ [ADD] ++ c)
= comp' x (comp' y (ADD : c))</pre></dd>
</dl><

まとめると

>|haskell|
comp'             :: Expr -> Code -> Code
comp' (Val n) c   =  Push n : c
comp' (Add x y) c =  comp' x (comp' y (ADD : c))
||<

ついに終わった……
",,"*1344405920*第13章 プログラムの論証 #7

**13.9 練習問題

><blockquote><ol>
<li value=""7"">以下の定義が与えられているとする。<br />
<pre>
map f &#91;]     = &#91;]
map f (x:xs) = f x : map f xs
(f.g) x      = f (g x)
</pre>
<code>map f (map g xs) = map (f.g) xs</code>であることを、xsに対する数学的帰納法で証明せよ。</li>
</ol></blockquote><

><dl>
<dt><code>xs = &#91;]</code>の場合</dt>
<dd><pre>  左辺
= map f (map g &#91;])
= map f &#91;]
= &#91;]

  右辺
= map (f.g) &#91;]
= &#91;]</pre></dd>
<dt><code>xs = ns</code> のときに式が成り立つと仮定して、 <code>xs = n:ns</code> の場合</dt>
<dd><pre>  左辺
= map f (map g (n:ns))
= map f (g n : map g ns)
= f (g n) : map f (map g ns)
= (f.g) n : map (f.g) ns

  右辺
= map (f.g) (n:ns)
= (f.g) n : map (f.g) ns</pre></dd>
</dl><



><blockquote><ol>
<li value=""8"">以下の定義が与えられているとする。<br />
<pre>
take 0 _          = &#91;]
take (n+1) &#91;]     = &#91;]
take (n+1) (x:xs) = x : take n xs

drop 0 xs         = xs
drop (n+1) &#91;]     = &#91;]
drop (n+1) (_:xs) = drop n xs
</pre>
この定義と上記の<code>++</code>の定義を使って、<code>take n xs ++ drop n xs = xs</code>を証明せよ。
その際、0以上の整数nとリストxsに対して同時に数学的帰納法を用いよ。<br />
ヒント：関数 <code>take</code> と <code>drop</code> の定義は、それぞれ三つの場合分けがあることに注意。</li>
</ol></blockquote><

><dl>
<dt><code>n = 0</code>の場合</dt>
<dd><pre>  左辺
= take 0 xs ++ drop 0 xs
= [] ++ xs
= xs
= 右辺</pre></dd>

<dt><code>n > 0, xs = []</code>の場合</dt>
<dd><pre>  左辺
= take n [] ++ drop n []
= [] ++ []
= []
= 右辺</pre></dd>

<dt><code>n = m, xs = ys</code>で式が成り立つと仮定して、<code>n = m+1, xs = y:ys</code>の場合</dt>
<dd><pre>  左辺
= take (m+1) (y:ys) ++ drop (m+1) (y:ys)
= (y: take m ys) ++ (drop m ys)
= y : (take m ys ++ drop m ys)
= y:ys
= 右辺</pre></dd>
</dl><



><blockquote><ol>
<li value=""9"">以下の型が与えられているとする。<br />
<pre>
data Tree = Leaf Int | Node Tree Tree
</pre>
この木の葉の個数は、節の個数よりも、常に1多いことを数学的帰納法で示せ。<br />
ヒント：木の葉と節の個数を数える関数を定義するところから始めよ。</li>
</ol></blockquote><

ヒント通り、木の葉と節の個数を数える関数を定義する。

>|haskell|
countLeaf :: Tree -> Int
countLeaf Leaf _   = 1
countLeaf Node l r = countLeaf l + countLeaf r

countNode :: Tree -> Int
countNode Leaf _ = 0
countNode Node l r = 1 + countNode l + countNode r
||<

その上で、<code>countLeaf t = countNode t + 1</code>が常に成り立つことをを証明する。

><dl>
<dt><code>t = Leaf n</code>の場合</dt>
<dd><pre>  左辺
= countLeaf Leaf n
= 1

  右辺
= countNode Leaf n + 1
= 0 + 1
= 1</pre></dd>

<dt><code>t = l</code> および  <code>t = r</code> で式が成り立つと仮定して <code>t = Node l r</code> の場合
<dd><pre>  左辺
= countLeaf Node l r
= countLeaf l + countLeaf r
= (countNode l + 1) + (countNode r + 1)
= 2 + countNode l + countNode r

  右辺
= countNode Node l r + 1
= 1 + countNode l + countNode r + 1
= 2 + countNode l + countNode r</pre></dd>
</dl><



><blockquote><ol>
<li value=""10"">等式 <code>comp' e c = comp e ++ c</code> が与えられたとき、数学的帰納法に似た手法をeに対して用いることで、関数 <code>comp'</code>の再帰的な定義を求めよ。</li>
</ol></blockquote><

<code>comp</code>の定義を再掲しておく。

>|haskell|
comp           :: Expr -> Code
comp (Val n)   =  [Push n]
comp (Add x y) =  comp x ++ comp y ++ [ADD]
||<

><dl>
<dt><code>e = Val n</code>の場合</dt>
<dd><pre>  comp' (Val n) c
= [Push n] ++ c
= Push n : c</pre></dd>

<dt><code>e = x</code> および  <code>e = y</code> で <code>comp' e c = comp e ++ c</code> が成り立つと仮定して <code>e = Add x y</code> の場合
<dd><pre>  comp' (Add x y) c
= comp x ++ comp y ++ [ADD] ++ c
= comp' x (comp y ++ [ADD] ++ c)
= comp' x (comp' y (ADD : c))</pre></dd>
</dl><

まとめると

>|haskell|
comp'             :: Expr -> Code -> Code
comp' (Val n) c   =  Push n : c
comp' (Add x y) c =  comp' x (comp' y (ADD : c))
||<

ついに終わった……
"
2012-08-07,,"*1344325510*第13章 プログラムの論証 #6

とりあえず残りの問題だけ

**13.9 練習問題

><blockquote><ol>
<li value=""7"">以下の定義が与えられているとする。<br />
<pre>
map f &#91;]     = &#91;]
map f (x:xs) = f x : map f xs
(f.g) x      = f (g x)
</pre>
<code>map f (map g xs) = map (f.g) xs</code>であることを、xsに対する数学的帰納法で証明せよ。</li>

<li value=""8"">以下の定義が与えられているとする。<br />
<pre>
take 0 _          = &#91;]
take (n+1) &#91;]     = &#91;]
take (n+1) (x:xs) = x : take n xs

drop 0 xs         = xs
drop (n+1) &#91;]     = &#91;]
drop (n+1) (_:xs) = drop n xs
</pre>
この定義と上記の<code>++</code>の定義を使って、<code>take n xs ++ drop n xs = xs</code>を証明せよ。
その際、0以上の整数nとリストxsに対して同時に数学的帰納法を用いよ。<br />
ヒント：関数 <code>take</code> と <code>drop</code> の定義は、それぞれ三つの場合分けがあることに注意。</li>

<li value=""9"">以下の型が与えられているとする。<br />
<pre>
data Tree = Leaf Int | Node Tree Tree
</pre>
この木の葉の個数は、節の個数よりも、常に1多いことを数学的帰納法で示せ。<br />
ヒント：木の葉と節の個数を数える関数を定義するところから始めよ。</li>

<li value=""10"">等式 <code>comp' e c = comp e ++ c</code> が与えられたとき、数学的帰納法に似た手法をeに対して用いることで、関数 <code>comp'</code>の再帰的な定義を求めよ。</li>
</ol></blockquote><",,"*1344325510*第13章 プログラムの論証 #6

とりあえず残りの問題だけ

**13.9 練習問題

><blockquote><ol>
<li value=""7"">以下の定義が与えられているとする。<br />
<pre>
map f &#91;]     = &#91;]
map f (x:xs) = f x : map f xs
(f.g) x      = f (g x)
</pre>
<code>map f (map g xs) = map (f.g) xs</code>であることを、xsに対する数学的帰納法で証明せよ。</li>

<li value=""8"">以下の定義が与えられているとする。<br />
<pre>
take 0 _          = &#91;]
take (n+1) &#91;]     = &#91;]
take (n+1) (x:xs) = x : take n xs

drop 0 xs         = xs
drop (n+1) &#91;]     = &#91;]
drop (n+1) (_:xs) = drop n xs
</pre>
この定義と上記の<code>++</code>の定義を使って、<code>take n xs ++ drop n xs = xs</code>を証明せよ。
その際、0以上の整数nとリストxsに対して同時に数学的帰納法を用いよ。<br />
ヒント：関数 <code>take</code> と <code>drop</code> の定義は、それぞれ三つの場合分けがあることに注意。</li>

<li value=""9"">以下の型が与えられているとする。<br />
<pre>
data Tree = Leaf Int | Node Tree Tree
</pre>
この木の葉の個数は、節の個数よりも、常に1多いことを数学的帰納法で示せ。<br />
ヒント：木の葉と節の個数を数える関数を定義するところから始めよ。</li>

<li value=""10"">等式 <code>comp' e c = comp e ++ c</code> が与えられたとき、数学的帰納法に似た手法をeに対して用いることで、関数 <code>comp'</code>の再帰的な定義を求めよ。</li>
</ol></blockquote><"
2012-07-30,,"*1343625153*[F#]C#よりF#が向いている領域って？

Stack Overflowに質問されていた、「[http://stackoverflow.com/questions/2785029/:title=In what areas might the use of F# be more appropriate than C#?]」の回答を翻訳してみた。

**[http://stackoverflow.com/posts/2787342/revisions:title=simon cousins]の回答

私は、とあるエネルギー会社向けに、発電所のポートフォリオに関する国の発電スケジュールと取引ポジションとのバランスをとるためのアプリケーションを書きました。クライアントおよびサーバーコンポーネントはC#でしたが、計算エンジンはF#で書かれています。

F#はこのアプリケーションの心臓部の複雑さに対処するために使用したのですが、このことは明らかに、エンタープライズ・ソフトウェアにおけるこの言語のスイートスポットを示しています。すなわち、大規模なデータセットのアルゴリズム的に複雑な分析です。私の経験は非常に肯定的なものでした。具体例を示します：

<span class=""deco"" style=""font-weight:bold;"">測定単位</span>。私が働く業界には、いろいろな単位が散らばっています。私が実装した方程式（多くの場合、幾何学的な性質の方程式）は、時間や電力やエネルギーの単位を扱っています。型システムが、関数の入出力における単位の正確さを検証することで、コードをテストしたり、読み取って理解したりすることの両面において、巨大な時間の節約になります。それ以前のシステムで生じやすかった種別のエラー全体を根絶したのです。

<span class=""deco"" style=""font-weight:bold;"">探索プログラミング</span>。スクリプトファイルとREPL（F#インタラクティブ）での作業では、実装にコミットする前に、編集→コンパイル→実行→テストの伝統的なループよりも効果的に解空間を探索することができました。それは、プログラマが問題点や設計上の緊張点を見つけるための非常に自然な方法です。

<span class=""deco"" style=""font-weight:bold;"">ユニットテスト</span>。副作用のない関数やイミュータブルなデータ構造を使って書かれたコードはテストしやすいものです。すべてをややこしくしてしまう、順序依存の複雑な相互作用も、モックが必要になるような大量の依存関係も、どちらもありません。

<span class=""deco"" style=""font-weight:bold;"">相互運用性</span>。私は計算エンジンへのインターフェイスをC#で定義し、計算自体はF#で実装しました。計算エンジンは、相互運用性についてはまったく心配せずに、計算エンジンを必要とするC#のモジュールに後から注入することができました。シームレスです。C#プログラマは何も知っておく必要がありません。

<span class=""deco"" style=""font-weight:bold;"">コードの削減</span>。計算エンジンに供給されるデータの多くは、ベクトルと行列の形でした。高階関数は、最小の手間、最小限のコードでこれらを扱います。朝飯前です。美しい。

<span class=""deco"" style=""font-weight:bold;"">バグの欠如</span>。関数型プログラミングは奇妙に感じることがあります。私がアルゴリズムに取り組んでいるときには、コードが型チェッカーを通過するように頑張らないといけないかもしれませんが、一旦型チェッカーを通してしまえば、それで終わりです。コードは動きます。基本的には2択なのです。コードがコンパイルを通らないか、コードが正しいかです。奇妙なエッジケースのエラーは最小化されます。ビジネスロジック以外のコードはエッジケースのエラーを導入しがちですが、そのようなコードは再帰や高階関数によって多くが取り除かれます。

<span class=""deco"" style=""font-weight:bold;"">並列処理</span>。実装の結果が関数的に純粋であることは、ベクトルデータの処理に固有の並列性を利用するのにうってつけです。NET 4が出た今は、私が次に進むべき場所は多分ここでしょう。

**[http://stackoverflow.com/posts/2785113/revisions:title=Tomas Petricek]の回答

Microsoft Researchでインターンシップに参加していたとき、（F#自身で記述された）F#のVisual Studio IntelliSenseに関して何か所か仕事をしました。以前のC#プロジェクトですでにIntelliSenseについての経験がありましたので、両者を比較できると思います。

-Visual Studio機能拡張は相変わらずCOMベースです。ですので、あんまり素敵とは言えない（そしてまったくもって関数的でない）.NETオブジェクトを扱わないといけません。ですが、C#とF#との間に大きな違いは感じませんでした（F#でもスムーズに動作します）。
-F#でプログラムコードを表現するのに使われたデータ構造は、ほとんどが判別共用体です（そしてそれはC#では妥当な方法でサポートされていません）。そして、この手の（プログラムコードのような木構造を処理しないといけない）アプリケーションにとっては、それは大きな違いとなります。判別共用体とパターンマッチングによってコードの構造が改善されます（関連する機能を1か所にまとめておくことができます。仮想メソッドだとあちこちに散らばってしまいますが）。

以前は、F#のCodeDOMプロバイダ（こちらもF#で記述されています）についても仕事をしました。実は最初はC#で始めたのですが、後からコードをF#に変更しました。

-CodeDOMプロバイダは.NETのオブジェクトを使って表現された構造を探索しないといけません。ですので、独自のデータ表現を考える余地はほとんどありませんでした（そしてそこがF#が力を発揮できる分野なのですが）。
-とはいえ、この仕事を楽にするちょっとしたF#の機能はたくさんありました。とある文字列を生成しなければならなかったので、（StringBuilderを使って）文字列を組み立てるカスタム演算子をいくつか定義した上で、それらの演算子や高階関数を使ってコードを実装しました（たとえば、指定した文字列をセパレータに使ってオブジェクトのリストをフォーマットするといったようなものです）。そうすることで、コードの重複を大幅に削減できました（つまらないforeachループもです）。

比較的詳細な例を2つ挙げましたが、どちらもプログラムの表現形式や式に関係するものです。もっと一般的に言えば、木構造のような複雑なデータ構造です。この分野ではF#が間違いなく良い選択肢だと思います（C#にも関数型の機能があることを踏まえても、です）。
",,"*1343625153*[F#]C#よりF#が向いている領域って？

Stack Overflowに質問されていた、「[http://stackoverflow.com/questions/2785029/:title=In what areas might the use of F# be more appropriate than C#?]」の回答を翻訳してみた。

**[http://stackoverflow.com/posts/2787342/revisions:title=simon cousins]の回答

私は、とあるエネルギー会社向けに、発電所のポートフォリオに関する国の発電スケジュールと取引ポジションとのバランスをとるためのアプリケーションを書きました。クライアントおよびサーバーコンポーネントはC#でしたが、計算エンジンはF#で書かれています。

F#はこのアプリケーションの心臓部の複雑さに対処するために使用したのですが、このことは明らかに、エンタープライズ・ソフトウェアにおけるこの言語のスイートスポットを示しています。すなわち、大規模なデータセットのアルゴリズム的に複雑な分析です。私の経験は非常に肯定的なものでした。具体例を示します：

<span class=""deco"" style=""font-weight:bold;"">測定単位</span>。私が働く業界には、いろいろな単位が散らばっています。私が実装した方程式（多くの場合、幾何学的な性質の方程式）は、時間や電力やエネルギーの単位を扱っています。型システムが、関数の入出力における単位の正確さを検証することで、コードをテストしたり、読み取って理解したりすることの両面において、巨大な時間の節約になります。それ以前のシステムで生じやすかった種別のエラー全体を根絶したのです。

<span class=""deco"" style=""font-weight:bold;"">探索プログラミング</span>。スクリプトファイルとREPL（F#インタラクティブ）での作業では、実装にコミットする前に、編集→コンパイル→実行→テストの伝統的なループよりも効果的に解空間を探索することができました。それは、プログラマが問題点や設計上の緊張点を見つけるための非常に自然な方法です。

<span class=""deco"" style=""font-weight:bold;"">ユニットテスト</span>。副作用のない関数やイミュータブルなデータ構造を使って書かれたコードはテストしやすいものです。すべてをややこしくしてしまう、順序依存の複雑な相互作用も、モックが必要になるような大量の依存関係も、どちらもありません。

<span class=""deco"" style=""font-weight:bold;"">相互運用性</span>。私は計算エンジンへのインターフェイスをC#で定義し、計算自体はF#で実装しました。計算エンジンは、相互運用性についてはまったく心配せずに、計算エンジンを必要とするC#のモジュールに後から注入することができました。シームレスです。C#プログラマは何も知っておく必要がありません。

<span class=""deco"" style=""font-weight:bold;"">コードの削減</span>。計算エンジンに供給されるデータの多くは、ベクトルと行列の形でした。高階関数は、最小の手間、最小限のコードでこれらを扱います。朝飯前です。美しい。

<span class=""deco"" style=""font-weight:bold;"">バグの欠如</span>。関数型プログラミングは奇妙に感じることがあります。私がアルゴリズムに取り組んでいるときには、コードが型チェッカーを通過するように頑張らないといけないかもしれませんが、一旦型チェッカーを通してしまえば、それで終わりです。コードは動きます。基本的には2択なのです。コードがコンパイルを通らないか、コードが正しいかです。奇妙なエッジケースのエラーは最小化されます。ビジネスロジック以外のコードはエッジケースのエラーを導入しがちですが、そのようなコードは再帰や高階関数によって多くが取り除かれます。

<span class=""deco"" style=""font-weight:bold;"">並列処理</span>。実装の結果が関数的に純粋であることは、ベクトルデータの処理に固有の並列性を利用するのにうってつけです。NET 4が出た今は、私が次に進むべき場所は多分ここでしょう。

**[http://stackoverflow.com/posts/2785113/revisions:title=Tomas Petricek]の回答

Microsoft Researchでインターンシップに参加していたとき、（F#自身で記述された）F#のVisual Studio IntelliSenseに関して何か所か仕事をしました。以前のC#プロジェクトですでにIntelliSenseについての経験がありましたので、両者を比較できると思います。

-Visual Studio機能拡張は相変わらずCOMベースです。ですので、あんまり素敵とは言えない（そしてまったくもって関数的でない）.NETオブジェクトを扱わないといけません。ですが、C#とF#との間に大きな違いは感じませんでした（F#でもスムーズに動作します）。
-F#でプログラムコードを表現するのに使われたデータ構造は、ほとんどが判別共用体です（そしてそれはC#では妥当な方法でサポートされていません）。そして、この手の（プログラムコードのような木構造を処理しないといけない）アプリケーションにとっては、それは大きな違いとなります。判別共用体とパターンマッチングによってコードの構造が改善されます（関連する機能を1か所にまとめておくことができます。仮想メソッドだとあちこちに散らばってしまいますが）。

以前は、F#のCodeDOMプロバイダ（こちらもF#で記述されています）についても仕事をしました。実は最初はC#で始めたのですが、後からコードをF#に変更しました。

-CodeDOMプロバイダは.NETのオブジェクトを使って表現された構造を探索しないといけません。ですので、独自のデータ表現を考える余地はほとんどありませんでした（そしてそこがF#が力を発揮できる分野なのですが）。
-とはいえ、この仕事を楽にするちょっとしたF#の機能はたくさんありました。とある文字列を生成しなければならなかったので、（StringBuilderを使って）文字列を組み立てるカスタム演算子をいくつか定義した上で、それらの演算子や高階関数を使ってコードを実装しました（たとえば、指定した文字列をセパレータに使ってオブジェクトのリストをフォーマットするといったようなものです）。そうすることで、コードの重複を大幅に削減できました（つまらないforeachループもです）。

比較的詳細な例を2つ挙げましたが、どちらもプログラムの表現形式や式に関係するものです。もっと一般的に言えば、木構造のような複雑なデータ構造です。この分野ではF#が間違いなく良い選択肢だと思います（C#にも関数型の機能があることを踏まえても、です）。
"
2012-07-22,,"*1342936311*第13章 プログラムの論証 #5

**13.9 練習問題

><blockquote><ol>
<li value=""1"">付録Aにある標準ライブラリの中から重複のあるパターンを使って定義されている関数を探せ。</li>
</ol></blockquote><

教科書を見ながら抜き出してみる。
ガードも重複パターンのうちかな？

***A.1 クラス

>|haskell|
min, max :: a -> a -> a
min x y | x <= y    = x
        | otherwise = y
max x y | x <= y    = y
        | otherwise = x
||<

***A.2 真理値
特になし

***A.3 文字

>|haskell|
toLower :: Char -> Char
toLower c
  | isUpper c = chr (ord c - ord 'A' + ord 'a')
  | otherwise = c

toUpper :: Char -> Char
toUpper c
  | isLower c = chr (ord c - ord 'a' + ord 'A')
  | otherwise = c
||<

***A.4 数値
特になし。累乗は多分重複のないパターン。

***A.5 タプル
特になし

***A.6 Maybe
特になし

***A.7 リスト
>|haskell|
last :: [a] -> a
last [x]    = x
last (_:xs) = last xs

takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile p (x:xs)
  | p x       = x:takeWhile p xs
  | otherwise = []

init :: [a] -> [a]
init [_]    = []
init (x:xs) = x:init xs

dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile _ [] = []
dropWhile p (x:xs)
  | p x       = dropWhile p xs
  | otherwise = x:xs

foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 _ [x]    = x
fildr1 f (x:xs) = f x (foldr1 f xs)

zip :: [a] -> [b] -> [(a,b)]
zip [] _          = []
zip _ []          = []
zip (x:xs) (y:ys) = (x,y):zip xs ys
||<

***A.8 関数
特になし

***A.9 入出力
特になし
",,"*1342936311*第13章 プログラムの論証 #5

**13.9 練習問題

><blockquote><ol>
<li value=""1"">付録Aにある標準ライブラリの中から重複のあるパターンを使って定義されている関数を探せ。</li>
</ol></blockquote><

教科書を見ながら抜き出してみる。
ガードも重複パターンのうちかな？

***A.1 クラス

>|haskell|
min, max :: a -> a -> a
min x y | x <= y    = x
        | otherwise = y
max x y | x <= y    = y
        | otherwise = x
||<

***A.2 真理値
特になし

***A.3 文字

>|haskell|
toLower :: Char -> Char
toLower c
  | isUpper c = chr (ord c - ord 'A' + ord 'a')
  | otherwise = c

toUpper :: Char -> Char
toUpper c
  | isLower c = chr (ord c - ord 'a' + ord 'A')
  | otherwise = c
||<

***A.4 数値
特になし。累乗は多分重複のないパターン。

***A.5 タプル
特になし

***A.6 Maybe
特になし

***A.7 リスト
>|haskell|
last :: [a] -> a
last [x]    = x
last (_:xs) = last xs

takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile p (x:xs)
  | p x       = x:takeWhile p xs
  | otherwise = []

init :: [a] -> [a]
init [_]    = []
init (x:xs) = x:init xs

dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile _ [] = []
dropWhile p (x:xs)
  | p x       = dropWhile p xs
  | otherwise = x:xs

foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 _ [x]    = x
fildr1 f (x:xs) = f x (foldr1 f xs)

zip :: [a] -> [b] -> [(a,b)]
zip [] _          = []
zip _ []          = []
zip (x:xs) (y:ys) = (x,y):zip xs ys
||<

***A.8 関数
特になし

***A.9 入出力
特になし
"
2012-07-16,,"*1342411563*第13章 プログラムの論証 #4

**13.9 練習問題

><blockquote><ol>
<li value=""1"">付録Aにある標準ライブラリの中から重複のあるパターンを使って定義されている関数を探せ。</li>
</ol></blockquote><

いま手元に教科書がなくて、付録Aを確認できないので、今日はパス。

><blockquote><ol>
<li value=""2""><code>add n (Succ m) = Succ (add n m)</code> であることをnに対する数学的帰納法で示せ。</li>
</ol></blockquote><

><dl>
<dt><code>n = Zero</code>の場合</dt>
<dd><pre>  左辺
= add Zero (Succ m)
= Succ m

  右辺
= Succ (add Zero m)
= Succ m</pre></dd>
<dt><code>n = x</code> のときに <code>add x (Succ m) = Succ (add x m)</code> が成り立つと仮定して、 <code>n = Succ x</code> の場合</dt>
<dd><pre>  左辺
= add (Succ x) (Succ m)
= Succ (add x (Succ m))
= Succ (Succ (add x m))

  右辺
= Succ (add (Succ x) m)
= Succ (Succ (add x m))
</dd>
</dl><

><blockquote><ol>
<li value=""3"">練習問題2の性質と <code>add n Zero = n</code> を使って、加算が交換法則 <code>add n m = add m n</code> を満たすことを示せ。その際、nに対して数学的帰納法を用いよ。</li>
</ol></blockquote><

><dl>
<dt><code>n = Zero</code>の場合</dt>
<dd><pre>  左辺
= add Zero m
= m

  右辺
= add m Zero
= m</pre></dd>
<dt><code>n = x</code> のときに <code>add x m = add m x</code> が成り立つと仮定して、 <code>n = Succ x</code> の場合</dt>
<dd><pre>  左辺
= add (Succ x) m
= Succ (add x m)
= Succ (add m x)

  右辺
= add m (Succ x)
= Succ (add m x)
</pre></dd>
</dl><

><blockquote><ol>
<li value=""4"">リストのすべての要素が、ある述語を満たすか調べるライブラリ関数 <code>all</code> の定義が以下のように与えられたとする。<br />
<pre>
all p []     = True
all p (x:xs) = p x && all p xs
</pre>
関数 <code>replicate</code> の正しさを証明したい。関数 <code>replicate</code> が生成するリストのすべての要素が同じであることを示す式 <code>all (==x) (replicate n x)</code> が満たされることを0以上の整数nに対する数学的帰納法を用いて証明せよ。<br />
ヒント：この性質が常に <code>True</code> となることを示せ。</li>
</ol></blockquote><

><dl>
<dt><code>n = 0</code>の場合</dt>
<dd><pre>  all (==x) (replicate 0 x)
= all (==x) []
= True
</pre></dd>
<dt><code>n = m</code> のときに <code>all (==x) (replicate m x) = True</code> が成り立つと仮定して、 <code>n = m + 1</code> の場合</dt>
<dd><pre>  all (==x) (replicate (m+1) x)
= all (==x) (x : replicate m x)
= (==x) x && all (==x) (replicate m x)
= True && True
= True
</pre></dd>
</dl><

><blockquote><ol>
<li value=""5"">以下の定義が与えられているとする。<br />
<pre>
[] ++ ys     = ys
(x:xs) ++ ys = x:(xs ++ ys)
</pre>
以下の二つの性質をxsに対する数学的帰納法で証明せよ。<br />
<pre>
xs ++ []         = xs
xs ++ (ys ++ zs) = (xs ++ ys) ++ zs
</pre>
ヒント：関数 <code>add</code> の証明と同じようにせよ。</li>
</ol></blockquote><

><dl>
<dt><code>xs = []</code>の場合</dt>
<dd><pre>  1の左辺
= &#91;] ++ []
= []
= 1の右辺

  2の左辺
= [] ++ (ys ++ zs)
= ys ++ zs
= ([] ++ ys) ++ zs
= 2の右辺
</pre></dd>
<dt><code>xs = ns</code> のときに <code>ns ++ [] = ns</code> および <code>ns ++ (ys ++ zs) = (ns ++ ys) ++ zs</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合</dt>
<dd><pre>  1の左辺
= (n:ns) ++ []
= n:(ns ++ [])
= n:ns
= 1の右辺

  2の左辺
= (n:ns) ++ (ys ++ zs)
= n:(ns ++ (ys ++ zs))
= n:((ns ++ ys) ++ zs)
= (n:(ns ++ ys)) ++ zs
= ((n:ns) ++ ys) ++ zs
= 2の右辺
</pre></dd>
</dl><

><blockquote><ol>
<li value=""6"">等式 <code>reverse (reverse xs) = xs</code> は、補助定理 <code>reverse (xs ++ [x]) = x:reverse xs</code> のみを用いて証明できる。この補助定理自体は、xsに対する数学的帰納法で証明できる。13.5節で示した証明の方が優れているのはなぜか？</li>
</ol></blockquote><

ちょっと何言ってるかわからないので、補助定理の証明にチャレンジ。

><dl>
<dt><code>xs = []</code>の場合</dt>
<dd><pre>  左辺
= reverse ([] ++ [x])
= reverse [x]
= [x] -- 13.3の性質

  右辺
= x:reverse []
= x:[]
= [x]
</pre></dd>
<dt><code>xs = ns</code> のときに <code>reverse (ns ++ [x]) = x:reverse ns</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合</dt>
<dd><pre>  左辺
= reverse ((n:ns) ++ [x])
= reverse (n:(ns ++ [x])) -- xxの定義
= reverse (ns ++ [x]) ++ [n] -- reverseの定義
= (x:reverse ns) ++ [n] -- 仮定
= x:(reverse ns ++ [n]) -- xxの定義

  右辺
= x:reverse (n:ns)
= x:(reverse ns ++ [n]) -- reverseの定義
</pre></dd>
</dl><

で、この補助定理を使うと

><dl>
<dt><code>xs = []</code>の場合</dt>
<dd><pre>  左辺
= reverse (reverse [])
= reverse []
= []
= 右辺
</pre></dd>
<dt><code>xs = ns</code> のときに <code>reverse (reverse ns) = ns</code> が成り立つと仮定して、 <code>xs = ns ++ [n]</code> の場合</dt>
<dd><pre>  左辺
= reverse (reverse (ns ++ [n]))
= reverse (n:reverse ns)) -- 補助定理
= reverse (reverse ns) ++ [n] -- reverseの定義
= ns ++ [n] -- 仮定
= 右辺
</pre></dd>
</dl><

帰納法のところで、<code>xs = n:ns</code> じゃなく、<code>xs = ns ++ [n]</code> になってるあたりがイケてないってことかな？それぐらいしか理由は思いつかないけど。

***追記
ちょっとネットでカンニングしたら、13.5節の分配法則は、この補助定理を一般化した形だから、そっちの方がいい、という回答が。

>||
reverse (xs ++ ys) = reverse ys ++ reverse xs
||<

において、<code>ys = [x]</code> としたのが今回の補助定理になる。確かにそうだ。
でも、13.5節の分配法則は、練習問題5で証明した <code>++</code>の結合法則がないと証明できないし……面倒だよね。
",,"*1342411563*第13章 プログラムの論証 #4

**13.9 練習問題

><blockquote><ol>
<li value=""1"">付録Aにある標準ライブラリの中から重複のあるパターンを使って定義されている関数を探せ。</li>
</ol></blockquote><

いま手元に教科書がなくて、付録Aを確認できないので、今日はパス。

><blockquote><ol>
<li value=""2""><code>add n (Succ m) = Succ (add n m)</code> であることをnに対する数学的帰納法で示せ。</li>
</ol></blockquote><

><dl>
<dt><code>n = Zero</code>の場合</dt>
<dd><pre>  左辺
= add Zero (Succ m)
= Succ m

  右辺
= Succ (add Zero m)
= Succ m</pre></dd>
<dt><code>n = x</code> のときに <code>add x (Succ m) = Succ (add x m)</code> が成り立つと仮定して、 <code>n = Succ x</code> の場合</dt>
<dd><pre>  左辺
= add (Succ x) (Succ m)
= Succ (add x (Succ m))
= Succ (Succ (add x m))

  右辺
= Succ (add (Succ x) m)
= Succ (Succ (add x m))
</dd>
</dl><

><blockquote><ol>
<li value=""3"">練習問題2の性質と <code>add n Zero = n</code> を使って、加算が交換法則 <code>add n m = add m n</code> を満たすことを示せ。その際、nに対して数学的帰納法を用いよ。</li>
</ol></blockquote><

><dl>
<dt><code>n = Zero</code>の場合</dt>
<dd><pre>  左辺
= add Zero m
= m

  右辺
= add m Zero
= m</pre></dd>
<dt><code>n = x</code> のときに <code>add x m = add m x</code> が成り立つと仮定して、 <code>n = Succ x</code> の場合</dt>
<dd><pre>  左辺
= add (Succ x) m
= Succ (add x m)
= Succ (add m x)

  右辺
= add m (Succ x)
= Succ (add m x)
</pre></dd>
</dl><

><blockquote><ol>
<li value=""4"">リストのすべての要素が、ある述語を満たすか調べるライブラリ関数 <code>all</code> の定義が以下のように与えられたとする。<br />
<pre>
all p []     = True
all p (x:xs) = p x && all p xs
</pre>
関数 <code>replicate</code> の正しさを証明したい。関数 <code>replicate</code> が生成するリストのすべての要素が同じであることを示す式 <code>all (==x) (replicate n x)</code> が満たされることを0以上の整数nに対する数学的帰納法を用いて証明せよ。<br />
ヒント：この性質が常に <code>True</code> となることを示せ。</li>
</ol></blockquote><

><dl>
<dt><code>n = 0</code>の場合</dt>
<dd><pre>  all (==x) (replicate 0 x)
= all (==x) []
= True
</pre></dd>
<dt><code>n = m</code> のときに <code>all (==x) (replicate m x) = True</code> が成り立つと仮定して、 <code>n = m + 1</code> の場合</dt>
<dd><pre>  all (==x) (replicate (m+1) x)
= all (==x) (x : replicate m x)
= (==x) x && all (==x) (replicate m x)
= True && True
= True
</pre></dd>
</dl><

><blockquote><ol>
<li value=""5"">以下の定義が与えられているとする。<br />
<pre>
[] ++ ys     = ys
(x:xs) ++ ys = x:(xs ++ ys)
</pre>
以下の二つの性質をxsに対する数学的帰納法で証明せよ。<br />
<pre>
xs ++ []         = xs
xs ++ (ys ++ zs) = (xs ++ ys) ++ zs
</pre>
ヒント：関数 <code>add</code> の証明と同じようにせよ。</li>
</ol></blockquote><

><dl>
<dt><code>xs = []</code>の場合</dt>
<dd><pre>  1の左辺
= &#91;] ++ []
= []
= 1の右辺

  2の左辺
= [] ++ (ys ++ zs)
= ys ++ zs
= ([] ++ ys) ++ zs
= 2の右辺
</pre></dd>
<dt><code>xs = ns</code> のときに <code>ns ++ [] = ns</code> および <code>ns ++ (ys ++ zs) = (ns ++ ys) ++ zs</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合</dt>
<dd><pre>  1の左辺
= (n:ns) ++ []
= n:(ns ++ [])
= n:ns
= 1の右辺

  2の左辺
= (n:ns) ++ (ys ++ zs)
= n:(ns ++ (ys ++ zs))
= n:((ns ++ ys) ++ zs)
= (n:(ns ++ ys)) ++ zs
= ((n:ns) ++ ys) ++ zs
= 2の右辺
</pre></dd>
</dl><

><blockquote><ol>
<li value=""6"">等式 <code>reverse (reverse xs) = xs</code> は、補助定理 <code>reverse (xs ++ [x]) = x:reverse xs</code> のみを用いて証明できる。この補助定理自体は、xsに対する数学的帰納法で証明できる。13.5節で示した証明の方が優れているのはなぜか？</li>
</ol></blockquote><

ちょっと何言ってるかわからないので、補助定理の証明にチャレンジ。

><dl>
<dt><code>xs = []</code>の場合</dt>
<dd><pre>  左辺
= reverse ([] ++ [x])
= reverse [x]
= [x] -- 13.3の性質

  右辺
= x:reverse []
= x:[]
= [x]
</pre></dd>
<dt><code>xs = ns</code> のときに <code>reverse (ns ++ [x]) = x:reverse ns</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合</dt>
<dd><pre>  左辺
= reverse ((n:ns) ++ [x])
= reverse (n:(ns ++ [x])) -- xxの定義
= reverse (ns ++ [x]) ++ [n] -- reverseの定義
= (x:reverse ns) ++ [n] -- 仮定
= x:(reverse ns ++ [n]) -- xxの定義

  右辺
= x:reverse (n:ns)
= x:(reverse ns ++ [n]) -- reverseの定義
</pre></dd>
</dl><

で、この補助定理を使うと

><dl>
<dt><code>xs = []</code>の場合</dt>
<dd><pre>  左辺
= reverse (reverse [])
= reverse []
= []
= 右辺
</pre></dd>
<dt><code>xs = ns</code> のときに <code>reverse (reverse ns) = ns</code> が成り立つと仮定して、 <code>xs = ns ++ [n]</code> の場合</dt>
<dd><pre>  左辺
= reverse (reverse (ns ++ [n]))
= reverse (n:reverse ns)) -- 補助定理
= reverse (reverse ns) ++ [n] -- reverseの定義
= ns ++ [n] -- 仮定
= 右辺
</pre></dd>
</dl><

帰納法のところで、<code>xs = n:ns</code> じゃなく、<code>xs = ns ++ [n]</code> になってるあたりがイケてないってことかな？それぐらいしか理由は思いつかないけど。

***追記
ちょっとネットでカンニングしたら、13.5節の分配法則は、この補助定理を一般化した形だから、そっちの方がいい、という回答が。

>||
reverse (xs ++ ys) = reverse ys ++ reverse xs
||<

において、<code>ys = [x]</code> としたのが今回の補助定理になる。確かにそうだ。
でも、13.5節の分配法則は、練習問題5で証明した <code>++</code>の結合法則がないと証明できないし……面倒だよね。
"
2012-07-07,,"*1341630870*第13章 プログラムの論証 #3

**13.7 コンパイラーの正しさ

忙しかったのでかなり間が空いてしまった。
今回は[http://haskell.g.hatena.ne.jp/matarillo/20120223/1330017719:title=10.5節で出てきた関数]を、10.5節とは違った形で（コンパイルして実行することで）評価する関数を定義して、その関数の振る舞いがもとの関数の振る舞いと一致することを証明する。

10.5節の関数の、仮想マシンを使わない定義はこれ（10.5節ではもともとの関数名は <code>value</code> だったが、<code>eval</code> に置き換えてある）。

>|haskell|
data Expr = Val Int | Add Expr Expr
eval           :: Expr -> Int
eval (Val n)   =  n
eval (Add x y) =  eval x + eval y
||<

10.5節では、「数式を処理する仮想マシンを定義することで、処理の順番を指示できる。」と述べたうえで、仮想マシンを使った <code>eval</code> 関数の定義に移っていった。この節でも同じような感じで数式を処理する仕組みを別途用意するのだけど、その方法が10.5節とは違っている。
10.5節では、加算レジスタ、評価レジスタ、そして命令のスタックを持った仮想マシンだった。そして、与えられた式を逐次仮想マシン命令に置き換えて評価していく、いわばインタープリタ的な動作として <code>eval</code> 関数を再定義した。

この節の仮想マシンは、加算・評価用のレジスタがスタックに置き換わっている感じ。加算もスタックに対して行うし、式の評価結果はスタックに残る。そして、与えられた数式はいったん命令スタックに置き換えて（コンパイルして）、それから仮想マシンを実行することで数式の値が評価される。

>|haskell|
type Stack = [Int]
type Code = [Op]
data Op = PUSH Int | Add

exec                       :: Code -> Stack -> Stack
exec [] s                  =  s
exec (PUSH n : c) s        =  exec c (n : s)
exec (ADD : c) (m : n : s) =  exec c (n + m : s)

comp           :: Expr -> Code
comp (Val n)   =  [Push n]
comp (Add x y) =  comp x ++ comp y ++ [ADD]
||<

こうやって定義したコンパイル関数 <code>comp</code> と実行関数 <code>exec</code> の振る舞いが、もとの <code>eval</code> 関数の振る舞いと一致することを論証していく。すなわち、証明したい等式は以下だ。

>||
exec (comp e) [] = [eval e]
||<

ただし、上の形では証明が難しいので、スタックの状態を一般化した形で証明する。

>||
exec (comp e) s = eval e : s
||<

*** 分配法則を使った証明

まずは、<code>e = Val n</code> の場合。

>||
  左辺
= exec (comp (Val n)) s
= exec [PUSH n] s
= n : s

  右辺
= eval (Val n) : s
= n : s
||<

次に、<code>e = x</code> および <code>e = y</code> のときに、以下が成り立つと仮定しておく。

>||
exec (comp x) s = eval x : s
exec (comp y) s = eval y : s
||<

上の仮定が成り立つときに、<code>e = Add x y</code> の場合は

>||
  左辺
= exec (comp (Add x y)) s
= exec (comp x ++ comp y ++ [ADD]) s
= exec (comp x ++ (comp y ++ [ADD])) s
= exec (comp y ++ [ADD]) (exec (comp x) s) ★
= exec (comp y ++ [ADD]) (eval x : s)
= exec [ADD] (exec (comp y) (eval x : s)) ★
= exec [ADD] (eval y : eval x : s)
= exec [] ((eval x + eval y) : s)
= (eval x + eval y) : s

  右辺
= eval (Add x y) : s
= (eval x + eval y) : s
||<

★はexecの分配法則を使って証明している。分配法則は、コードcとdを連結してから実行するのと、コードcの実行結果を使ってコードdを実行するのが同じ結果になることを表している。
>||
exec (c ++ d) s = exec d (exec c s)
||<

さて、分配法則を数学的帰納法で証明しよう。まずは、<code>c = []</code> の場合。

>||
  左辺
= exec ([] ++ d) s
= exec d s

  右辺
= exec d (exec [] s)
= exec d s
||<

そして、<code>c = x</code> のときに、<code>exec (x ++ d) s = exec d (exec x s)</code> が成り立つと仮定しておき、さらに場合分けをする。

<code>c = PUSH n : x</code> の場合

>||
  左辺
= exec ((PUSH n : x) ++ d) s
= exec (PUSH n : (x ++ d)) s
= exec (x ++ d) (n : s)
= exec d (exec x (n : s))

  右辺
= exec d (exec (PUSH n : x) s)
= exec d (exec x (n : s))
||<

<code>c = ADD : x</code> の場合

この場合は、スタックsについて、<code>s = m : n : s'</code> であると考えてよい。これは、加算命令ADDが実行されるときには、スタックに少なくとも２つの数値が入っていることからきている（ADD命令を実行する exec の定義もそのようになっている）。

>||
  左辺
= exec ((ADD : x) ++ d) s
= exec (ADD : (x ++ d)) (m : n : s')
= exec (x ++ d) (m + n : s')
= exec d (exec x (m + n : s'))

  右辺
= exec d (exec (ADD : x) s)
= exec d (exec (ADD : x) (m : n : s'))
= exec d (exec x (m + n : s'))
||<

うへえ、長い……

*** 分配法則の除去

13.6節で連結演算子を除去したのと同じような手法で、より簡潔に証明できる。

具体的には、以下の等式を満たす関数 <code>comp'</code> の定義を探す。

>||
comp' e c = comp e ++ c
||<

数学的帰納法に似た変形を使うと（教科書では省略してある。あとで練習問題に出そうだな）、<code>comp'</code>は以下のような定義になることがわかるらしい。

>|haskell|
comp'             :: Expr -> Code -> Code
comp' (Val n) c   =  PUSH n : c
comp' (Add x y) c =  comp' x (comp' y (ADD : c))
||<

で、この <code>comp'</code> の正しさは、以下の等式を証明することで論証される。

>||
exec (comp' e c) s = exec c (eval e : s)
||<

<code>e = Val n</code> の場合

>||
  左辺
= exec (comp' (Val n) c) s
= exec (PUSH n : c) s
= exec c (n : s)

  右辺
= exec c (eval (Val n) : s)
= exec c (n : s)
||<

<code>e = x</code> および <code>e = y</code> のときに、以下が成り立つと仮定しておく。
>||
exec (comp' x c) s = exec c (eval x : s)
exec (comp' y c) s = exec c (eval y : s)
||<

<code>e = Add x y</code> の場合

>||
  左辺
= exec (comp' (Add x y) c) s
= exec (comp' x (comp' y (ADD : c))) s
= exec (comp' y (ADD : c)) (eval x : s)
= exec (ADD : c) (eval y : eval x : s)
= exec c ((eval x + eval y) : s)

  右辺
= exec c (eval (Add x y) : s)
= exec c ((eval x + eval y) : s)
||<

おおー、短くなった！
",,"*1341630870*第13章 プログラムの論証 #3

**13.7 コンパイラーの正しさ

忙しかったのでかなり間が空いてしまった。
今回は[http://haskell.g.hatena.ne.jp/matarillo/20120223/1330017719:title=10.5節で出てきた関数]を、10.5節とは違った形で（コンパイルして実行することで）評価する関数を定義して、その関数の振る舞いがもとの関数の振る舞いと一致することを証明する。

10.5節の関数の、仮想マシンを使わない定義はこれ（10.5節ではもともとの関数名は <code>value</code> だったが、<code>eval</code> に置き換えてある）。

>|haskell|
data Expr = Val Int | Add Expr Expr
eval           :: Expr -> Int
eval (Val n)   =  n
eval (Add x y) =  eval x + eval y
||<

10.5節では、「数式を処理する仮想マシンを定義することで、処理の順番を指示できる。」と述べたうえで、仮想マシンを使った <code>eval</code> 関数の定義に移っていった。この節でも同じような感じで数式を処理する仕組みを別途用意するのだけど、その方法が10.5節とは違っている。
10.5節では、加算レジスタ、評価レジスタ、そして命令のスタックを持った仮想マシンだった。そして、与えられた式を逐次仮想マシン命令に置き換えて評価していく、いわばインタープリタ的な動作として <code>eval</code> 関数を再定義した。

この節の仮想マシンは、加算・評価用のレジスタがスタックに置き換わっている感じ。加算もスタックに対して行うし、式の評価結果はスタックに残る。そして、与えられた数式はいったん命令スタックに置き換えて（コンパイルして）、それから仮想マシンを実行することで数式の値が評価される。

>|haskell|
type Stack = [Int]
type Code = [Op]
data Op = PUSH Int | Add

exec                       :: Code -> Stack -> Stack
exec [] s                  =  s
exec (PUSH n : c) s        =  exec c (n : s)
exec (ADD : c) (m : n : s) =  exec c (n + m : s)

comp           :: Expr -> Code
comp (Val n)   =  [Push n]
comp (Add x y) =  comp x ++ comp y ++ [ADD]
||<

こうやって定義したコンパイル関数 <code>comp</code> と実行関数 <code>exec</code> の振る舞いが、もとの <code>eval</code> 関数の振る舞いと一致することを論証していく。すなわち、証明したい等式は以下だ。

>||
exec (comp e) [] = [eval e]
||<

ただし、上の形では証明が難しいので、スタックの状態を一般化した形で証明する。

>||
exec (comp e) s = eval e : s
||<

*** 分配法則を使った証明

まずは、<code>e = Val n</code> の場合。

>||
  左辺
= exec (comp (Val n)) s
= exec [PUSH n] s
= n : s

  右辺
= eval (Val n) : s
= n : s
||<

次に、<code>e = x</code> および <code>e = y</code> のときに、以下が成り立つと仮定しておく。

>||
exec (comp x) s = eval x : s
exec (comp y) s = eval y : s
||<

上の仮定が成り立つときに、<code>e = Add x y</code> の場合は

>||
  左辺
= exec (comp (Add x y)) s
= exec (comp x ++ comp y ++ [ADD]) s
= exec (comp x ++ (comp y ++ [ADD])) s
= exec (comp y ++ [ADD]) (exec (comp x) s) ★
= exec (comp y ++ [ADD]) (eval x : s)
= exec [ADD] (exec (comp y) (eval x : s)) ★
= exec [ADD] (eval y : eval x : s)
= exec [] ((eval x + eval y) : s)
= (eval x + eval y) : s

  右辺
= eval (Add x y) : s
= (eval x + eval y) : s
||<

★はexecの分配法則を使って証明している。分配法則は、コードcとdを連結してから実行するのと、コードcの実行結果を使ってコードdを実行するのが同じ結果になることを表している。
>||
exec (c ++ d) s = exec d (exec c s)
||<

さて、分配法則を数学的帰納法で証明しよう。まずは、<code>c = []</code> の場合。

>||
  左辺
= exec ([] ++ d) s
= exec d s

  右辺
= exec d (exec [] s)
= exec d s
||<

そして、<code>c = x</code> のときに、<code>exec (x ++ d) s = exec d (exec x s)</code> が成り立つと仮定しておき、さらに場合分けをする。

<code>c = PUSH n : x</code> の場合

>||
  左辺
= exec ((PUSH n : x) ++ d) s
= exec (PUSH n : (x ++ d)) s
= exec (x ++ d) (n : s)
= exec d (exec x (n : s))

  右辺
= exec d (exec (PUSH n : x) s)
= exec d (exec x (n : s))
||<

<code>c = ADD : x</code> の場合

この場合は、スタックsについて、<code>s = m : n : s'</code> であると考えてよい。これは、加算命令ADDが実行されるときには、スタックに少なくとも２つの数値が入っていることからきている（ADD命令を実行する exec の定義もそのようになっている）。

>||
  左辺
= exec ((ADD : x) ++ d) s
= exec (ADD : (x ++ d)) (m : n : s')
= exec (x ++ d) (m + n : s')
= exec d (exec x (m + n : s'))

  右辺
= exec d (exec (ADD : x) s)
= exec d (exec (ADD : x) (m : n : s'))
= exec d (exec x (m + n : s'))
||<

うへえ、長い……

*** 分配法則の除去

13.6節で連結演算子を除去したのと同じような手法で、より簡潔に証明できる。

具体的には、以下の等式を満たす関数 <code>comp'</code> の定義を探す。

>||
comp' e c = comp e ++ c
||<

数学的帰納法に似た変形を使うと（教科書では省略してある。あとで練習問題に出そうだな）、<code>comp'</code>は以下のような定義になることがわかるらしい。

>|haskell|
comp'             :: Expr -> Code -> Code
comp' (Val n) c   =  PUSH n : c
comp' (Add x y) c =  comp' x (comp' y (ADD : c))
||<

で、この <code>comp'</code> の正しさは、以下の等式を証明することで論証される。

>||
exec (comp' e c) s = exec c (eval e : s)
||<

<code>e = Val n</code> の場合

>||
  左辺
= exec (comp' (Val n) c) s
= exec (PUSH n : c) s
= exec c (n : s)

  右辺
= exec c (eval (Val n) : s)
= exec c (n : s)
||<

<code>e = x</code> および <code>e = y</code> のときに、以下が成り立つと仮定しておく。
>||
exec (comp' x c) s = exec c (eval x : s)
exec (comp' y c) s = exec c (eval y : s)
||<

<code>e = Add x y</code> の場合

>||
  左辺
= exec (comp' (Add x y) c) s
= exec (comp' x (comp' y (ADD : c))) s
= exec (comp' y (ADD : c)) (eval x : s)
= exec (ADD : c) (eval y : eval x : s)
= exec c ((eval x + eval y) : s)

  右辺
= exec c (eval (Add x y) : s)
= exec c ((eval x + eval y) : s)
||<

おおー、短くなった！
"
2012-05-25,,"*1337930046*第13章 プログラムの論証 #2

**13.5 リストに対する数学的帰納法

リストも再帰的にオブジェクトが構築される型なので、数学的帰納法で論証できる。

<code>reverse (reverse xs) = xs</code>の証明。

<code>xs = []</code> の場合
>||
  reverse (reverse [])
= reverse []
= []
||<

<code>xs = ns</code> のときに <code>reverse (reverse xs) = xs</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合
>||
  reverse (reverse (n:ns))
= reverse (reverse ns ++ [n]) ★1
= reverse [n] ++ reverse (reverse ns)
= [n] ++ reverse (reverse ns)
= [n] ++ ns
= n:ns
||<

★1については、<code>reverse</code> 関数が <code>++</code> 演算子に対して分配法則を持っているという性質を使用する。
>||
reverse (xs ++ ys) = reverse ys ++ reverse xs
||<

<code>xs = []</code> の場合
>||
  左辺
= reverse ([] ++ ys)
= reverse ys

  右辺
= reverse ys ++ reverse []
= reverse ys ++ []
= reverse ys
||<

<code>xs = ns</code> のときに <code>reverse (xs ++ ys) = reverse ys ++ reverse xs</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合
>||
  左辺
= reverse ((n:ns) ++ ys)
= reverse (n:(ns ++ ys))
= reverse (ns ++ ys) ++ [n]
= (reverse ys ++ reverse ns) ++ [n] ★2
= revserse ys ++ (reverse ns ++ [n])

  右辺
= reverse ys ++ reverse (n:ns)
= reverse ys ++ (reverse ns ++ [n])
||<

★2については、<code>++</code> が結合法則を満たすという性質を使用する。（練習問題で証明する）

** 13.6 連結を除去する

連結演算子 <code>++</code> の効率は一番目の引数の長さに比例するので、<code>reverse</code> の効率は O(n^2)。そこで <code>reverse</code> の定義から <code>++</code> を除去する。具体的には、以下の等式を満たす関数 <code>reverse'</code> の定義を探す。

>||
reverse' xs ys = reverse xs ++ ys
||<

（上記は等式であって、定義ではないことに注意。）

このような <code>reverse'</code> を、 <code>++</code> を使わずに定義することができれば、 <code>reverse</code> の定義を
>||
reverse xs = reverse' xs []
||<
に変えることで、 <code>++</code> を除去できるはず。

<code>reverse'</code> の定義は、上記の等式を元に数学的帰納法に似た変形を使うことで得られる。

<code>xs = []</code> の場合
>||
  reverse' [] ys
= reverse [] ++ ys
= [] ++ ys
= ys
||<

<code>xs = ns</code> のときに <code>reverse' xs ys = reverse xs ++ ys</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合
>||
  reverse' (n:ns) ys
= reverse (n:ns) ++ ys
= (reverse ns ++ [n]) ++ ys
= reverse ns ++ ([n] ++ ys)
= reverse ns ++ (n:ys)
= reverse' ns (n:ys)
||<

すなわち、<code>reverse'</code> の定義は
>|haskell|
reverse'           :: [a] -> [a] -> [a]
reverse' [] ys     =  ys
reverse' (x:xs) ys =  reverse' xs (x:ys)
||<

この関数を使った <code>reverse</code> の定義は、効率が O(n)になる。

>>
蓄積変数を使うよう関数 <code>reverse</code> を変更するには、単に <code>reverse = foldl (\xs x -> x:xs) []</code> と定義すればよい。しかし、同様の振る舞いが数学的帰納法に似た手法で導けることを知っておくのも有益である。
<<

続いて、木構造を扱う関数について、同様の導出で <code>++</code> を除去する。

>|haskell|
data Tree = Leaf Int | Node Tree Tree
flatten            :: Tree -> [Int]
flatten (Leaf n)   =  [n]
flatten (Node l r) =  flatten l ++ flatten r
||<

さっきのよりもさらに天下り的だが、以下の等式を満たす関数 <code>flatten'</code> の定義を探す。

>||
flatten' t ns = flatten t ++ ns
||<

もしこの関数が、<code>++</code> を使わない形で定義できるのであれば、
>||
  flatten t
= flatten t ++ []
= flatten' t []
||<

という定義を使って、<code>++</code> を除去できるはず。

<code>t = Leaf n</code> の場合
>||
  flatten' (Leaf n) ns
= flatten (Leaf n) ++ ns
= [n] ++ ns
= n:ns
||<

<code>t = r</code> および <code>t = l</code> のときに <code>flatten' t ns = flatten t ++ ns</code> が成り立つと仮定して、 <code>t = Node l r</code> の場合

>||
  flatten' (Node l r) ns
= flatten (Node l r) ++ ns
= flatten l ++ flatten r ++ ns
= flatten l ++ (flatten r ++ ns)
= flatten l ++ (flatten' r ns)
= flatten' l (flatten' r ns)
||<

すなわち、<code>flatten</code> の定義は
>|haskell|
flatten   :: Tree -> [Int]
flatten t =  flatten' t []

flatten'               :: Tree -> [Int]
flatten' (Leaf n) ns   =  n:ns
flatten' (Node l r) ns =  flatten' l (flatten' r ns)
||<
",,"*1337930046*第13章 プログラムの論証 #2

**13.5 リストに対する数学的帰納法

リストも再帰的にオブジェクトが構築される型なので、数学的帰納法で論証できる。

<code>reverse (reverse xs) = xs</code>の証明。

<code>xs = []</code> の場合
>||
  reverse (reverse [])
= reverse []
= []
||<

<code>xs = ns</code> のときに <code>reverse (reverse xs) = xs</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合
>||
  reverse (reverse (n:ns))
= reverse (reverse ns ++ [n]) ★1
= reverse [n] ++ reverse (reverse ns)
= [n] ++ reverse (reverse ns)
= [n] ++ ns
= n:ns
||<

★1については、<code>reverse</code> 関数が <code>++</code> 演算子に対して分配法則を持っているという性質を使用する。
>||
reverse (xs ++ ys) = reverse ys ++ reverse xs
||<

<code>xs = []</code> の場合
>||
  左辺
= reverse ([] ++ ys)
= reverse ys

  右辺
= reverse ys ++ reverse []
= reverse ys ++ []
= reverse ys
||<

<code>xs = ns</code> のときに <code>reverse (xs ++ ys) = reverse ys ++ reverse xs</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合
>||
  左辺
= reverse ((n:ns) ++ ys)
= reverse (n:(ns ++ ys))
= reverse (ns ++ ys) ++ [n]
= (reverse ys ++ reverse ns) ++ [n] ★2
= revserse ys ++ (reverse ns ++ [n])

  右辺
= reverse ys ++ reverse (n:ns)
= reverse ys ++ (reverse ns ++ [n])
||<

★2については、<code>++</code> が結合法則を満たすという性質を使用する。（練習問題で証明する）

** 13.6 連結を除去する

連結演算子 <code>++</code> の効率は一番目の引数の長さに比例するので、<code>reverse</code> の効率は O(n^2)。そこで <code>reverse</code> の定義から <code>++</code> を除去する。具体的には、以下の等式を満たす関数 <code>reverse'</code> の定義を探す。

>||
reverse' xs ys = reverse xs ++ ys
||<

（上記は等式であって、定義ではないことに注意。）

このような <code>reverse'</code> を、 <code>++</code> を使わずに定義することができれば、 <code>reverse</code> の定義を
>||
reverse xs = reverse' xs []
||<
に変えることで、 <code>++</code> を除去できるはず。

<code>reverse'</code> の定義は、上記の等式を元に数学的帰納法に似た変形を使うことで得られる。

<code>xs = []</code> の場合
>||
  reverse' [] ys
= reverse [] ++ ys
= [] ++ ys
= ys
||<

<code>xs = ns</code> のときに <code>reverse' xs ys = reverse xs ++ ys</code> が成り立つと仮定して、 <code>xs = n:ns</code> の場合
>||
  reverse' (n:ns) ys
= reverse (n:ns) ++ ys
= (reverse ns ++ [n]) ++ ys
= reverse ns ++ ([n] ++ ys)
= reverse ns ++ (n:ys)
= reverse' ns (n:ys)
||<

すなわち、<code>reverse'</code> の定義は
>|haskell|
reverse'           :: [a] -> [a] -> [a]
reverse' [] ys     =  ys
reverse' (x:xs) ys =  reverse' xs (x:ys)
||<

この関数を使った <code>reverse</code> の定義は、効率が O(n)になる。

>>
蓄積変数を使うよう関数 <code>reverse</code> を変更するには、単に <code>reverse = foldl (\xs x -> x:xs) []</code> と定義すればよい。しかし、同様の振る舞いが数学的帰納法に似た手法で導けることを知っておくのも有益である。
<<

続いて、木構造を扱う関数について、同様の導出で <code>++</code> を除去する。

>|haskell|
data Tree = Leaf Int | Node Tree Tree
flatten            :: Tree -> [Int]
flatten (Leaf n)   =  [n]
flatten (Node l r) =  flatten l ++ flatten r
||<

さっきのよりもさらに天下り的だが、以下の等式を満たす関数 <code>flatten'</code> の定義を探す。

>||
flatten' t ns = flatten t ++ ns
||<

もしこの関数が、<code>++</code> を使わない形で定義できるのであれば、
>||
  flatten t
= flatten t ++ []
= flatten' t []
||<

という定義を使って、<code>++</code> を除去できるはず。

<code>t = Leaf n</code> の場合
>||
  flatten' (Leaf n) ns
= flatten (Leaf n) ++ ns
= [n] ++ ns
= n:ns
||<

<code>t = r</code> および <code>t = l</code> のときに <code>flatten' t ns = flatten t ++ ns</code> が成り立つと仮定して、 <code>t = Node l r</code> の場合

>||
  flatten' (Node l r) ns
= flatten (Node l r) ++ ns
= flatten l ++ flatten r ++ ns
= flatten l ++ (flatten r ++ ns)
= flatten l ++ (flatten' r ns)
= flatten' l (flatten' r ns)
||<

すなわち、<code>flatten</code> の定義は
>|haskell|
flatten   :: Tree -> [Int]
flatten t =  flatten' t []

flatten'               :: Tree -> [Int]
flatten' (Leaf n) ns   =  n:ns
flatten' (Node l r) ns =  flatten' l (flatten' r ns)
||<
"
2012-05-11,,"*1336732716*第13章 プログラムの論証 #1

ついに最終章！

>>
この最終章では、Haskellプログラミングを論証する方法を紹介する。まず等式推論の復習から始め、それがHaskellにどのように適用できるかを考える。そして、数学的帰納法という重要な技法を説明し、連結演算子を数学的帰納法に似た手法で除去できることを示す。最後に本章の締めくくりとして、簡単なコンパイラーの正しさを証明する。
<<

**13.1 等式推論

数学の復習。交換法則、結合法則、分配法則を使い、和の積を積の和に展開しても代数的に等しい。
公理から定理が導けるかを推論するのが等式推論。

**13.2 Haskellでの論証

Haskellの等式推論。Haskellを論証するために数学を使う。関数定義を使い、左辺から右辺へ適用したり、右辺から左辺へ逆適用したりする。
ただし、Haskellの関数定義でパターンマッチを使っている場合、定義の順番に依存している。プログラムの論証を簡単にするには、順番に依存しないパターン（互いに素な、または重複なしのパターン）である必要がある。

これは順番に依存する。
>|haskell|
isZero   :: Int -> Bool
isZero 0 =  True
isZero n =  False
||<

ガードを使い、互いに素なパターンにしておく。
>|haskell|
isZero            :: Int -> Bool
isZero 0          =  True
isZero n | n /= 0 =  False
||<

**13.3 簡単な例題

<code>reverse</code> 関数の定義。

>|haskell|
reverse        :: [a] -> [a]
reverse []     =  []
reverse (x:xs) =  reverse xs ++ [x]
||<

この定義と、リスト表記の定義と、結合演算子 <code>++</code> の定義を元に、任意の要素xに対し <code>reverse [x] = [x]</code>が成り立つことを証明する。

>||
  reverse [x]
= reverse (x:[])     -- リスト表記の定義
= reverse [] ++ [x]  -- reverseの定義
= [] ++ [x]          -- reverseの定義
= [x]                -- ++の定義
||<

これを使うことで、<strong>プログラム中の式 <code>reverse [x]</code> を <code>[x]</code> と置き換えてもよい</strong>ことがわかる。

続いて、パターンマッチを使ったプログラムの論証を場合分けで。
否定演算子の定義を使って、任意の真理値 <code>b</code> について二重否定を除去できることを証明したい。そこで、値が <code>True</code> の場合と <code>False</code> の場合の両方に分ける。
<code>b = False</code> の場合は以下のとおり。

>||
  not (not False)
= not True
= False
||<

**13.4 整数に対する数学的帰納法

再帰を使ったプログラムの論証を数学的帰納法で。（ただし、無限に再帰する値は扱わない）

>|haskell|
data Nat = Zero | Succ Nat

add            :: Nat -> Nat -> Nat
add Zero m     =  m
add (Succ n) m = Succ (add n m)
||<
という関数 <code>add</code> について、 <code>add n Zero = n</code>を証明する。

<code>n = Zero</code> の場合
>||
  add Zero Zero
= Zero
||<

<code>n = x</code> のときに <code>add x Zero = x</code> が成り立つと仮定して、 <code>n = Succ x</code> の場合
>||
  add (Succ x) Zero
= Succ (add x Zero)
= Succ x
||<

><hr><

自然数の加算に対する結合法則 <code>add x (add y z) = add (add x y) z</code> を証明する。

<code>x = Zero</code> の場合

>||
  左辺
= add Zero (add y z)
= add y z

  右辺
= add (add Zero y) z
= add y z
||<

<code>x = n</code> のときに <code>add n (add y z) = add (add n y) z</code> が成り立つと仮定して、 <code>x = Succ n</code> の場合
>||
  左辺
= add (Succ n) (add y z)
= Succ (add n (add y z))
= Succ (add (add n y) z)

  右辺
= add (add (Succ n) y) z
= add (Succ (add n y)) z
= Succ (add (add n y) z)
||<

><hr><

指定された要素をn個持つリストを生成するライブラリ関数 <code>replicate</code> の定義

>|haskell|
replicate         :: Int -> a -> [a]
replicate 0 _     =  []
replicate (n+1) c =  c : replicate n c
||<

をもとに、replicateが生成するリストの長さがnであること <code>length (replicate n c) = n</code> を証明する。

<code>n = 0</code> の場合
>||
  length (replicate 0 c)
= length []
= 0
||<

<code>n = x</code> のときに <code>length (replicate n c) = n</code> が成り立つと仮定して、 <code>n = x + 1</code> の場合
>||
  length (replicate (x+1) c)
= length (c : replicate n c)
= 1 + length (replicate n c)
= 1 + n
= n + 1
||<
",,"*1336732716*第13章 プログラムの論証 #1

ついに最終章！

>>
この最終章では、Haskellプログラミングを論証する方法を紹介する。まず等式推論の復習から始め、それがHaskellにどのように適用できるかを考える。そして、数学的帰納法という重要な技法を説明し、連結演算子を数学的帰納法に似た手法で除去できることを示す。最後に本章の締めくくりとして、簡単なコンパイラーの正しさを証明する。
<<

**13.1 等式推論

数学の復習。交換法則、結合法則、分配法則を使い、和の積を積の和に展開しても代数的に等しい。
公理から定理が導けるかを推論するのが等式推論。

**13.2 Haskellでの論証

Haskellの等式推論。Haskellを論証するために数学を使う。関数定義を使い、左辺から右辺へ適用したり、右辺から左辺へ逆適用したりする。
ただし、Haskellの関数定義でパターンマッチを使っている場合、定義の順番に依存している。プログラムの論証を簡単にするには、順番に依存しないパターン（互いに素な、または重複なしのパターン）である必要がある。

これは順番に依存する。
>|haskell|
isZero   :: Int -> Bool
isZero 0 =  True
isZero n =  False
||<

ガードを使い、互いに素なパターンにしておく。
>|haskell|
isZero            :: Int -> Bool
isZero 0          =  True
isZero n | n /= 0 =  False
||<

**13.3 簡単な例題

<code>reverse</code> 関数の定義。

>|haskell|
reverse        :: [a] -> [a]
reverse []     =  []
reverse (x:xs) =  reverse xs ++ [x]
||<

この定義と、リスト表記の定義と、結合演算子 <code>++</code> の定義を元に、任意の要素xに対し <code>reverse [x] = [x]</code>が成り立つことを証明する。

>||
  reverse [x]
= reverse (x:[])     -- リスト表記の定義
= reverse [] ++ [x]  -- reverseの定義
= [] ++ [x]          -- reverseの定義
= [x]                -- ++の定義
||<

これを使うことで、<strong>プログラム中の式 <code>reverse [x]</code> を <code>[x]</code> と置き換えてもよい</strong>ことがわかる。

続いて、パターンマッチを使ったプログラムの論証を場合分けで。
否定演算子の定義を使って、任意の真理値 <code>b</code> について二重否定を除去できることを証明したい。そこで、値が <code>True</code> の場合と <code>False</code> の場合の両方に分ける。
<code>b = False</code> の場合は以下のとおり。

>||
  not (not False)
= not True
= False
||<

**13.4 整数に対する数学的帰納法

再帰を使ったプログラムの論証を数学的帰納法で。（ただし、無限に再帰する値は扱わない）

>|haskell|
data Nat = Zero | Succ Nat

add            :: Nat -> Nat -> Nat
add Zero m     =  m
add (Succ n) m = Succ (add n m)
||<
という関数 <code>add</code> について、 <code>add n Zero = n</code>を証明する。

<code>n = Zero</code> の場合
>||
  add Zero Zero
= Zero
||<

<code>n = x</code> のときに <code>add x Zero = x</code> が成り立つと仮定して、 <code>n = Succ x</code> の場合
>||
  add (Succ x) Zero
= Succ (add x Zero)
= Succ x
||<

><hr><

自然数の加算に対する結合法則 <code>add x (add y z) = add (add x y) z</code> を証明する。

<code>x = Zero</code> の場合

>||
  左辺
= add Zero (add y z)
= add y z

  右辺
= add (add Zero y) z
= add y z
||<

<code>x = n</code> のときに <code>add n (add y z) = add (add n y) z</code> が成り立つと仮定して、 <code>x = Succ n</code> の場合
>||
  左辺
= add (Succ n) (add y z)
= Succ (add n (add y z))
= Succ (add (add n y) z)

  右辺
= add (add (Succ n) y) z
= add (Succ (add n y)) z
= Succ (add (add n y) z)
||<

><hr><

指定された要素をn個持つリストを生成するライブラリ関数 <code>replicate</code> の定義

>|haskell|
replicate         :: Int -> a -> [a]
replicate 0 _     =  []
replicate (n+1) c =  c : replicate n c
||<

をもとに、replicateが生成するリストの長さがnであること <code>length (replicate n c) = n</code> を証明する。

<code>n = 0</code> の場合
>||
  length (replicate 0 c)
= length []
= 0
||<

<code>n = x</code> のときに <code>length (replicate n c) = n</code> が成り立つと仮定して、 <code>n = x + 1</code> の場合
>||
  length (replicate (x+1) c)
= length (c : replicate n c)
= 1 + length (replicate n c)
= 1 + n
= n + 1
||<
"
2012-05-08,,"*1336463057*第12章 遅延評価 #4

**12.9 練習問題

><ol>
<li value=""1"">以下の式において、簡約可能式はどこか？また、選び出した簡約可能式が、最も内側か、 最も外側か、両方か、いずれでもないかを考えよ。<br />
<p>こんな感じ？簡約可能式に抜け漏れがなければいいけど。</p>
<dl>
<dt>1+(2*3)</dt>
<dd><ul>
<li>2*3...最内</li>
<li>1+()...最外（追記）原著の解答では、こっちは簡約可能式とみなされてない……なぜだ。</li>
</ul></dd>

<dt>(1+2)*(2+3)</dt>
<dd><ul>
<li>1+2...最内</li>
<li>2+3...どちらでもない（追記）こっちも最内といえるような気がするけど、原著の解答ではこっちは最内じゃないみたい。</li>
<li>()*()...最外</li>
</ul></dd>

<dt>fst (1+2, 2+3)</dt>
<dd><ul>
<li>1+2...最内</li>
<li>2+3...どちらでもない（追記）こっちも最内といえるような気がするけど、原著の解答ではこっちは最内じゃないみたい。</li>
<li>fst ()...最外</li>
</ul></dd>

<dt>(λx→1+x) (2*3)</dt>
<dd><ul>
<li>2*3...最内</li>
<li>1+x...どちらでもない（追記）原著の解答ではこっちは簡約可能式とみなされていない。ラムダ式の内側だから？</li>
<li>(λx→1+x) ()...最外</li>
</ul></dd>
</dl>

</li>
</ol><

><ol>
<li value=""2"">式 <code>fst (1+2, 2+3)</code> を評価する際、最内簡約よりも最外簡約の方が適している理由を述べよ。<br />
<p>最内簡約だと <code>1+2</code>と<code>2+3</code>の両方を評価するが、最外簡約だと<code>1+2</code>だけ評価すればよいため。</p>
</li>
</ol><

><ol>
<li value=""3"">定義 <code>mult = λx→(λy→x*y)</code> が与えられたとき、式 <code>mult 3 4</code> の評価が四段階の手順になることを示せ。<br />
<ul>
<li>初期状態 <code>mult 3 4</code></li>
<li>multを評価 <code>(λx→(λy→x*y)) 3 4</code></li>
<li>3を束縛 <code>(λy→3*y) 4</code></li>
<li>4を束縛 <code>3*4</code></li>
<li>積を計算 <code>12</code></li>
</ul>
</li>
</ol><

><ol>
<li value=""4"">リスト内包表記を使って、以下に示すフィボナッチ数の無限リストを生成する関数 <code>fibs :: [Integer]</code> を実装せよ。(フィボナッチ数は急激に大きくなるので、多倍長整数 <code>Integer</code> を使っていることに注意)<br />
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...<br />
以下の手順を踏むこと。
<ul>
<li>最初の二つの数を0と1とする</li>
<li>次の数は、前の二つの数を足して算出する</li>
<li>二番目に戻る</li>
</ul>
ヒント：ライプラリ関数 zip と tail を利用せよ。<br />
<pre>
fibs :: [Integer]
fibs =  0 : 1 : [x + y | (x, y) &lt;- zip fibs (tail fibs)]
</pre>
</li>
</ol><

><ol>
<li value=""5"">関数 <code>fibs</code> を用いて、0番目から数えてn番目のフィボナッチ数を返す関数 <code>fib :: Int -> Integer</code> を定義せよ。また、1000より大きい最初のフィボナッチ数を計算する式を示せ。<br />
<p>fibsはリストなんだから、これでいいよね。</p>
<pre>
fib :: Int -&gt; Integer
fib =  (fibs !!)
</pre>
<p>1000より大きな最初のフィボナッチは <code>head $ dropWhile (&lt;=1000) fibs</code> でいいですか。</p>
</li>
</ol><

><ol>
<li value=""6"">以下のライブラリ関数が、 以下の二分木に対して動くように変更せよ。<br />
<pre>
repeat              :: a -> [a]
repeat x            =  xs where xs = x:xs

take                :: Int -> [a] -> [a]
take 0 _            =  []
take (n + 1) &#x5b;&#x5d;     =  []
take (n + 1) (x:xs) =  x : take n xs

replicate           :: Int -> a -> [a]
replicate n         =  take n . repeat
</pre>

<pre>
data Tree a = Leaf | Node (Tree a) a (Tree a)
</pre>
訳者からのヒント：nは木の深さを表す。<br />
<p><code>repeat</code>は左の子にぶら下げるべきか、両方の子にぶらさげていくべきか。とりあえず両方の子にぶら下げよう。</p>
<pre>
repeat'   :: a -&gt; Tree a
repeat' x =  xt where xt = Node xt x xt
</pre>
<p><code>take</code>は、n+1パターンは使えない前提で。</p>
<pre>
take'                :: Int -&gt; Tree a -&gt; Tree a
take' 0 _            =  Leaf
take' n Leaf         =  Leaf
take' n (Node l x r) =  Node (take' (n-1) l) x (take' (n-1) r)
</pre>
<p><code>replicate</code>はそのまま。</p>
<pre>
replicate'   :: Int -&gt; a -&gt; Tree a
replicate' n =  take' n . repeat'
</pre>
</li>
</ol><
",,"*1336463057*第12章 遅延評価 #4

**12.9 練習問題

><ol>
<li value=""1"">以下の式において、簡約可能式はどこか？また、選び出した簡約可能式が、最も内側か、 最も外側か、両方か、いずれでもないかを考えよ。<br />
<p>こんな感じ？簡約可能式に抜け漏れがなければいいけど。</p>
<dl>
<dt>1+(2*3)</dt>
<dd><ul>
<li>2*3...最内</li>
<li>1+()...最外（追記）原著の解答では、こっちは簡約可能式とみなされてない……なぜだ。</li>
</ul></dd>

<dt>(1+2)*(2+3)</dt>
<dd><ul>
<li>1+2...最内</li>
<li>2+3...どちらでもない（追記）こっちも最内といえるような気がするけど、原著の解答ではこっちは最内じゃないみたい。</li>
<li>()*()...最外</li>
</ul></dd>

<dt>fst (1+2, 2+3)</dt>
<dd><ul>
<li>1+2...最内</li>
<li>2+3...どちらでもない（追記）こっちも最内といえるような気がするけど、原著の解答ではこっちは最内じゃないみたい。</li>
<li>fst ()...最外</li>
</ul></dd>

<dt>(λx→1+x) (2*3)</dt>
<dd><ul>
<li>2*3...最内</li>
<li>1+x...どちらでもない（追記）原著の解答ではこっちは簡約可能式とみなされていない。ラムダ式の内側だから？</li>
<li>(λx→1+x) ()...最外</li>
</ul></dd>
</dl>

</li>
</ol><

><ol>
<li value=""2"">式 <code>fst (1+2, 2+3)</code> を評価する際、最内簡約よりも最外簡約の方が適している理由を述べよ。<br />
<p>最内簡約だと <code>1+2</code>と<code>2+3</code>の両方を評価するが、最外簡約だと<code>1+2</code>だけ評価すればよいため。</p>
</li>
</ol><

><ol>
<li value=""3"">定義 <code>mult = λx→(λy→x*y)</code> が与えられたとき、式 <code>mult 3 4</code> の評価が四段階の手順になることを示せ。<br />
<ul>
<li>初期状態 <code>mult 3 4</code></li>
<li>multを評価 <code>(λx→(λy→x*y)) 3 4</code></li>
<li>3を束縛 <code>(λy→3*y) 4</code></li>
<li>4を束縛 <code>3*4</code></li>
<li>積を計算 <code>12</code></li>
</ul>
</li>
</ol><

><ol>
<li value=""4"">リスト内包表記を使って、以下に示すフィボナッチ数の無限リストを生成する関数 <code>fibs :: [Integer]</code> を実装せよ。(フィボナッチ数は急激に大きくなるので、多倍長整数 <code>Integer</code> を使っていることに注意)<br />
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...<br />
以下の手順を踏むこと。
<ul>
<li>最初の二つの数を0と1とする</li>
<li>次の数は、前の二つの数を足して算出する</li>
<li>二番目に戻る</li>
</ul>
ヒント：ライプラリ関数 zip と tail を利用せよ。<br />
<pre>
fibs :: [Integer]
fibs =  0 : 1 : [x + y | (x, y) &lt;- zip fibs (tail fibs)]
</pre>
</li>
</ol><

><ol>
<li value=""5"">関数 <code>fibs</code> を用いて、0番目から数えてn番目のフィボナッチ数を返す関数 <code>fib :: Int -> Integer</code> を定義せよ。また、1000より大きい最初のフィボナッチ数を計算する式を示せ。<br />
<p>fibsはリストなんだから、これでいいよね。</p>
<pre>
fib :: Int -&gt; Integer
fib =  (fibs !!)
</pre>
<p>1000より大きな最初のフィボナッチは <code>head $ dropWhile (&lt;=1000) fibs</code> でいいですか。</p>
</li>
</ol><

><ol>
<li value=""6"">以下のライブラリ関数が、 以下の二分木に対して動くように変更せよ。<br />
<pre>
repeat              :: a -> [a]
repeat x            =  xs where xs = x:xs

take                :: Int -> [a] -> [a]
take 0 _            =  []
take (n + 1) &#x5b;&#x5d;     =  []
take (n + 1) (x:xs) =  x : take n xs

replicate           :: Int -> a -> [a]
replicate n         =  take n . repeat
</pre>

<pre>
data Tree a = Leaf | Node (Tree a) a (Tree a)
</pre>
訳者からのヒント：nは木の深さを表す。<br />
<p><code>repeat</code>は左の子にぶら下げるべきか、両方の子にぶらさげていくべきか。とりあえず両方の子にぶら下げよう。</p>
<pre>
repeat'   :: a -&gt; Tree a
repeat' x =  xt where xt = Node xt x xt
</pre>
<p><code>take</code>は、n+1パターンは使えない前提で。</p>
<pre>
take'                :: Int -&gt; Tree a -&gt; Tree a
take' 0 _            =  Leaf
take' n Leaf         =  Leaf
take' n (Node l x r) =  Node (take' (n-1) l) x (take' (n-1) r)
</pre>
<p><code>replicate</code>はそのまま。</p>
<pre>
replicate'   :: Int -&gt; a -&gt; Tree a
replicate' n =  take' n . repeat'
</pre>
</li>
</ol><
"
2012-05-07,,"*1336346443*第12章 遅延評価 #2

**12.5 無限のデータ構造

Haskellの遅延評価は、無限のデータ構造を相手にした時も、必要がない限り無限回の評価は行わない。
>>
一般的に、遅延評価は次のような性質を持つ。すなわち、遅延評価を用いると、式が利用される文脈が要求する回数だけしか、その式は評価されない。
<<

>|haskell|
ones :: [Int]
ones =  1 : ones
||<
こういう無限リストがあったとして、<code>ones</code>を評価すると停止しないが、<code>head ones</code>の評価は二段階で停止する。

ここでいう文脈とは、関数<code>head</code>が「リストをとり、先頭の要素を返す」という振る舞いそのもののこと。なので、<code>ones</code>の先頭の要素が確定するところまでしか簡約しない。ここでは<code>ones</code>の要素は1という値なのだけれど、これが何らかの式だったとしても、評価のし方によっては、式そのものの評価までは必要ない場合もあって、そうするとその式はまだ簡約されない。

**12.6 部品プログラミング

無限リストから最初のn個を取り出す、という計算では、無限リストはデータ部品、リストから最初のn個を取り出すのは制御部品、として分離できる。

>>
データは制御が要求する回数だけ評価され、二つの部品は交互に簡約を実施する。
<<

例として、エラトステネスのふるいを実装する。
+無限リスト 2, 3, 4, 5, 6, ...を生成する
+リストの先頭の整数pを素数であると印を付ける
+pの倍数をリストから取り除く
+二番目の手順に戻る

Haskellではこれを素直にプログラムとして表現できる。しかも、無限リストを生成する手順1と、制御を表す手順2～4を別の部品にできる。
>|haskell|
primes :: [Int]
primes =  sieve [2..]

sieve        :: [Int] -> [Int]
sieve (p:xs) =  p : sieve [x | x <- xs, x `mod` p /= 0]
||<

このように定義したprimeを評価すると、無限リストと関数<code>sieve</code>は交互に簡約される。

**12.7 正格適用

関数適用を正格評価で実行する演算子<code>$!</code>。この演算子は
-基本型の場合は、値が定まるまで
-タプルの場合は、タプルが得られるまで
-リストの場合は、空リストまたは先頭の要素が得られるまで
評価を実行し、その後は通常の関数適用と同じ動きになる。

タプルやリストの要素自体の評価はどうするんだろうと思ってちょっとぐぐった。こっちも、基本型なら値が定まるまで評価されるのかな？

リストの和を取る関数を考える。
>|haskell|
sumwith          :: Int -> [Int] -> Int
sumwith v []     =  v
sumwith v (x:xs) =  sumwith (v + x) xs
||<
この関数定義だと、加算を実行する前に、全体の和を式として構築するため、長いリストを相手にするとメモリが足りなくなる。

>|haskell|
sumwith'          :: Int -> [Int] -> Int
sumwith' v []     =  v
sumwith' v (x:xs) =  (sumwith' $! (v + x)) xs
||<
この関数定義であれば、再帰のたびに引数を正格評価するので、メモリが足りなくならない。

同様に<code>foldl</code>の正格評価を考える。
>|haskell|
foldl'            :: (a -> b -> a) -> a -> [b] -> a
foldl' f v []     =  v
foldl' f v (x:xs) =  ((foldl' f) $! (f v x)) xs
||<
このように定義した<code>foldl'</code>であれば、長いリストに対しても適用できる。

ちょっとぐぐったら、Haskellにおけるfoldl'の定義は微妙に違っていて、<code>$!</code>を使わずに同じ効果を得ているようだけど。

*1336403785*第12章 遅延評価 #3

問題文だけ転記。

**12.9 練習問題

><ol>
<li value=""1"">以下の式において、簡約可能式はどこか？また、選び出した簡約可能式が、最も内側か、 最も外側か、両方か、いずれでもないかを考えよ。<br />
<pre>
1+(2*3)
(1+2)*(2+3)
fst (1+2, 2+3)
(λx→1+x) (2*3)
</pre>
</li>
<li>式 <code>fst (1+2, 2+3)</code> を評価する際、最内簡約よりも最外簡約の方が適している理由を述べよ。</li>
<li>定義 <code>mult = λx→(λy→x*y)</code> が与えられたとき、式 <code>mult 3 4</code> の評価が四段階の手順になることを示せ。</li>
<li>リスト内包表記を使って、以下に示すフィボナッチ数の無限リストを生成する関数 <code>fibs :: [Integer]</code> を実装せよ。(フィボナッチ数は急激に大きくなるので、多倍長整数 <code>Integer</code> を使っていることに注意)<br />
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...<br />
以下の手順を踏むこと。
<ul>
<li>最初の二つの数を0と1とする</li>
<li>次の数は、前の二つの数を足して算出する</li>
<li>二番目に戻る</li>
</ul>
ヒント：ライプラリ関数 zip と tail を利用せよ。</li>
<li>関数 <code>fibs</code> を用いて、0番目から数えてn番目のフィボナッチ数を返す関数 <code>fib :: Int -> Integer</code> を定義せよ。また、1000より大きい最初のフィボナッチ数を計算する式を示せ。</li>
<li>以下のライブラリ関数が、 以下の二分木に対して動くように変更せよ。<br />
<pre>
repeat              :: a -> [a]
repeat x            =  xs where xs = x:xs

take                :: Int -> [a] -> [a]
take 0 _            =  []
take (n + 1) &#x5b;&#x5d;     =  []
take (n + 1) (x:xs) =  x : take n xs

replicate           :: Int -> a -> [a]
replicate n         =  take n . repeat
</pre>
<pre>
data Tree a = Leaf | Node (Tree a) a (Tree a)
</pre>
訳者からのヒント：nは木の深さを表す。</li>
</ol><
",,"*1336346443*第12章 遅延評価 #2

**12.5 無限のデータ構造

Haskellの遅延評価は、無限のデータ構造を相手にした時も、必要がない限り無限回の評価は行わない。
>>
一般的に、遅延評価は次のような性質を持つ。すなわち、遅延評価を用いると、式が利用される文脈が要求する回数だけしか、その式は評価されない。
<<

>|haskell|
ones :: [Int]
ones =  1 : ones
||<
こういう無限リストがあったとして、<code>ones</code>を評価すると停止しないが、<code>head ones</code>の評価は二段階で停止する。

ここでいう文脈とは、関数<code>head</code>が「リストをとり、先頭の要素を返す」という振る舞いそのもののこと。なので、<code>ones</code>の先頭の要素が確定するところまでしか簡約しない。ここでは<code>ones</code>の要素は1という値なのだけれど、これが何らかの式だったとしても、評価のし方によっては、式そのものの評価までは必要ない場合もあって、そうするとその式はまだ簡約されない。

**12.6 部品プログラミング

無限リストから最初のn個を取り出す、という計算では、無限リストはデータ部品、リストから最初のn個を取り出すのは制御部品、として分離できる。

>>
データは制御が要求する回数だけ評価され、二つの部品は交互に簡約を実施する。
<<

例として、エラトステネスのふるいを実装する。
+無限リスト 2, 3, 4, 5, 6, ...を生成する
+リストの先頭の整数pを素数であると印を付ける
+pの倍数をリストから取り除く
+二番目の手順に戻る

Haskellではこれを素直にプログラムとして表現できる。しかも、無限リストを生成する手順1と、制御を表す手順2～4を別の部品にできる。
>|haskell|
primes :: [Int]
primes =  sieve [2..]

sieve        :: [Int] -> [Int]
sieve (p:xs) =  p : sieve [x | x <- xs, x `mod` p /= 0]
||<

このように定義したprimeを評価すると、無限リストと関数<code>sieve</code>は交互に簡約される。

**12.7 正格適用

関数適用を正格評価で実行する演算子<code>$!</code>。この演算子は
-基本型の場合は、値が定まるまで
-タプルの場合は、タプルが得られるまで
-リストの場合は、空リストまたは先頭の要素が得られるまで
評価を実行し、その後は通常の関数適用と同じ動きになる。

タプルやリストの要素自体の評価はどうするんだろうと思ってちょっとぐぐった。こっちも、基本型なら値が定まるまで評価されるのかな？

リストの和を取る関数を考える。
>|haskell|
sumwith          :: Int -> [Int] -> Int
sumwith v []     =  v
sumwith v (x:xs) =  sumwith (v + x) xs
||<
この関数定義だと、加算を実行する前に、全体の和を式として構築するため、長いリストを相手にするとメモリが足りなくなる。

>|haskell|
sumwith'          :: Int -> [Int] -> Int
sumwith' v []     =  v
sumwith' v (x:xs) =  (sumwith' $! (v + x)) xs
||<
この関数定義であれば、再帰のたびに引数を正格評価するので、メモリが足りなくならない。

同様に<code>foldl</code>の正格評価を考える。
>|haskell|
foldl'            :: (a -> b -> a) -> a -> [b] -> a
foldl' f v []     =  v
foldl' f v (x:xs) =  ((foldl' f) $! (f v x)) xs
||<
このように定義した<code>foldl'</code>であれば、長いリストに対しても適用できる。

ちょっとぐぐったら、Haskellにおけるfoldl'の定義は微妙に違っていて、<code>$!</code>を使わずに同じ効果を得ているようだけど。

*1336403785*第12章 遅延評価 #3

問題文だけ転記。

**12.9 練習問題

><ol>
<li value=""1"">以下の式において、簡約可能式はどこか？また、選び出した簡約可能式が、最も内側か、 最も外側か、両方か、いずれでもないかを考えよ。<br />
<pre>
1+(2*3)
(1+2)*(2+3)
fst (1+2, 2+3)
(λx→1+x) (2*3)
</pre>
</li>
<li>式 <code>fst (1+2, 2+3)</code> を評価する際、最内簡約よりも最外簡約の方が適している理由を述べよ。</li>
<li>定義 <code>mult = λx→(λy→x*y)</code> が与えられたとき、式 <code>mult 3 4</code> の評価が四段階の手順になることを示せ。</li>
<li>リスト内包表記を使って、以下に示すフィボナッチ数の無限リストを生成する関数 <code>fibs :: [Integer]</code> を実装せよ。(フィボナッチ数は急激に大きくなるので、多倍長整数 <code>Integer</code> を使っていることに注意)<br />
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...<br />
以下の手順を踏むこと。
<ul>
<li>最初の二つの数を0と1とする</li>
<li>次の数は、前の二つの数を足して算出する</li>
<li>二番目に戻る</li>
</ul>
ヒント：ライプラリ関数 zip と tail を利用せよ。</li>
<li>関数 <code>fibs</code> を用いて、0番目から数えてn番目のフィボナッチ数を返す関数 <code>fib :: Int -> Integer</code> を定義せよ。また、1000より大きい最初のフィボナッチ数を計算する式を示せ。</li>
<li>以下のライブラリ関数が、 以下の二分木に対して動くように変更せよ。<br />
<pre>
repeat              :: a -> [a]
repeat x            =  xs where xs = x:xs

take                :: Int -> [a] -> [a]
take 0 _            =  []
take (n + 1) &#x5b;&#x5d;     =  []
take (n + 1) (x:xs) =  x : take n xs

replicate           :: Int -> a -> [a]
replicate n         =  take n . repeat
</pre>
<pre>
data Tree a = Leaf | Node (Tree a) a (Tree a)
</pre>
訳者からのヒント：nは木の深さを表す。</li>
</ol><
"
2012-05-06,,"*1336317226*第12章 遅延評価 #1

**12.1 導入

一般的な命令型言語は、同じ式に対する評価順序が違うと結果が変わることがあるが、Haskellではどのような順序で評価しても(停止するのでない限り)同じ結果が得られる。

ぐぐってみたら、「チャーチ・ロッサー性」というのかな？

**12.2 評価戦略

簡約可能式の簡約方法。
:最内簡約:最も内側で最も左の簡約可能式から簡約する。λ式の内部を除いた最内簡約が値渡し。
:最外簡約:最も外側で最も左の簡約可能式から簡約する。λ式の内部を除いた最外簡約が名前渡し。

最外簡約を選んだとしても、関数が正格だと、引数を評価してからでないと値が決まらない。

（追記）なにか違和感があると思って落ち着いて考えた。よくある値渡しと名前渡しの比較は、変数をどう渡すかの違いを見ている。ここでいう値渡しと名前渡しは、変数だけじゃなくて、式を渡すときの扱い方だ。

**12.3 停止性

>|haskell|
inf :: Int
inf =  1 + inf
||<

このような関数は、値渡しでも名前渡しでも停止しない。
しかし、<code>fst (0, inf)</code>を評価する場合は、値渡しでは停止しないが名前渡しなら停止する。
>>
一般的に言うと、名前渡しには次のような重要な性質がある。すなわち、ある式に対し停止する評価の手順が存在するなら、名前渡しはこの式の評価を必ず停止させ、同じ結果を返す。
<<
とのこと。まあここでは証明とかは考えずに、とりあえずすんなり受け入れて次に進むか。

**12.4 簡約の回数

>|haskell|
square   :: Int -> Int
square n =  n * n
||<
このような関数について、<code>square (1 + 2)</code>を考える。値渡しと名前渡しを比べると、名前渡しのほうが簡約の回数が増える。しかし、名前渡しであっても、引数をポインター（参照）で共有すれば、簡約結果も共有できる。このような、ポインター（参照）による共有を用いた名前渡しを遅延評価と呼んでいる。
",,"*1336317226*第12章 遅延評価 #1

**12.1 導入

一般的な命令型言語は、同じ式に対する評価順序が違うと結果が変わることがあるが、Haskellではどのような順序で評価しても(停止するのでない限り)同じ結果が得られる。

ぐぐってみたら、「チャーチ・ロッサー性」というのかな？

**12.2 評価戦略

簡約可能式の簡約方法。
:最内簡約:最も内側で最も左の簡約可能式から簡約する。λ式の内部を除いた最内簡約が値渡し。
:最外簡約:最も外側で最も左の簡約可能式から簡約する。λ式の内部を除いた最外簡約が名前渡し。

最外簡約を選んだとしても、関数が正格だと、引数を評価してからでないと値が決まらない。

（追記）なにか違和感があると思って落ち着いて考えた。よくある値渡しと名前渡しの比較は、変数をどう渡すかの違いを見ている。ここでいう値渡しと名前渡しは、変数だけじゃなくて、式を渡すときの扱い方だ。

**12.3 停止性

>|haskell|
inf :: Int
inf =  1 + inf
||<

このような関数は、値渡しでも名前渡しでも停止しない。
しかし、<code>fst (0, inf)</code>を評価する場合は、値渡しでは停止しないが名前渡しなら停止する。
>>
一般的に言うと、名前渡しには次のような重要な性質がある。すなわち、ある式に対し停止する評価の手順が存在するなら、名前渡しはこの式の評価を必ず停止させ、同じ結果を返す。
<<
とのこと。まあここでは証明とかは考えずに、とりあえずすんなり受け入れて次に進むか。

**12.4 簡約の回数

>|haskell|
square   :: Int -> Int
square n =  n * n
||<
このような関数について、<code>square (1 + 2)</code>を考える。値渡しと名前渡しを比べると、名前渡しのほうが簡約の回数が増える。しかし、名前渡しであっても、引数をポインター（参照）で共有すれば、簡約結果も共有できる。このような、ポインター（参照）による共有を用いた名前渡しを遅延評価と呼んでいる。
"
2012-04-25,,"*1335366278*[F#]F#のコンピュテーション式
ってHaskellのdo記法なんだね。",,"*1335366278*[F#]F#のコンピュテーション式
ってHaskellのdo記法なんだね。"
2012-03-25,,"*1332646472*第11章 切符番号遊び #3

**11.7 練習問題

><ol>
<li value=""4"">関数 <code>choices</code>、<code>exprs</code>、および<code>eval</code>を用いて、1、3、7、10、25、50に対し可能な式は33,665,406個あり、そのうち4,672,540個のみが有効であることを確かめよ。</li>
</ol><

こんな感じでいいのかな。
もっと見た目よく関数合成したいんだけど。F#の <code>|> </code>みたいな演算子はないのかな。

>|haskell|
availables :: [Int] -> Int
availables = length . concat . map exprs . choices

valids :: [Int] -> Int
valids = length . concat . map eval . concat . map exprs . choices

main :: IO ()
main = do
  print $ availables [1,3,7,10,25,50]
  print $ valids [1,3,7,10,25,50]
||<

><ol>
<li value=""5"">同様に数値の定義域を整数に拡大すると、有効な式の数が10,839,369個に増えることを確かめよ。<br />
ヒント：関数 <code>valid</code> の定義を変更せよ。</li>
</ol><

<code>eval</code>の方は変えなくてよかったのかな……

>|haskell|
valid         :: Op -> Int -> Int -> Bool
valid Add _ _ =  True
valid Sub x y =  True
valid Mul _ _ =  True
valid Div x y =  y /= 0 && x `mod` y == 0
||<

><ol>
<li value=""6"">関数 <code>solutions''</code> を以下のように改良せよ。
<ol type=""a""><li>式に累乗演算子が使えるようにする</li>
<li>解がない場合に、目標の数に最も近い解を算出する</li>
<li>適切な方法で解を並び替える</li></ol></li>
</ol><

***6-a

累乗ということで<code>Pow</code>を増やした。そしたら整数値がオーバーフローするようになって困った。
しかたなく、validの定義の方でオーバーフローしたものを排除するようにした。

>|haskell|
data Op = Add | Sub | Mul | Div | Pow
  deriving Show

valid         :: Op -> Int -> Int -> Bool
valid Add x y =  x <= y && x + y /= 0
valid Sub x y =  x > y
valid Mul x y =  x /= 1 && y /= 1 && x <= y && x * y /= 0
valid Div x y =  y /= 1 && x `mod` y == 0
valid Pow x y =  x > 1 && y > 1 && x ^ y /= 0

apply         :: Op -> Int -> Int -> Int
apply Add x y =  x + y
apply Sub x y =  x - y
apply Mul x y =  x * y
apply Div x y =  x `div` y
apply Pow x y =  x ^ y

ops :: [Op]
ops =  [Add, Sub, Mul, Div, Pow]
||<

***6-b

目標とする数値との差の絶対値が最小になる式のリストを作って返すようにした。
わりと面倒なコードになってしまったけど、どうなんだろ。

>|haskell|
minsby :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
minsby _ xs     []     = xs
minsby f []     (y:ys) = minsby f [y] ys
minsby f (x:xs) (y:ys)
  | f x y == LT        = minsby f (x:xs) ys
  | f x y == EQ        = minsby f ((x:xs) ++ [y]) ys
  | otherwise          = minsby f [y] ys

solutions'' :: [Int] -> Int -> [Expr]
solutions'' ns n = [e | (e, _) <- minsby f [] candidates]
  where
    f (_, x) (_, y) = compare (abs (x - n)) (abs (y - n))
    candidates = [r | ns' <- choices ns,
                      r <- results ns']
||<

***6-c

「適切な方法」って何だよ！意味がわからない。
なので
-使用した数値の数が小さい順
-使用した数値の並び順
-使用した演算子の並び順
という感じにしてみた。

>|haskell|
data Op = Add | Sub | Mul | Div | Pow
  deriving (Show, Ord, Eq)

opcodes             :: Expr -> [Op]
opcodes (Val _)     =  []
opcodes (App o l r) =  o : (opcodes l) ++ (opcodes r)

type Comparer a = a -> a -> Ordering

andthen         :: Comparer a -> Comparer a -> Comparer a
andthen f g x y =  if f x y /= EQ then f x y else g x y

compareby       :: Ord b => (a -> b) -> Comparer a
compareby f x y =  compare (f x) (f y)

exprcomparer :: Comparer Expr
exprcomparer =  compareby (length . values) `andthen`
                compareby values `andthen`
                compareby opcodes

solutions'' :: [Int] -> Int -> [Expr]
solutions'' ns n = sortBy exprcomparer [e | (e, _) <- minsby f [] candidates]
  where
    f (_, x) (_, y) = compare (abs (x - n)) (abs (y - n))
    candidates = [r | ns' <- choices ns,
                      r <- results ns']
||<
",,"*1332646472*第11章 切符番号遊び #3

**11.7 練習問題

><ol>
<li value=""4"">関数 <code>choices</code>、<code>exprs</code>、および<code>eval</code>を用いて、1、3、7、10、25、50に対し可能な式は33,665,406個あり、そのうち4,672,540個のみが有効であることを確かめよ。</li>
</ol><

こんな感じでいいのかな。
もっと見た目よく関数合成したいんだけど。F#の <code>|> </code>みたいな演算子はないのかな。

>|haskell|
availables :: [Int] -> Int
availables = length . concat . map exprs . choices

valids :: [Int] -> Int
valids = length . concat . map eval . concat . map exprs . choices

main :: IO ()
main = do
  print $ availables [1,3,7,10,25,50]
  print $ valids [1,3,7,10,25,50]
||<

><ol>
<li value=""5"">同様に数値の定義域を整数に拡大すると、有効な式の数が10,839,369個に増えることを確かめよ。<br />
ヒント：関数 <code>valid</code> の定義を変更せよ。</li>
</ol><

<code>eval</code>の方は変えなくてよかったのかな……

>|haskell|
valid         :: Op -> Int -> Int -> Bool
valid Add _ _ =  True
valid Sub x y =  True
valid Mul _ _ =  True
valid Div x y =  y /= 0 && x `mod` y == 0
||<

><ol>
<li value=""6"">関数 <code>solutions''</code> を以下のように改良せよ。
<ol type=""a""><li>式に累乗演算子が使えるようにする</li>
<li>解がない場合に、目標の数に最も近い解を算出する</li>
<li>適切な方法で解を並び替える</li></ol></li>
</ol><

***6-a

累乗ということで<code>Pow</code>を増やした。そしたら整数値がオーバーフローするようになって困った。
しかたなく、validの定義の方でオーバーフローしたものを排除するようにした。

>|haskell|
data Op = Add | Sub | Mul | Div | Pow
  deriving Show

valid         :: Op -> Int -> Int -> Bool
valid Add x y =  x <= y && x + y /= 0
valid Sub x y =  x > y
valid Mul x y =  x /= 1 && y /= 1 && x <= y && x * y /= 0
valid Div x y =  y /= 1 && x `mod` y == 0
valid Pow x y =  x > 1 && y > 1 && x ^ y /= 0

apply         :: Op -> Int -> Int -> Int
apply Add x y =  x + y
apply Sub x y =  x - y
apply Mul x y =  x * y
apply Div x y =  x `div` y
apply Pow x y =  x ^ y

ops :: [Op]
ops =  [Add, Sub, Mul, Div, Pow]
||<

***6-b

目標とする数値との差の絶対値が最小になる式のリストを作って返すようにした。
わりと面倒なコードになってしまったけど、どうなんだろ。

>|haskell|
minsby :: (a -> a -> Ordering) -> [a] -> [a] -> [a]
minsby _ xs     []     = xs
minsby f []     (y:ys) = minsby f [y] ys
minsby f (x:xs) (y:ys)
  | f x y == LT        = minsby f (x:xs) ys
  | f x y == EQ        = minsby f ((x:xs) ++ [y]) ys
  | otherwise          = minsby f [y] ys

solutions'' :: [Int] -> Int -> [Expr]
solutions'' ns n = [e | (e, _) <- minsby f [] candidates]
  where
    f (_, x) (_, y) = compare (abs (x - n)) (abs (y - n))
    candidates = [r | ns' <- choices ns,
                      r <- results ns']
||<

***6-c

「適切な方法」って何だよ！意味がわからない。
なので
-使用した数値の数が小さい順
-使用した数値の並び順
-使用した演算子の並び順
という感じにしてみた。

>|haskell|
data Op = Add | Sub | Mul | Div | Pow
  deriving (Show, Ord, Eq)

opcodes             :: Expr -> [Op]
opcodes (Val _)     =  []
opcodes (App o l r) =  o : (opcodes l) ++ (opcodes r)

type Comparer a = a -> a -> Ordering

andthen         :: Comparer a -> Comparer a -> Comparer a
andthen f g x y =  if f x y /= EQ then f x y else g x y

compareby       :: Ord b => (a -> b) -> Comparer a
compareby f x y =  compare (f x) (f y)

exprcomparer :: Comparer Expr
exprcomparer =  compareby (length . values) `andthen`
                compareby values `andthen`
                compareby opcodes

solutions'' :: [Int] -> Int -> [Expr]
solutions'' ns n = sortBy exprcomparer [e | (e, _) <- minsby f [] candidates]
  where
    f (_, x) (_, y) = compare (abs (x - n)) (abs (y - n))
    candidates = [r | ns' <- choices ns,
                      r <- results ns']
||<
"
2012-03-18,,"*1332056219*第11章 切符番号遊び #2

**11.7 練習問題

><ol>
<li value=""1"">ライブラリ関数<code>concat</code>と<code>map</code>を用いる代わりに、リスト内包表記を使って、組み合わせの関数<code>choices</code>を再定義せよ。</li>
</ol><

10章の練習問題でリストモナドについて書いたことを思い出せば簡単。

>|haskell|
choices' :: [a] -> [[a]]
choices' xs = [zs | ys <- subs xs,
                    zs <- perms ys]
||<

><ol>
<li value=""2"">再帰的な関数<code>isChoice :: Eq a => [a] -> [a] -> Bool</code>を定義せよ。この関数は、関数<code>perms</code>や関数<code>subs</code>を使わずに、一方のリストが他方のリストから選択されたものかを検査する。<br />
ヒント：まずはじめに、あるリストに対して、最初に見つかった特定の値を取り除く関数を定義せよ。</li>
</ol><

というわけでヒントどおりに関数<code>eliminate</code>を定義する。
最初はfilterでいいかと思ったがそれではダメ。「最初に見つかった」値だけを取り除かないといけないから。
>|haskell|
eliminate :: Eq a => a -> [a] -> [a]
eliminate p ps = before ++ after
  where
    before = takeWhile (/=p) ps
    after  = safeTail (dropWhile (/=p) ps)
    safeTail []   = []
    safeTail x:xs = xs
||<

（追記）なんて無駄なコードを……疲れてたのだろうか。消してしまいたい。
>|haskell|
eliminate :: Eq a => a -> [a] -> [a]
eliminate _ [] = []
eliminate x (y:ys)
  | x == y    = ys
  | otherwise = y : eliminate x ys
||<

で、これを使うとこんな感じか。第1引数が選択元、第2引数が選択結果としよう。
>|haskell|
isChoice :: Eq a => [a] -> [a] -> Bool
isChoice _  [] = True
isChoice [] _  = False
isChoice xs (y:ys)
  | not (elem y xs) = False
  | otherwise       = isChoice (eliminate y xs) ys
||<

><ol>
<li value=""3"">関数<code>split</code>を空リストも許すように拡張すると、関数<code>solutions</code>の挙動にどのような影響を与えるか述べよ。</li>
</ol><

空リストを許すということは、こんな定義？
>|haskell|
split        :: [a] -> [([a],[a])]
split []     =  ([], [])
split [x]    =  ([], [x])
split (x:xs) =  ([], (x:xs)) : [(x:ls,rs) | (ls,rs) <- split xs]
||<

splitの結果に要素が1つ増えるだけだし、しかもそれは空リストを含んだタプルなので、exprsの中で無視されるから、たいした影響はないはず……と思ったんだけど、実行してみると逆にちょっと速くなる。何で？
",,"*1332056219*第11章 切符番号遊び #2

**11.7 練習問題

><ol>
<li value=""1"">ライブラリ関数<code>concat</code>と<code>map</code>を用いる代わりに、リスト内包表記を使って、組み合わせの関数<code>choices</code>を再定義せよ。</li>
</ol><

10章の練習問題でリストモナドについて書いたことを思い出せば簡単。

>|haskell|
choices' :: [a] -> [[a]]
choices' xs = [zs | ys <- subs xs,
                    zs <- perms ys]
||<

><ol>
<li value=""2"">再帰的な関数<code>isChoice :: Eq a => [a] -> [a] -> Bool</code>を定義せよ。この関数は、関数<code>perms</code>や関数<code>subs</code>を使わずに、一方のリストが他方のリストから選択されたものかを検査する。<br />
ヒント：まずはじめに、あるリストに対して、最初に見つかった特定の値を取り除く関数を定義せよ。</li>
</ol><

というわけでヒントどおりに関数<code>eliminate</code>を定義する。
最初はfilterでいいかと思ったがそれではダメ。「最初に見つかった」値だけを取り除かないといけないから。
>|haskell|
eliminate :: Eq a => a -> [a] -> [a]
eliminate p ps = before ++ after
  where
    before = takeWhile (/=p) ps
    after  = safeTail (dropWhile (/=p) ps)
    safeTail []   = []
    safeTail x:xs = xs
||<

（追記）なんて無駄なコードを……疲れてたのだろうか。消してしまいたい。
>|haskell|
eliminate :: Eq a => a -> [a] -> [a]
eliminate _ [] = []
eliminate x (y:ys)
  | x == y    = ys
  | otherwise = y : eliminate x ys
||<

で、これを使うとこんな感じか。第1引数が選択元、第2引数が選択結果としよう。
>|haskell|
isChoice :: Eq a => [a] -> [a] -> Bool
isChoice _  [] = True
isChoice [] _  = False
isChoice xs (y:ys)
  | not (elem y xs) = False
  | otherwise       = isChoice (eliminate y xs) ys
||<

><ol>
<li value=""3"">関数<code>split</code>を空リストも許すように拡張すると、関数<code>solutions</code>の挙動にどのような影響を与えるか述べよ。</li>
</ol><

空リストを許すということは、こんな定義？
>|haskell|
split        :: [a] -> [([a],[a])]
split []     =  ([], [])
split [x]    =  ([], [x])
split (x:xs) =  ([], (x:xs)) : [(x:ls,rs) | (ls,rs) <- split xs]
||<

splitの結果に要素が1つ増えるだけだし、しかもそれは空リストを含んだタプルなので、exprsの中で無視されるから、たいした影響はないはず……と思ったんだけど、実行してみると逆にちょっと速くなる。何で？
"
2012-03-07,,"*1331129463*[Haskell][F#]Haskell vs F# リベンジ
[http://haskell.g.hatena.ne.jp/matarillo/20120306/1331058448:title=昨日のHaskellコード]をF#に移植してみた。

>|ocaml|
type Point =
    {X: int; Y: int;}
    static member ( + ) (p: Point, q: Point) = {X = p.X + q.X; Y = p.Y + q.Y;}
    static member ( - ) (p: Point, q: Point) = {X = p.X - q.X; Y = p.Y - q.Y;}

type Pair =
    {Front: Point; Back: Point;}

type Node = Pair list

let move (p : Pair) (q : Point) : Pair =
    {Front = p.Front + q; Back = p.Back - q;}

let moves (p : Pair) (q : Pair) : Pair list =
    let forward : Point = p.Front - q.Front
    let left : Point = {X = forward.Y; Y = -forward.X;}
    let right : Point = {X = -forward.Y; Y = forward.X;}
    List.map (move p) [forward; left; right;]

let nexts (n: Node) : Node list =
    match n with
    | p1::p0::ps -> [for p2 in moves p1 p0 -> p2::n]
    | _ -> []

let exists (p : Point) (qs : Pair list) =
    List.exists (fun q -> p = q.Front || p = q.Back) qs

let solve (size: int) : Node seq =
    let center : Point = {X = size/2; Y = size/2;}
    let p0 : Pair = {Front = center; Back = center;}
    let p1 : Pair = move p0 {X = 0; Y = 1;}
    let initial : Node = [p1; p0;]

    let atboundary (p : Point) : bool =
        (p.X = 0) || (p.X = size) || (p.Y = 0) || (p.Y = size)

    let rec solutions (n : Node) : Node seq =
        match n with
        | p::ps when atboundary p.Front -> Seq.singleton n
        | p::ps when exists p.Front ps -> Seq.empty
        | p::ps -> seq {for n' in (nexts n) do
                        for n'' in (solutions n') do
                        yield n''}
        | _ -> Seq.empty

    solutions initial

printfn ""%d"" (Seq.length (solve 8))
||<

で、実行してみると、これが断然Haskellが速い。

>||
$ time solverhs.exe
184525

real    0m1.613s
user    0m0.000s
sys     0m0.015s

$ time solverfs.exe
184525

real    0m4.550s
user    0m0.000s
sys     0m0.015s
||<

というわけで、やはり得手不得手があるのよなあ。
","rst76wListの高階関数を使って、List/Seqの変換をしないようにしたら、手元の環境では、--O2オプションをつけないHaskellと同じくらいの速度になりました。O2つきにはまだまだ敵いませんが。<br>自分の中で、F#の内包表記は使わないというルールができつつあります。<br><br>let nexts (n: Node) : Node list =<br>　match n with<br>　| p1::p0::ps -&gt; List.map (fun p2 -&gt; p2::n) (moves p1 p0)<br>　| _ -&gt; []<br><br>let rec solutions (n : Node) : Node list =<br>　　match n with<br>　| p::ps when atboundary p.Front -&gt; [n]<br>　| p::ps when exists p.Front ps -&gt; []<br>　| p::ps -&gt; List.collect solutions (nexts n)<br>　| _ -&gt; []x
matarillowそこか！配列じゃないからと油断していましたよ。<br>C#とかとの相互運用性を考えるとSeq自体は重要なんだけどねえ……x
","*1331129463*[Haskell][F#]Haskell vs F# リベンジ
[http://haskell.g.hatena.ne.jp/matarillo/20120306/1331058448:title=昨日のHaskellコード]をF#に移植してみた。

>|ocaml|
type Point =
    {X: int; Y: int;}
    static member ( + ) (p: Point, q: Point) = {X = p.X + q.X; Y = p.Y + q.Y;}
    static member ( - ) (p: Point, q: Point) = {X = p.X - q.X; Y = p.Y - q.Y;}

type Pair =
    {Front: Point; Back: Point;}

type Node = Pair list

let move (p : Pair) (q : Point) : Pair =
    {Front = p.Front + q; Back = p.Back - q;}

let moves (p : Pair) (q : Pair) : Pair list =
    let forward : Point = p.Front - q.Front
    let left : Point = {X = forward.Y; Y = -forward.X;}
    let right : Point = {X = -forward.Y; Y = forward.X;}
    List.map (move p) [forward; left; right;]

let nexts (n: Node) : Node list =
    match n with
    | p1::p0::ps -> [for p2 in moves p1 p0 -> p2::n]
    | _ -> []

let exists (p : Point) (qs : Pair list) =
    List.exists (fun q -> p = q.Front || p = q.Back) qs

let solve (size: int) : Node seq =
    let center : Point = {X = size/2; Y = size/2;}
    let p0 : Pair = {Front = center; Back = center;}
    let p1 : Pair = move p0 {X = 0; Y = 1;}
    let initial : Node = [p1; p0;]

    let atboundary (p : Point) : bool =
        (p.X = 0) || (p.X = size) || (p.Y = 0) || (p.Y = size)

    let rec solutions (n : Node) : Node seq =
        match n with
        | p::ps when atboundary p.Front -> Seq.singleton n
        | p::ps when exists p.Front ps -> Seq.empty
        | p::ps -> seq {for n' in (nexts n) do
                        for n'' in (solutions n') do
                        yield n''}
        | _ -> Seq.empty

    solutions initial

printfn ""%d"" (Seq.length (solve 8))
||<

で、実行してみると、これが断然Haskellが速い。

>||
$ time solverhs.exe
184525

real    0m1.613s
user    0m0.000s
sys     0m0.015s

$ time solverfs.exe
184525

real    0m4.550s
user    0m0.000s
sys     0m0.015s
||<

というわけで、やはり得手不得手があるのよなあ。
"
2012-03-06,,"*1331058448*[Haskell]会社のプログラミングコンテスト

10年ぐらい前の問題をHaskellで解いてみた。
問題は、「8×8ますの正方形のパネルを同じ形に2分割する分け方はいくつあるか」というもの。
↓のコードは回転同型は考慮しているが鏡像同型は考慮してない。でもすっきりと書けたんじゃないかな。
（追記）Node型を修正。
>|haskell|
type Point = (Int, Int)
type Pair = (Point, Point)
type Node = [Pair]

main :: IO ()
main =  do
  print $ length $ solve 8

plus                   :: Point -> Point -> Point
plus (x1, y1) (x2, y2) =  (x1+x2, y1+y2)

minus                   :: Point -> Point -> Point
minus (x1, y1) (x2, y2) =  (x1-x2, y1-y2)

move          :: Pair -> Point -> Pair
move (f, b) p =  (f `plus` p, b `minus` p)

moves                   :: Pair -> Pair -> [Pair]
moves (pf, pb) (qf, qb) =  map (move (pf, pb)) [f, r, l]
  where
    (dx, dy) = pf `minus` qf
    f = (dx, dy)
    r = (-dy, dx)
    l = (dy, -dx)

nexts            :: Node -> [Node]
nexts (p1:p0:ps) =  [p2:p1:p0:ps | p2 <- moves p1 p0]

exists :: Point -> [Pair] -> Bool
exists p = any (either p)
  where
    either p (pf, pb) = p == pf || p == pb

solve      :: Int -> [Node]
solve size =  solutions initial
  where
    center :: Point
    center =  (size `div` 2, size `div` 2)

    p0 :: Pair
    p0 =  (center, center)

    initial :: Node
    initial = [move p0 (0, 1), p0]

    atboundary        :: Point -> Bool
    atboundary (x, y) =  (x == 0) || (x == size) || (y == 0) || (y == size)

    solutions   :: Node -> [Node]
    solutions n
      | atboundary f = [n]
      | exists f ps  = []
      | otherwise    = [n'' | n' <- nexts n,
                              n'' <- solutions n']
      where
        (f,b):ps = n
||<

[http://ideone.com/0gFNU:title=ideone.comでの実行結果。]
",,"*1331058448*[Haskell]会社のプログラミングコンテスト

10年ぐらい前の問題をHaskellで解いてみた。
問題は、「8×8ますの正方形のパネルを同じ形に2分割する分け方はいくつあるか」というもの。
↓のコードは回転同型は考慮しているが鏡像同型は考慮してない。でもすっきりと書けたんじゃないかな。
（追記）Node型を修正。
>|haskell|
type Point = (Int, Int)
type Pair = (Point, Point)
type Node = [Pair]

main :: IO ()
main =  do
  print $ length $ solve 8

plus                   :: Point -> Point -> Point
plus (x1, y1) (x2, y2) =  (x1+x2, y1+y2)

minus                   :: Point -> Point -> Point
minus (x1, y1) (x2, y2) =  (x1-x2, y1-y2)

move          :: Pair -> Point -> Pair
move (f, b) p =  (f `plus` p, b `minus` p)

moves                   :: Pair -> Pair -> [Pair]
moves (pf, pb) (qf, qb) =  map (move (pf, pb)) [f, r, l]
  where
    (dx, dy) = pf `minus` qf
    f = (dx, dy)
    r = (-dy, dx)
    l = (dy, -dx)

nexts            :: Node -> [Node]
nexts (p1:p0:ps) =  [p2:p1:p0:ps | p2 <- moves p1 p0]

exists :: Point -> [Pair] -> Bool
exists p = any (either p)
  where
    either p (pf, pb) = p == pf || p == pb

solve      :: Int -> [Node]
solve size =  solutions initial
  where
    center :: Point
    center =  (size `div` 2, size `div` 2)

    p0 :: Pair
    p0 =  (center, center)

    initial :: Node
    initial = [move p0 (0, 1), p0]

    atboundary        :: Point -> Bool
    atboundary (x, y) =  (x == 0) || (x == size) || (y == 0) || (y == size)

    solutions   :: Node -> [Node]
    solutions n
      | atboundary f = [n]
      | exists f ps  = []
      | otherwise    = [n'' | n' <- nexts n,
                              n'' <- solutions n']
      where
        (f,b):ps = n
||<

[http://ideone.com/0gFNU:title=ideone.comでの実行結果。]
"
2012-03-05,,"*1330964233*第11章 切符番号遊び #1

数日かけて写経したのでまとめて更新。

**11.1 導入
>>
切符番号遊びは、切符の端に書いてある四つの数字を使って、10になるように数式を組み立てる遊びである。
（中略）この章では、ゲームのルールを少し変更する。利用する数は任意の大きさで、全部を使わなくてもよく、目標も任意の数として与えられる。また、計算途中に出てくる数は、自然数 {1, 2, 3, ...}でなければならず、負の数や0、自然数に直せない分数は許されない。
<<

**11.2 問題の形式化
四つの演算子に対する型。
>|haskell|
data Op = Add | Sub | Mul | Div
  deriving Show
||<

二つの自然数に演算子を適用すると自然数を生成するかを調べる関数 <code>valid</code>。
>|haskell|
valid         :: Op -> Int -> Int -> Bool
valid Add _ _ =  True
valid Sub x y =  x > y
valid Mul _ _ =  True
valid Div x y =  x `mod` y == 0
||<

有効な演算子適用を実行する関数 <code>apply</code>。
>|haskell|
apply         :: Op -> Int -> Int -> Int
apply Add x y =  x + y
apply Sub x y =  x - y
apply Mul x y =  x * y
apply Div x y =  x `div` y
||<

数式の型。
>|haskell|
data Expr = Val Int | App Op Expr Expr
  deriving Show
||<

式の中の数値をリストとして返す関数 <code>values</code> と、式全体の値を返す関数 <code>eval</code>。
失敗するかもしれない関数 <code>eval</code> の型は、<code>Maybe</code> 型を使って表現してもいいが、リストならリスト内包が使えるので、今回はそうしているそうだ。
>|haskell|
values             :: Expr -> [Int]
values (Val n)     =  [n]
values (App _ l r) =  values l ++ values r

eval             :: Expr -> [Int]
eval (Val n)     =  [n | n > 0]
eval (App o l r) =  [apply o x y | x <- eval l,
                                   y <- eval r,
                                   valid o x y]
||<

続いて、便利関数。
リストの部分リストを返す関数 <code>subs</code>。
>|haskell|
subs        :: [a] -> [[a]]
subs []     =  [[]]
subs (x:xs) =  yss ++ map (x:) yss
               where yss = subs xs
||<

新たな要素をリストへ挿入して返す関数 <code>interleave</code>。
>|haskell|
interleave          :: a -> [a] -> [[a]]
interleave x []     =  [[x]]
interleave x (y:ys) =  (x:y:ys) : map (y:) (interleave x ys)
||<

リストの要素に対する順列を返す関数 <code>perms</code>。
>|haskell|
perms        :: [a] -> [[a]]
perms []     =  [[]]
perms (x:xs) =  concat (map (interleave x) (perms xs))
||<
これらは再帰的定義になっているのがポイント。

リストから選択肢を返す関数 <code>choices</code>。
>|haskell|
choices :: [a] -> [[a]]
choices xs = concat (map perms (subs xs))
||<

与えられた式が切符番号遊びの解となっているか調べる関数 <code>solution</code>。
>|haskell|
solution        :: Expr -> [Int] -> Int -> Bool
solution e ns n =  elem (values e) (choices ns) && eval e == [n]
||<

**11.3 総当たり法

あるリストを二つの空でないリストに分割して組にする方法すべてを算出する関数 <code>split</code>。
>|haskell|
split        :: [a] -> [([a],[a])]
split []     =  []
split [_]    =  []
split (x:xs) =  ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
||<
これも再帰的定義。

与えられたそれぞれの数値が一回だけ使われている式すべてを返す関数 <code>exprs</code>。
>|haskell|
exprs     :: [int] -> [Expr]
exprs []  =  []
exprs [n] =  [Val n]
exprs ns  =  [e | (ls, rs) <- split ns,
                  l <- exprs ls,
                  r <- exprs rs,
                  e <- combine l r]
||<

二つの式を四つの演算子それぞれで組み合わせる関数 <code>combine</code>。
>|haskell|
combine :: Expr -> Expr -> [Expr]
combine l r = [App o l r | o <- ops]

ops :: [Op]
ops =  [Add, Sub, Mul, Div]
||<

切符番号遊びの一問題を満たす式すべてを返す関数 <code>solutions</code>。
>|haskell|
solutions :: [Int] -> Int -> [Expr]
solutions ns n = [e | ns' <- choices ns,
                      e <- exprs ns',
                      eval e == [n]]
||<
総当りなので遅い。

**11.4 生成と評価の方法を変える
総当たり法を使った切符番号遊びのプログラムの性能を向上させる。
評価に失敗する式は早い段階でふるい落とし、以降はそれらの式から他の式を生成しないようにする。

式とその式全体を評価した値の組 <code>Result</code>。
>|haskell|
type Result = (Expr, Int)
||<

与えられたそれぞれの数値が一回だけ使われている式すべてを返す関数 <code>results</code>。
>|haskell|
results     :: [Int] -> [Result]
results []  =  []
results [n] =  [(Val n, n) | n > 0]
results ns  =  [res | (ls, rs) <- split ns,
                      lx <- results ls,
                      ry <- results rs,
                      res <- combine' lx ry]
||<
これも再帰的定義。

二つの式を四つの演算子それぞれで組み合わせる関数 <code>combine'</code> (効率化版)。
>|haskell|
combine' :: Result -> Result -> [Result]
combine' (l,x) (r,y) = [(App o l r, apply o x y) | o <- ops,
                                                   valid o x y]
||<
有効な結果のみを残す。

切符番号遊びの一問題を満たす式すべてを返す関数 <code>solutions'</code> (効率化版)。
>|haskell|
solutions' :: [Int] -> Int -> [Expr]
solutions' ns n = [e | ns' <- choices ns,
                       (e,m) <- results ns',
                       m == n]
||<

**11.5 代数的な性質をいかす

交換法則と単位元の性質を利用して、有効な式の数を減らす。
交換法則で式を減らすのはいいとして、単位元で式を減らすのは、“数は全部を使わなくても良い”というルールを反映したものである。

演算子の適用が有効かを調べる関数 <code>valid'</code> (数を減らした版)。
>|haskell|
valid'         :: Op -> Int -> Int -> Bool
valid' Add x y =  x <= y
valid' Sub x y =  x > y
valid' Mul x y =  x /= 1 && y /= 1 && x <= y
valid' Div x y =  y /= 1 && x `mod` y == 0
||<

あとは、<code>valid'</code>関数を使うように、他の関数も置き換えていく。
>|haskell|
results'     :: [Int] -> [Result]
results' []  =  []
results' [n] =  [(Val n, n) | n > 0]
results' ns  =  [res | (ls, rs) <- split ns,
                       lx <- results' ls,
                       ry <- results' rs,
                       res <- combine'' lx ry]

combine'' :: Result -> Result -> [Result]
combine'' (l,x) (r,y) = [(App o l r, apply o x y) | o <- ops,
                                                    valid' o x y]

solutions'' :: [Int] -> Int -> [Expr]
solutions'' ns n = [e | ns' <- choices ns,
                        (e,m) <- results' ns',
                        m == n]
||<

実行結果にかかった時間を計測する。

11.3.hs
>|haskell|
import ElevenThree

main :: IO ()
main =  do
  putStrLn $ show (length $ solutions [1,3,7,10,25,50] 765)
||<

11.4.hs
>|haskell|
import ElevenFour

main :: IO ()
main =  do
  putStrLn $ show (length $ solutions' [1,3,7,10,25,50] 765)
||<

11.5.hs
>|haskell|
import ElevenFive

main :: IO ()
main =  do
  putStrLn $ show (length $ solutions'' [1,3,7,10,25,50] 765)
||<

ghcでコンパイル。
>||
$ ghc -odir bin -hidir bin -o bin/11.3.exe 11.3.hs

$ ghc -odir bin -hidir bin -o bin/11.4.exe 11.4.hs

$ ghc -odir bin -hidir bin -o bin/11.5.exe 11.5.hs

||<

>||
$ time bin/11.3.exe
780

real    0m20.731s
user    0m0.000s
sys     0m0.000s

$ time bin/11.4.exe
780

real    0m1.729s
user    0m0.000s
sys     0m0.031s

$ time bin/11.5.exe
49

real    0m0.327s
user    0m0.000s
sys     0m0.015s

||<
",,"*1330964233*第11章 切符番号遊び #1

数日かけて写経したのでまとめて更新。

**11.1 導入
>>
切符番号遊びは、切符の端に書いてある四つの数字を使って、10になるように数式を組み立てる遊びである。
（中略）この章では、ゲームのルールを少し変更する。利用する数は任意の大きさで、全部を使わなくてもよく、目標も任意の数として与えられる。また、計算途中に出てくる数は、自然数 {1, 2, 3, ...}でなければならず、負の数や0、自然数に直せない分数は許されない。
<<

**11.2 問題の形式化
四つの演算子に対する型。
>|haskell|
data Op = Add | Sub | Mul | Div
  deriving Show
||<

二つの自然数に演算子を適用すると自然数を生成するかを調べる関数 <code>valid</code>。
>|haskell|
valid         :: Op -> Int -> Int -> Bool
valid Add _ _ =  True
valid Sub x y =  x > y
valid Mul _ _ =  True
valid Div x y =  x `mod` y == 0
||<

有効な演算子適用を実行する関数 <code>apply</code>。
>|haskell|
apply         :: Op -> Int -> Int -> Int
apply Add x y =  x + y
apply Sub x y =  x - y
apply Mul x y =  x * y
apply Div x y =  x `div` y
||<

数式の型。
>|haskell|
data Expr = Val Int | App Op Expr Expr
  deriving Show
||<

式の中の数値をリストとして返す関数 <code>values</code> と、式全体の値を返す関数 <code>eval</code>。
失敗するかもしれない関数 <code>eval</code> の型は、<code>Maybe</code> 型を使って表現してもいいが、リストならリスト内包が使えるので、今回はそうしているそうだ。
>|haskell|
values             :: Expr -> [Int]
values (Val n)     =  [n]
values (App _ l r) =  values l ++ values r

eval             :: Expr -> [Int]
eval (Val n)     =  [n | n > 0]
eval (App o l r) =  [apply o x y | x <- eval l,
                                   y <- eval r,
                                   valid o x y]
||<

続いて、便利関数。
リストの部分リストを返す関数 <code>subs</code>。
>|haskell|
subs        :: [a] -> [[a]]
subs []     =  [[]]
subs (x:xs) =  yss ++ map (x:) yss
               where yss = subs xs
||<

新たな要素をリストへ挿入して返す関数 <code>interleave</code>。
>|haskell|
interleave          :: a -> [a] -> [[a]]
interleave x []     =  [[x]]
interleave x (y:ys) =  (x:y:ys) : map (y:) (interleave x ys)
||<

リストの要素に対する順列を返す関数 <code>perms</code>。
>|haskell|
perms        :: [a] -> [[a]]
perms []     =  [[]]
perms (x:xs) =  concat (map (interleave x) (perms xs))
||<
これらは再帰的定義になっているのがポイント。

リストから選択肢を返す関数 <code>choices</code>。
>|haskell|
choices :: [a] -> [[a]]
choices xs = concat (map perms (subs xs))
||<

与えられた式が切符番号遊びの解となっているか調べる関数 <code>solution</code>。
>|haskell|
solution        :: Expr -> [Int] -> Int -> Bool
solution e ns n =  elem (values e) (choices ns) && eval e == [n]
||<

**11.3 総当たり法

あるリストを二つの空でないリストに分割して組にする方法すべてを算出する関数 <code>split</code>。
>|haskell|
split        :: [a] -> [([a],[a])]
split []     =  []
split [_]    =  []
split (x:xs) =  ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
||<
これも再帰的定義。

与えられたそれぞれの数値が一回だけ使われている式すべてを返す関数 <code>exprs</code>。
>|haskell|
exprs     :: [int] -> [Expr]
exprs []  =  []
exprs [n] =  [Val n]
exprs ns  =  [e | (ls, rs) <- split ns,
                  l <- exprs ls,
                  r <- exprs rs,
                  e <- combine l r]
||<

二つの式を四つの演算子それぞれで組み合わせる関数 <code>combine</code>。
>|haskell|
combine :: Expr -> Expr -> [Expr]
combine l r = [App o l r | o <- ops]

ops :: [Op]
ops =  [Add, Sub, Mul, Div]
||<

切符番号遊びの一問題を満たす式すべてを返す関数 <code>solutions</code>。
>|haskell|
solutions :: [Int] -> Int -> [Expr]
solutions ns n = [e | ns' <- choices ns,
                      e <- exprs ns',
                      eval e == [n]]
||<
総当りなので遅い。

**11.4 生成と評価の方法を変える
総当たり法を使った切符番号遊びのプログラムの性能を向上させる。
評価に失敗する式は早い段階でふるい落とし、以降はそれらの式から他の式を生成しないようにする。

式とその式全体を評価した値の組 <code>Result</code>。
>|haskell|
type Result = (Expr, Int)
||<

与えられたそれぞれの数値が一回だけ使われている式すべてを返す関数 <code>results</code>。
>|haskell|
results     :: [Int] -> [Result]
results []  =  []
results [n] =  [(Val n, n) | n > 0]
results ns  =  [res | (ls, rs) <- split ns,
                      lx <- results ls,
                      ry <- results rs,
                      res <- combine' lx ry]
||<
これも再帰的定義。

二つの式を四つの演算子それぞれで組み合わせる関数 <code>combine'</code> (効率化版)。
>|haskell|
combine' :: Result -> Result -> [Result]
combine' (l,x) (r,y) = [(App o l r, apply o x y) | o <- ops,
                                                   valid o x y]
||<
有効な結果のみを残す。

切符番号遊びの一問題を満たす式すべてを返す関数 <code>solutions'</code> (効率化版)。
>|haskell|
solutions' :: [Int] -> Int -> [Expr]
solutions' ns n = [e | ns' <- choices ns,
                       (e,m) <- results ns',
                       m == n]
||<

**11.5 代数的な性質をいかす

交換法則と単位元の性質を利用して、有効な式の数を減らす。
交換法則で式を減らすのはいいとして、単位元で式を減らすのは、“数は全部を使わなくても良い”というルールを反映したものである。

演算子の適用が有効かを調べる関数 <code>valid'</code> (数を減らした版)。
>|haskell|
valid'         :: Op -> Int -> Int -> Bool
valid' Add x y =  x <= y
valid' Sub x y =  x > y
valid' Mul x y =  x /= 1 && y /= 1 && x <= y
valid' Div x y =  y /= 1 && x `mod` y == 0
||<

あとは、<code>valid'</code>関数を使うように、他の関数も置き換えていく。
>|haskell|
results'     :: [Int] -> [Result]
results' []  =  []
results' [n] =  [(Val n, n) | n > 0]
results' ns  =  [res | (ls, rs) <- split ns,
                       lx <- results' ls,
                       ry <- results' rs,
                       res <- combine'' lx ry]

combine'' :: Result -> Result -> [Result]
combine'' (l,x) (r,y) = [(App o l r, apply o x y) | o <- ops,
                                                    valid' o x y]

solutions'' :: [Int] -> Int -> [Expr]
solutions'' ns n = [e | ns' <- choices ns,
                        (e,m) <- results' ns',
                        m == n]
||<

実行結果にかかった時間を計測する。

11.3.hs
>|haskell|
import ElevenThree

main :: IO ()
main =  do
  putStrLn $ show (length $ solutions [1,3,7,10,25,50] 765)
||<

11.4.hs
>|haskell|
import ElevenFour

main :: IO ()
main =  do
  putStrLn $ show (length $ solutions' [1,3,7,10,25,50] 765)
||<

11.5.hs
>|haskell|
import ElevenFive

main :: IO ()
main =  do
  putStrLn $ show (length $ solutions'' [1,3,7,10,25,50] 765)
||<

ghcでコンパイル。
>||
$ ghc -odir bin -hidir bin -o bin/11.3.exe 11.3.hs

$ ghc -odir bin -hidir bin -o bin/11.4.exe 11.4.hs

$ ghc -odir bin -hidir bin -o bin/11.5.exe 11.5.hs

||<

>||
$ time bin/11.3.exe
780

real    0m20.731s
user    0m0.000s
sys     0m0.000s

$ time bin/11.4.exe
780

real    0m1.729s
user    0m0.000s
sys     0m0.031s

$ time bin/11.5.exe
49

real    0m0.327s
user    0m0.000s
sys     0m0.015s

||<
"
2012-03-02,,"*1330680915*第10章 型とクラスの定義 #8

**10.8 練習問題

><ol>
<li value=""8"">以下のインスタンス宣言を完成させよ。<br />
<pre>
instance Monad Maybe where
  ...
instance Monad [] where
  ...
</pre>
ここで<code>[]</code>は、<code>[a]</code>から型変数を取り除いたリスト型を表す。<br />
ヒント：最初に、それぞれのインスタンスのメソッド <code>return</code> と <code>&gt;&gt;=</code> の型を考えよ。</li>
</ol><

<code>Maybe</code>はもう自習してたから、<code>[]</code>だけ考えればいいんだけど、こんなんでいいのかな？
LINQに馴染んでいるので、リストがモナドだってことと、bindはSelectMany(scalaならflatMap)ってことは知ってる。
>|haskell|
-- return :: a -> Maybe a
-- >>=    :: Maybe a -> (a -> Maybe b) -> Maybe b
instance Monad Maybe where
  return x      = Just x
  Nothing >>= _ = Nothing
  Just x  >>= f = f x
||<

>|haskell|
-- return :: a -> [a]
-- >>=    :: [a] -> (a -> [b]) -> [b]
instance Monad [] where
  return x = [x]
  xs >>= f = concat (map f xs)
||<

ぐぐったらHaskellにconcatMapという関数があるみたいなのでそれでもよいと思うのだが、教科書には載ってなかったからあえて使わず。
",,"*1330680915*第10章 型とクラスの定義 #8

**10.8 練習問題

><ol>
<li value=""8"">以下のインスタンス宣言を完成させよ。<br />
<pre>
instance Monad Maybe where
  ...
instance Monad [] where
  ...
</pre>
ここで<code>[]</code>は、<code>[a]</code>から型変数を取り除いたリスト型を表す。<br />
ヒント：最初に、それぞれのインスタンスのメソッド <code>return</code> と <code>&gt;&gt;=</code> の型を考えよ。</li>
</ol><

<code>Maybe</code>はもう自習してたから、<code>[]</code>だけ考えればいいんだけど、こんなんでいいのかな？
LINQに馴染んでいるので、リストがモナドだってことと、bindはSelectMany(scalaならflatMap)ってことは知ってる。
>|haskell|
-- return :: a -> Maybe a
-- >>=    :: Maybe a -> (a -> Maybe b) -> Maybe b
instance Monad Maybe where
  return x      = Just x
  Nothing >>= _ = Nothing
  Just x  >>= f = f x
||<

>|haskell|
-- return :: a -> [a]
-- >>=    :: [a] -> (a -> [b]) -> [b]
instance Monad [] where
  return x = [x]
  xs >>= f = concat (map f xs)
||<

ぐぐったらHaskellにconcatMapという関数があるみたいなのでそれでもよいと思うのだが、教科書には載ってなかったからあえて使わず。
"
2012-03-01,,"*1330604619*第10章 型とクラスの定義 #7

**10.8 練習問題

><ol>
<li value=""6"">関数 <code>isTaut</code> と、前の二つの章で定義したパーサーと対話プログラムのライブラリを用いて、対話的に恒真式か検査する関数を実装せよ。ユーザーがキーボードからわかりやすい文法で命題を入力できるようにすること。<br />
ヒント：8章で定義した数式のパーサーを改良して、命題のパーサーを作れ。</li>
</ol><

なかなか面倒な問題だった。パーサーがうまく構成できなくてね。優先度をまちがえて、""True""をパースしたら""T""だけが <code>Var 'T'</code> とパースされたり。

>|haskell|
module TenEightSix where

import Parsing
import NineFive
import TenEightFive

factor :: Parser Prop
factor
  = do
    symbol ""(""
    e <- expr
    symbol "")""
    return e
  +++
    bool
  +++
    variable

bool :: Parser Prop
bool
  = do
    symbol ""True""
    return (Const True)
  +++ do
    symbol ""False""
    return (Const False)

variable :: Parser Prop
variable = token (do
  c <- letter
  return (Var c))

term :: Parser Prop
term
  = do
    symbol ""!""
    f <- factor
    return (Not f)
  +++
    factor

expr :: Parser Prop
expr = do
  t <- term
  (do
    symbol ""&&""
    t2 <- term
    return (And t t2)
   +++ do
    symbol ""||""
    t2 <- term
    return (Or t t2)
   +++ do
    symbol ""=>""
    t2 <- term
    return (Imply t t2)
   +++ do
    symbol ""==""
    t2 <- term
    return (Equiv t t2)
   +++
    return t)

run :: IO ()
run = do
  putStr ""Enter a proposition: ""
  xs <- getLine
  parseTaut xs

parseTaut :: String -> IO ()
parseTaut xs = case parse expr xs of
  [(p,"""")] -> showTaut p
  _        -> putStrLn ""Syntax Error""

showTaut :: Prop -> IO ()
showTaut p = if isTaut p
  then
    putStrLn ""Tautology""
  else
    putStrLn ""Not tautology""
||<

><ol>
<li value=""7"">乗算を扱えるように仮想マシンを拡張せよ。</li>
</ol><

仮想マシンの命令を2つ増やさざるを得ないと思われる。<code>EVAM Expr</code>と<code>MUL Int</code>。最初に定義していた<code>EVAL Expr</code>は加算の右辺評価命令なので、左辺はとりあえず<code>ADD Int</code>を突っ込んでおいて、右辺評価後に加算する。<code>EVAM Expr</code>は乗算の右辺評価命令なので、左辺はとりあえず<code>MUL Int</code>を突っ込んでおいて、右辺評価後に乗算する。

>|diff|
1c1
< data Expr = Val Int | Add Expr Expr
---
> data Expr = Val Int | Add Expr Expr | Mul Expr Expr
4c4
< data Op   = EVAL Expr | ADD Int
---
> data Op   = EVAL Expr | ADD Int | EVAM Expr | MUL Int
8a9
> eval (Mul x y) c = eval x (EVAM y:c)
13a15,16
> exec (EVAM y:c) n =  eval y (MUL n:c)
> exec (MUL n:c) m  =  exec c (n * m)
||<
",,"*1330604619*第10章 型とクラスの定義 #7

**10.8 練習問題

><ol>
<li value=""6"">関数 <code>isTaut</code> と、前の二つの章で定義したパーサーと対話プログラムのライブラリを用いて、対話的に恒真式か検査する関数を実装せよ。ユーザーがキーボードからわかりやすい文法で命題を入力できるようにすること。<br />
ヒント：8章で定義した数式のパーサーを改良して、命題のパーサーを作れ。</li>
</ol><

なかなか面倒な問題だった。パーサーがうまく構成できなくてね。優先度をまちがえて、""True""をパースしたら""T""だけが <code>Var 'T'</code> とパースされたり。

>|haskell|
module TenEightSix where

import Parsing
import NineFive
import TenEightFive

factor :: Parser Prop
factor
  = do
    symbol ""(""
    e <- expr
    symbol "")""
    return e
  +++
    bool
  +++
    variable

bool :: Parser Prop
bool
  = do
    symbol ""True""
    return (Const True)
  +++ do
    symbol ""False""
    return (Const False)

variable :: Parser Prop
variable = token (do
  c <- letter
  return (Var c))

term :: Parser Prop
term
  = do
    symbol ""!""
    f <- factor
    return (Not f)
  +++
    factor

expr :: Parser Prop
expr = do
  t <- term
  (do
    symbol ""&&""
    t2 <- term
    return (And t t2)
   +++ do
    symbol ""||""
    t2 <- term
    return (Or t t2)
   +++ do
    symbol ""=>""
    t2 <- term
    return (Imply t t2)
   +++ do
    symbol ""==""
    t2 <- term
    return (Equiv t t2)
   +++
    return t)

run :: IO ()
run = do
  putStr ""Enter a proposition: ""
  xs <- getLine
  parseTaut xs

parseTaut :: String -> IO ()
parseTaut xs = case parse expr xs of
  [(p,"""")] -> showTaut p
  _        -> putStrLn ""Syntax Error""

showTaut :: Prop -> IO ()
showTaut p = if isTaut p
  then
    putStrLn ""Tautology""
  else
    putStrLn ""Not tautology""
||<

><ol>
<li value=""7"">乗算を扱えるように仮想マシンを拡張せよ。</li>
</ol><

仮想マシンの命令を2つ増やさざるを得ないと思われる。<code>EVAM Expr</code>と<code>MUL Int</code>。最初に定義していた<code>EVAL Expr</code>は加算の右辺評価命令なので、左辺はとりあえず<code>ADD Int</code>を突っ込んでおいて、右辺評価後に加算する。<code>EVAM Expr</code>は乗算の右辺評価命令なので、左辺はとりあえず<code>MUL Int</code>を突っ込んでおいて、右辺評価後に乗算する。

>|diff|
1c1
< data Expr = Val Int | Add Expr Expr
---
> data Expr = Val Int | Add Expr Expr | Mul Expr Expr
4c4
< data Op   = EVAL Expr | ADD Int
---
> data Op   = EVAL Expr | ADD Int | EVAM Expr | MUL Int
8a9
> eval (Mul x y) c = eval x (EVAM y:c)
13a15,16
> exec (EVAM y:c) n =  eval y (MUL n:c)
> exec (MUL n:c) m  =  exec c (n * m)
||<
"
2012-02-27,,"*1330226377*第10章 型とクラスの定義 #6

**10.8 練習問題

><ol>
<li value=""1"">再帰と関数<code>add</code>を用いて、自然数の乗算関数 <code>mult :: Nat -> Nat -> Nat</code> を定義せよ。</li>
</ol><

これは楽勝。（10.3で定義したNatはゼロも自然数だったことを思い出して）

>|haskell|
module TenEightOne where

import TenThree

mult :: Nat -> Nat -> Nat
mult Zero     _    = Zero
mult _        Zero = Zero
mult (Succ m) n    = add n (mult m n)
||<

><ol>
<li value=""2"">付録Aには掲載されていないが、標準ライブラリでは以下のクラスとメソッドが定義されている。<br />
<pre>
data Ordering = LT | EQ | GT
compare :: Ord a => a -> a -> Ordering
</pre>
このメソッドは、順序クラスのある値が他の値と比較して、小さい（LT）か、等しい（EQ）か、大きい（GT）かを判断する。このメソッドを用いて、探索木用の関数 <code>occures :: Int -> Tree -> Bool</code> を再定義せよ。また、新しい実装が本の実装よりも効率的である理由を述べよ。</li>
</ol><

こんなのでどうかな。<code>cp</code>で比較した結果をもとにパターンマッチするから、比較が1回しか実行されない。

>|haskell|
module TenEightTwo where

import TenThree

occurs'' :: Int -> Tree -> Bool
occurs'' m (Leaf n) = m == n
occurs'' m t        = f (cp m t) m t
  where
    cp m (Node _ n _)   = compare m n
    f LT m (Node l _ _) = occurs'' m l
    f EQ _ _            = True
    f GT m (Node _ _ r) = occurs'' m r
||<

><ol>
<li value=""3"">以下の二分木を考えよう。<br />
<pre>data Tree = Leaf Int | Node Tree Tree</pre><br />
全ての節に対して、右と左の部分木にある葉の数が、高々一つだけ異なるとき、木は平衡していると表現する。葉は平衡していると考える。木が平衡しているか調べる関数 <code>balanced :: Tree -> Bool</code> を定義せよ。<br />
ヒント：最初に木の中の葉の数を返す関数を実装せよ。</li>
</ol><

ヒント通りに実装。

>|haskell|
module TenEightThree where

data Tree = Leaf Int | Node Tree Tree

leaves            :: Tree -> Int
leaves (Leaf _)   =  1
leaves (Node l r) =  leaves l + leaves r

balanced            :: Tree -> Bool
balanced (Leaf _)   =  True
balanced (Node l r) =  abs (leaves l - leaves r) <= 1
||<

><ol>
<li value=""4"">空でない整数のリストを平衡木に変換する関数 <code>balance :: [Int] -> Tree</code> を定義せよ。<br />
ヒント：最初にリストを、長さが高々一つだけ異なるリスト二つに分割する関数を実装せよ。
</li>
</ol><

書けたんだけど、空リストを適用すると無限ループしてエラーになってしまう。
>|haskell|
module TenEightFour where

import TenEightThree

devide    :: [a] -> ([a], [a])
devide xs =  splitAt (length xs `div` 2) xs

balance :: [Int] -> Tree
balance [n] = Leaf n
balance xs  = Node (balance l) (balance r)
  where (l, r) = devide xs
||<

><ol>
<li value=""5"">恒真式か検査する関数を拡張して、命題に論理和（∨）と同値（⇔）が使えるようにせよ。</li>
</ol><

コンストラクタに<code>Or</code>と<code>Equiv</code>を追加。ついでに命題としてド・モルガンの法則（の片方）を定義してみる。
>|diff|
@@ -1,4 +1,4 @@
-module TenFour where
+module TenEightFive where
 
 import NineSeven
 import TenOne
@@ -8,6 +8,8 @@
   | Not Prop
   | And Prop Prop
   | Imply Prop Prop
+  | Or Prop Prop
+  | Equiv Prop Prop
 
 p1 :: Prop
 p1 = And (Var 'A') (Not (Var 'A'))
@@ -17,6 +19,8 @@
 p3 = Imply (Var 'A') (And (Var 'A') (Var 'B'))
 p4 :: Prop
 p4 = Imply (And (Var 'A') (Imply (Var 'A') (Var 'B'))) (Var 'B')
+p5 :: Prop
+p5 = Equiv (Not (And (Var 'A') (Var 'B'))) (Or (Not (Var 'A')) (Not (Var 'B')))
 
 type Subst = Assoc Char Bool
 
@@ -26,6 +30,8 @@
 eval s (Not p)     =  not (eval s p)
 eval s (And p q)   =  eval s p && eval s q
 eval s (Imply p q) =  eval s p <= eval s q
+eval s (Or p q)    =  eval s p || eval s q
+eval s (Equiv p q) =  eval s p == eval s q
 
 vars             :: Prop -> [Char]
 vars (Const _)   =  []
@@ -33,6 +39,8 @@
 vars (Not p)     =  vars p
 vars (And p q)   =  vars p ++ vars q
 vars (Imply p q) =  vars p ++ vars q
+vars (Or p q)    =  vars p ++ vars q
+vars (Equiv p q) =  vars p ++ vars q
 
 bools   :: Int -> [[Bool]]
 bools 0 = [[]]
||<
",,"*1330226377*第10章 型とクラスの定義 #6

**10.8 練習問題

><ol>
<li value=""1"">再帰と関数<code>add</code>を用いて、自然数の乗算関数 <code>mult :: Nat -> Nat -> Nat</code> を定義せよ。</li>
</ol><

これは楽勝。（10.3で定義したNatはゼロも自然数だったことを思い出して）

>|haskell|
module TenEightOne where

import TenThree

mult :: Nat -> Nat -> Nat
mult Zero     _    = Zero
mult _        Zero = Zero
mult (Succ m) n    = add n (mult m n)
||<

><ol>
<li value=""2"">付録Aには掲載されていないが、標準ライブラリでは以下のクラスとメソッドが定義されている。<br />
<pre>
data Ordering = LT | EQ | GT
compare :: Ord a => a -> a -> Ordering
</pre>
このメソッドは、順序クラスのある値が他の値と比較して、小さい（LT）か、等しい（EQ）か、大きい（GT）かを判断する。このメソッドを用いて、探索木用の関数 <code>occures :: Int -> Tree -> Bool</code> を再定義せよ。また、新しい実装が本の実装よりも効率的である理由を述べよ。</li>
</ol><

こんなのでどうかな。<code>cp</code>で比較した結果をもとにパターンマッチするから、比較が1回しか実行されない。

>|haskell|
module TenEightTwo where

import TenThree

occurs'' :: Int -> Tree -> Bool
occurs'' m (Leaf n) = m == n
occurs'' m t        = f (cp m t) m t
  where
    cp m (Node _ n _)   = compare m n
    f LT m (Node l _ _) = occurs'' m l
    f EQ _ _            = True
    f GT m (Node _ _ r) = occurs'' m r
||<

><ol>
<li value=""3"">以下の二分木を考えよう。<br />
<pre>data Tree = Leaf Int | Node Tree Tree</pre><br />
全ての節に対して、右と左の部分木にある葉の数が、高々一つだけ異なるとき、木は平衡していると表現する。葉は平衡していると考える。木が平衡しているか調べる関数 <code>balanced :: Tree -> Bool</code> を定義せよ。<br />
ヒント：最初に木の中の葉の数を返す関数を実装せよ。</li>
</ol><

ヒント通りに実装。

>|haskell|
module TenEightThree where

data Tree = Leaf Int | Node Tree Tree

leaves            :: Tree -> Int
leaves (Leaf _)   =  1
leaves (Node l r) =  leaves l + leaves r

balanced            :: Tree -> Bool
balanced (Leaf _)   =  True
balanced (Node l r) =  abs (leaves l - leaves r) <= 1
||<

><ol>
<li value=""4"">空でない整数のリストを平衡木に変換する関数 <code>balance :: [Int] -> Tree</code> を定義せよ。<br />
ヒント：最初にリストを、長さが高々一つだけ異なるリスト二つに分割する関数を実装せよ。
</li>
</ol><

書けたんだけど、空リストを適用すると無限ループしてエラーになってしまう。
>|haskell|
module TenEightFour where

import TenEightThree

devide    :: [a] -> ([a], [a])
devide xs =  splitAt (length xs `div` 2) xs

balance :: [Int] -> Tree
balance [n] = Leaf n
balance xs  = Node (balance l) (balance r)
  where (l, r) = devide xs
||<

><ol>
<li value=""5"">恒真式か検査する関数を拡張して、命題に論理和（∨）と同値（⇔）が使えるようにせよ。</li>
</ol><

コンストラクタに<code>Or</code>と<code>Equiv</code>を追加。ついでに命題としてド・モルガンの法則（の片方）を定義してみる。
>|diff|
@@ -1,4 +1,4 @@
-module TenFour where
+module TenEightFive where
 
 import NineSeven
 import TenOne
@@ -8,6 +8,8 @@
   | Not Prop
   | And Prop Prop
   | Imply Prop Prop
+  | Or Prop Prop
+  | Equiv Prop Prop
 
 p1 :: Prop
 p1 = And (Var 'A') (Not (Var 'A'))
@@ -17,6 +19,8 @@
 p3 = Imply (Var 'A') (And (Var 'A') (Var 'B'))
 p4 :: Prop
 p4 = Imply (And (Var 'A') (Imply (Var 'A') (Var 'B'))) (Var 'B')
+p5 :: Prop
+p5 = Equiv (Not (And (Var 'A') (Var 'B'))) (Or (Not (Var 'A')) (Not (Var 'B')))
 
 type Subst = Assoc Char Bool
 
@@ -26,6 +30,8 @@
 eval s (Not p)     =  not (eval s p)
 eval s (And p q)   =  eval s p && eval s q
 eval s (Imply p q) =  eval s p <= eval s q
+eval s (Or p q)    =  eval s p || eval s q
+eval s (Equiv p q) =  eval s p == eval s q
 
 vars             :: Prop -> [Char]
 vars (Const _)   =  []
@@ -33,6 +39,8 @@
 vars (Not p)     =  vars p
 vars (And p q)   =  vars p ++ vars q
 vars (Imply p q) =  vars p ++ vars q
+vars (Or p q)    =  vars p ++ vars q
+vars (Equiv p q) =  vars p ++ vars q
 
 bools   :: Int -> [[Bool]]
 bools 0 = [[]]
||<
"
2012-02-26,,"*1330217379*第10章 型とクラスの定義 #5

**10.6 クラスとインスタンスの宣言
前にも書いたけど、Haskellのクラスは型クラスで、型クラスのインスタンスは型。
最初はBool型がEqクラスを実装する例。自分でも手を動かしたかったので、Bool_型とEq_クラスを自分で定義してみる。演算子はちょっと悩んだけど、<code>%==</code>と<code>%!=</code>にしてみた。

>|haskell|
data Bool_ = True_ | False_

class Eq_ a where
  (%==) :: a -> a -> Bool
  (%!=) :: a -> a -> Bool
  x %!= y = not (x %== y)

instance Eq_ Bool_ where
  False_ %== False_ = True
  True_  %== True_  = True
  _      %== _      = False
||<

Haskellの型クラスはJavaやC#のインターフェースみたいなものだけど、関数のデフォルト実装を書けるところは違うね。

続いてEq_クラスを拡張したOrd_クラスの例。C#だとIComparable&lt;T&gt;はIEquatable&lt;T&gt;を拡張したインターフェースじゃないけど。

>|haskell|
class Eq_ a => Ord_ a where
  (%<)  :: a -> a -> Bool
  (%<=) :: a -> a -> Bool
  (%>)  :: a -> a -> Bool
  (%>=) :: a -> a -> Bool
  min   :: a -> a -> a
  max   :: a -> a -> a
  min x y | x %<= y   = x
          | otherwise = y
  max x y | x %>= y   = x
          | otherwise = y

instance Ord_ Bool_ where
  False_ %<  True_ = True
  _      %<  _     = False
  b      %<= c     = (b %< c) || (b %== c)
  b      %>  c     = c %< b
  b      %>= c     = c %<= b
||<

***インスタンスの自動導出

おおー、楽だ。Showクラスとか書くの面倒だなと思ってたけど、こんな機能があるならOKだ。
derivingの後ろにクラスを複数書く場合は<code>()</code>で囲む必要あり。
>|haskell|
data Shape = Circle Float | Rect Float Float
  deriving (Eq, Ord)
||<

***モナド型

前に使ったParser型を本当のモナドにした時に、Monadクラスを実装していたこと(と、MonadPlusクラスを実装していたこと)はすでに知ってた。
せっかくなので、Maybe_型を自分で書いてみよう。
>|haskell|
data Maybe_ a = Nothing_ | Just_ a
  deriving Show

instance Monad Maybe_ where
  return x       = Just_ x
  Nothing_ >>= _ = Nothing_
  Just_ x  >>= f = f x
||<
",,"*1330217379*第10章 型とクラスの定義 #5

**10.6 クラスとインスタンスの宣言
前にも書いたけど、Haskellのクラスは型クラスで、型クラスのインスタンスは型。
最初はBool型がEqクラスを実装する例。自分でも手を動かしたかったので、Bool_型とEq_クラスを自分で定義してみる。演算子はちょっと悩んだけど、<code>%==</code>と<code>%!=</code>にしてみた。

>|haskell|
data Bool_ = True_ | False_

class Eq_ a where
  (%==) :: a -> a -> Bool
  (%!=) :: a -> a -> Bool
  x %!= y = not (x %== y)

instance Eq_ Bool_ where
  False_ %== False_ = True
  True_  %== True_  = True
  _      %== _      = False
||<

Haskellの型クラスはJavaやC#のインターフェースみたいなものだけど、関数のデフォルト実装を書けるところは違うね。

続いてEq_クラスを拡張したOrd_クラスの例。C#だとIComparable&lt;T&gt;はIEquatable&lt;T&gt;を拡張したインターフェースじゃないけど。

>|haskell|
class Eq_ a => Ord_ a where
  (%<)  :: a -> a -> Bool
  (%<=) :: a -> a -> Bool
  (%>)  :: a -> a -> Bool
  (%>=) :: a -> a -> Bool
  min   :: a -> a -> a
  max   :: a -> a -> a
  min x y | x %<= y   = x
          | otherwise = y
  max x y | x %>= y   = x
          | otherwise = y

instance Ord_ Bool_ where
  False_ %<  True_ = True
  _      %<  _     = False
  b      %<= c     = (b %< c) || (b %== c)
  b      %>  c     = c %< b
  b      %>= c     = c %<= b
||<

***インスタンスの自動導出

おおー、楽だ。Showクラスとか書くの面倒だなと思ってたけど、こんな機能があるならOKだ。
derivingの後ろにクラスを複数書く場合は<code>()</code>で囲む必要あり。
>|haskell|
data Shape = Circle Float | Rect Float Float
  deriving (Eq, Ord)
||<

***モナド型

前に使ったParser型を本当のモナドにした時に、Monadクラスを実装していたこと(と、MonadPlusクラスを実装していたこと)はすでに知ってた。
せっかくなので、Maybe_型を自分で書いてみよう。
>|haskell|
data Maybe_ a = Nothing_ | Just_ a
  deriving Show

instance Monad Maybe_ where
  return x       = Just_ x
  Nothing_ >>= _ = Nothing_
  Just_ x  >>= f = f x
||<
"
2012-02-23,,"*1330017719*第10章 型とクラスの定義 #4

**10.5 仮想マシン

>>
二つ目の長い例題として、整数と加算演算子からなる単純な数式の型と、この数式を評価して整数にする関数を考えよう。
<<

>|haskell|
data Expr = Val Int | Add Expr Expr
value           :: Expr -> Int
value (Val n)   =  n
value (Add x y) =  value x + value y
||<

で、式 (2+3)+4 をこのデータ型を使って表すと、<code>Add (Add (Val 2) (Val 3)) (Val 4)</code>となる。図にすると下のような感じ。

[f:id:matarillo:20120223232540p:image:w200]

図を書いたときにあらためて気づいたけど、データ型って値型じゃなくて参照型なんだよな。

さて、ここまでなら何て事ないんだけど……

>>
関数 <code>value</code> の定義は、加算演算子の左の引数を右の引数よりも先に評価すると指定している訳ではない。さらに一般的に、どの時点でも次に何をすべきかを指定している訳ではない。評価の順番はHaskellの処理系が決める。
<<

ふむふむ。

>>
しかし望むのであれば、数式を処理する仮想マシンを定義することで、処理の順番を指示できる。
それを実現するために、仮想マシンを制御するスタックの型を宣言しよう。
<<

はい？

で、ここから教科書は仮想マシンの話に突入するのだが、図がなくてちょっとわかりにくかったので、自分の理解のために図を書いてみた（これ、Haskellの勉強から外れるよなあ）。

まず、この仮想マシンは基本的には加算しかしないので、加算用のレジスタと、加算命令を保持するスタックを想定する。加算命令は<code>ADD n</code>の形で、加算レジスタにnを足すという動きをする。

[f:id:matarillo:20120223232541p:image:w200]

こんな仮想マシンで(((1+2)+3)+4)+5を計算する様子が下の図だ。スタックに積んである加算命令を次々に実行した結果、15が得られる。

[f:id:matarillo:20120223232542p:image:w400]

ただし計算したい数式はこんな風に左から足していけばいいわけじゃない。木構造になる。そうすると、<code>ADD n</code>命令は足す数が分かっている場合にしか使えないので困ってしまう。
そこで命令とレジスタを増やす。評価用のレジスタと、評価命令だ。

[f:id:matarillo:20120223232543p:image:w200]

命令スタックの中に<code>EVAL</code>命令が含まれていた場合の命令実行イメージはこのような流れだ。

[f:id:matarillo:20120223232544p:image:w400]

まずは<code>ADD 2</code>を実行して、加算レジスタが3になる。次の命令が<code>EVAL x</code>だったとする（xの中身は<code>Expr</code>型のデータ）。xを評価して、その結果を足したい。そこで、xは評価レジスタに置き、加算レジスタにあった3という値を<code>ADD 3</code>命令に変えてスタックに積み、加算モードから評価モードに切り替える。
評価モードの動作は後で説明するとして、まあ結果的にxを評価した値が3だったとする。評価結果が出た場合はその値を加算レジスタに置き、再度スタック上の加算命令を順に実行していく。

ここまでの流れが理解できれば、評価命令の動作は簡単だ。

評価する式が<code>Val n</code>だったら、評価結果はnだ。評価モードを終了して加算モードに移行する。

[f:id:matarillo:20120223232545p:image:w300]

評価する式が<code>Add x y</code>だったら、yは後で評価して足すのでスタックに<code>EVAL y</code>を積んで、評価レジスタにはxを置き、再度評価する。

[f:id:matarillo:20120223232546p:image:w300]

というわけで、最初の数式 (2+3)+4 がどう評価されて加算されていくかを見てみよう。

[f:id:matarillo:20120223232540p:image:w200]

[f:id:matarillo:20120223232547p:image:w600]

計算の順番が、当初の想定通りに<code>2</code>→<code>3</code>→<code>2+3=5</code>→<code>4</code>→<code>4+5=9</code>となっているのが分かる。

で、コードはこれ。<code>EVAL</code>を実行する関数<code>eval</code>の引数は評価レジスタとスタックで、スタックに積まれた命令を実行しながら加算処理をする関数<code>exec</code>の引数はスタックと加算レジスタだ。

>|haskell|
data Expr = Val Int | Add Expr Expr

type Cont = [Op]
data Op   = EVAL Expr | ADD Int

eval  :: Expr -> Cont -> Int
eval (Val n) c = exec c n
eval (Add x y) c = eval x (EVAL y:c)

exec              :: Cont -> Int -> Int
exec [] n         =  n
exec (EVAL y:c) n =  eval y (ADD n:c)
exec (ADD n:c) m  =  exec c (n + m)

value   :: Expr -> Int
value e =  eval e []
||<
",,"*1330017719*第10章 型とクラスの定義 #4

**10.5 仮想マシン

>>
二つ目の長い例題として、整数と加算演算子からなる単純な数式の型と、この数式を評価して整数にする関数を考えよう。
<<

>|haskell|
data Expr = Val Int | Add Expr Expr
value           :: Expr -> Int
value (Val n)   =  n
value (Add x y) =  value x + value y
||<

で、式 (2+3)+4 をこのデータ型を使って表すと、<code>Add (Add (Val 2) (Val 3)) (Val 4)</code>となる。図にすると下のような感じ。

[f:id:matarillo:20120223232540p:image:w200]

図を書いたときにあらためて気づいたけど、データ型って値型じゃなくて参照型なんだよな。

さて、ここまでなら何て事ないんだけど……

>>
関数 <code>value</code> の定義は、加算演算子の左の引数を右の引数よりも先に評価すると指定している訳ではない。さらに一般的に、どの時点でも次に何をすべきかを指定している訳ではない。評価の順番はHaskellの処理系が決める。
<<

ふむふむ。

>>
しかし望むのであれば、数式を処理する仮想マシンを定義することで、処理の順番を指示できる。
それを実現するために、仮想マシンを制御するスタックの型を宣言しよう。
<<

はい？

で、ここから教科書は仮想マシンの話に突入するのだが、図がなくてちょっとわかりにくかったので、自分の理解のために図を書いてみた（これ、Haskellの勉強から外れるよなあ）。

まず、この仮想マシンは基本的には加算しかしないので、加算用のレジスタと、加算命令を保持するスタックを想定する。加算命令は<code>ADD n</code>の形で、加算レジスタにnを足すという動きをする。

[f:id:matarillo:20120223232541p:image:w200]

こんな仮想マシンで(((1+2)+3)+4)+5を計算する様子が下の図だ。スタックに積んである加算命令を次々に実行した結果、15が得られる。

[f:id:matarillo:20120223232542p:image:w400]

ただし計算したい数式はこんな風に左から足していけばいいわけじゃない。木構造になる。そうすると、<code>ADD n</code>命令は足す数が分かっている場合にしか使えないので困ってしまう。
そこで命令とレジスタを増やす。評価用のレジスタと、評価命令だ。

[f:id:matarillo:20120223232543p:image:w200]

命令スタックの中に<code>EVAL</code>命令が含まれていた場合の命令実行イメージはこのような流れだ。

[f:id:matarillo:20120223232544p:image:w400]

まずは<code>ADD 2</code>を実行して、加算レジスタが3になる。次の命令が<code>EVAL x</code>だったとする（xの中身は<code>Expr</code>型のデータ）。xを評価して、その結果を足したい。そこで、xは評価レジスタに置き、加算レジスタにあった3という値を<code>ADD 3</code>命令に変えてスタックに積み、加算モードから評価モードに切り替える。
評価モードの動作は後で説明するとして、まあ結果的にxを評価した値が3だったとする。評価結果が出た場合はその値を加算レジスタに置き、再度スタック上の加算命令を順に実行していく。

ここまでの流れが理解できれば、評価命令の動作は簡単だ。

評価する式が<code>Val n</code>だったら、評価結果はnだ。評価モードを終了して加算モードに移行する。

[f:id:matarillo:20120223232545p:image:w300]

評価する式が<code>Add x y</code>だったら、yは後で評価して足すのでスタックに<code>EVAL y</code>を積んで、評価レジスタにはxを置き、再度評価する。

[f:id:matarillo:20120223232546p:image:w300]

というわけで、最初の数式 (2+3)+4 がどう評価されて加算されていくかを見てみよう。

[f:id:matarillo:20120223232540p:image:w200]

[f:id:matarillo:20120223232547p:image:w600]

計算の順番が、当初の想定通りに<code>2</code>→<code>3</code>→<code>2+3=5</code>→<code>4</code>→<code>4+5=9</code>となっているのが分かる。

で、コードはこれ。<code>EVAL</code>を実行する関数<code>eval</code>の引数は評価レジスタとスタックで、スタックに積まれた命令を実行しながら加算処理をする関数<code>exec</code>の引数はスタックと加算レジスタだ。

>|haskell|
data Expr = Val Int | Add Expr Expr

type Cont = [Op]
data Op   = EVAL Expr | ADD Int

eval  :: Expr -> Cont -> Int
eval (Val n) c = exec c n
eval (Add x y) c = eval x (EVAL y:c)

exec              :: Cont -> Int -> Int
exec [] n         =  n
exec (EVAL y:c) n =  eval y (ADD n:c)
exec (ADD n:c) m  =  exec c (n + m)

value   :: Expr -> Int
value e =  eval e []
||<
"
2012-02-21,,"*1329735474*第10章 型とクラスの定義 #3
**10.4 恒真式
命題論理式を表す型を作り、与えられた命題が恒真式（式に含まれる変数の値に関係なく、常に真となる式）かどうかを判定する関数を書く。

まずは命題の型を定義。
:真理値(True, False):Const Bool
:変数(A, B, ... , Z):Var Char
:否定(￢):Not Prop
:論理積(∧):And Prop Prop
:論理包含(⇒):Imply Prop Prop

>|haskell|
data Prop = Const Bool
  | Var Char
  | Not Prop
  | And Prop Prop
  | Imply Prop Prop
||<

変数名を真理値に対応付ける置換表を定義して、与えられた置換表を元に命題の値を評価する関数も書く。
>|haskell|
type Subst = Assoc Char Bool

eval               :: Subst -> Prop -> Bool
eval _ (Const b)   =  b
eval s (Var x)     =  find x s
eval s (Not p)     =  not (eval s p)
eval s (And p q)   =  eval s p && eval s q
eval s (Imply p q) =  eval s p <= eval s q
||<

命題の中から変数（重複あり）を抽出する関数は

>|haskell|
vars             :: Prop -> [Char]
vars (Const _)   =  []
vars (Var x)     =  [x]
vars (Not p)     =  vars p
vars (And p q)   =  vars p ++ vars q
vars (Imply p q) =  vars p ++ vars q
||<

変数の数に対応して、とり得る真理値の組み合わせを列挙する関数は
>|haskell|
bools   :: Int -> [[Bool]]
bools 0 = [[]]
bools n = map (False:) bss ++ map (True:) bss
          where bss = bools (n-1)

-- bools n =  map (map conv . make n . int2bin) [0..limit]
--   where
--     limit = (2 ^ n) - 1
--     make n bs = take n (bs ++ repeat 0)
--     conv 0 = False
--     conv 1 = True
--     int2bin 0 = []
--     int2bin n = n `mod` 2 : int2bin (n `div` 2)
||<

道具がそろってきたので、命題に含まれる変数がとり得る真理値の組み合わせを置換表にして列挙する関数を定義し、それを使って恒真式の判定関数を書く。

>|haskell|
substs   :: Prop -> [Subst]
substs p =  map (zip vs) (bools (length vs))
            where vs = rmdups (vars p)

isTaut   :: Prop -> Bool
isTaut p =  and [eval s p | s <- substs p]
||<
",,"*1329735474*第10章 型とクラスの定義 #3
**10.4 恒真式
命題論理式を表す型を作り、与えられた命題が恒真式（式に含まれる変数の値に関係なく、常に真となる式）かどうかを判定する関数を書く。

まずは命題の型を定義。
:真理値(True, False):Const Bool
:変数(A, B, ... , Z):Var Char
:否定(￢):Not Prop
:論理積(∧):And Prop Prop
:論理包含(⇒):Imply Prop Prop

>|haskell|
data Prop = Const Bool
  | Var Char
  | Not Prop
  | And Prop Prop
  | Imply Prop Prop
||<

変数名を真理値に対応付ける置換表を定義して、与えられた置換表を元に命題の値を評価する関数も書く。
>|haskell|
type Subst = Assoc Char Bool

eval               :: Subst -> Prop -> Bool
eval _ (Const b)   =  b
eval s (Var x)     =  find x s
eval s (Not p)     =  not (eval s p)
eval s (And p q)   =  eval s p && eval s q
eval s (Imply p q) =  eval s p <= eval s q
||<

命題の中から変数（重複あり）を抽出する関数は

>|haskell|
vars             :: Prop -> [Char]
vars (Const _)   =  []
vars (Var x)     =  [x]
vars (Not p)     =  vars p
vars (And p q)   =  vars p ++ vars q
vars (Imply p q) =  vars p ++ vars q
||<

変数の数に対応して、とり得る真理値の組み合わせを列挙する関数は
>|haskell|
bools   :: Int -> [[Bool]]
bools 0 = [[]]
bools n = map (False:) bss ++ map (True:) bss
          where bss = bools (n-1)

-- bools n =  map (map conv . make n . int2bin) [0..limit]
--   where
--     limit = (2 ^ n) - 1
--     make n bs = take n (bs ++ repeat 0)
--     conv 0 = False
--     conv 1 = True
--     int2bin 0 = []
--     int2bin n = n `mod` 2 : int2bin (n `div` 2)
||<

道具がそろってきたので、命題に含まれる変数がとり得る真理値の組み合わせを置換表にして列挙する関数を定義し、それを使って恒真式の判定関数を書く。

>|haskell|
substs   :: Prop -> [Subst]
substs p =  map (zip vs) (bools (length vs))
            where vs = rmdups (vars p)

isTaut   :: Prop -> Bool
isTaut p =  and [eval s p | s <- substs p]
||<
"
2012-02-20,,"*1329713457*第10章 型とクラスの定義 #2
前回の日記でdataによる型定義を学んだけど、これ、もっと掘り下げておくべきだったな。

引数なしのデータコンストラクタだと列挙型みたいなもの。これはOK。たとえば、Bool型の要素がTrueとFalse、といった形でこれまでも登場している。
でも引数ありのデータコンストラクタを持つ型は、これまでになかったものだ。これはCで言えば構造体だし、オブジェクト指向言語でいえばオブジェクトにあたるのだけど、以下が違う。

-フィールドには名前がいらない。
-名前のないフィールドを参照するときはパターンマッチ（順序で区別する）。

この理解は正しいかな？と思いながらググったら、こんなこともわかった。

-データコンストラクタのパターンマッチは、リストのパターンマッチという形ですでに登場していた
-フィールドには名前をつけることもできる。

ふむ。教科書にはそこまで書いてないから、先取りしたことになるだろうか。

**10.3 再帰型
ここのコード写経ではデータコンストラクタのパターンマッチがたくさん登場する。

まずは、ペアノの公理みたいな自然数定義（ゼロは自然数！）。
教科書ではn+kパターンで書かれていた部分を書き換えてみながら。
（ちなみに、NatをShowクラスのインスタンスにしていないので、hugsやghicでNatを評価するとエラーになってしまう。）

>|haskell|
-- rec (Peano axioms)
data Nat = Zero | Succ Nat

nat2int          :: Nat -> Int
nat2int Zero     =  0
nat2int (Succ n) =  1 + nat2int n

int2nat   :: Int -> Nat
int2nat 0 =  Zero
int2nat n =  Succ (int2nat (n-1))
-- n + k pattern
-- int2nat (n + 1) =  Succ (int2nat n)

add            :: Nat -> Nat -> Nat
add Zero n     =  n
add (Succ m) n =  Succ (add m n)
||<

続いて、リスト（コンスセルのリスト）を自分定義。
>|haskell|
-- rec (List)
data List a = Nil | Cons a (List a)

len             :: List a -> Int
len Nil         =  0
len (Cons _ xs) =  1 + len xs
||<

最後に、二分木。なお、<code>occurs'</code>関数は二分探索木用の定義。

>|haskell|
-- rec (Binary Tree)
data Tree = Leaf Int | Node Tree Int Tree

t :: Tree
t =  Node (Node (Leaf 1) 3 (Leaf 4)) 5 (Node (Leaf 6) 7 (Leaf 9))

occurs                :: Int -> Tree -> Bool
occurs m (Leaf n)     =  m == n
occurs m (Node l n r) =  m == n || occurs m l || occurs m r

flatten              :: Tree -> [Int]
flatten (Leaf n)     =  [n]
flatten (Node l n r) =  flatten l ++ [n] ++ flatten r

occurs' :: Int -> Tree -> Bool
occurs' m (Leaf n) =  m == n
occurs' m (Node l n r)
  | m == n    = True
  | m < n     = occurs' m l
  | otherwise = occurs' m r
||<

おまけで、木構造の定義のバリエーション。
>|haskell|
-- data Tree a = Leaf a | Node (Tree a) (Tree a)
-- data Tree a = Leaf | Node (Tree a) a (Tree a)
-- data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)
-- data Tree a = Node a [Tree a]
||<
",,"*1329713457*第10章 型とクラスの定義 #2
前回の日記でdataによる型定義を学んだけど、これ、もっと掘り下げておくべきだったな。

引数なしのデータコンストラクタだと列挙型みたいなもの。これはOK。たとえば、Bool型の要素がTrueとFalse、といった形でこれまでも登場している。
でも引数ありのデータコンストラクタを持つ型は、これまでになかったものだ。これはCで言えば構造体だし、オブジェクト指向言語でいえばオブジェクトにあたるのだけど、以下が違う。

-フィールドには名前がいらない。
-名前のないフィールドを参照するときはパターンマッチ（順序で区別する）。

この理解は正しいかな？と思いながらググったら、こんなこともわかった。

-データコンストラクタのパターンマッチは、リストのパターンマッチという形ですでに登場していた
-フィールドには名前をつけることもできる。

ふむ。教科書にはそこまで書いてないから、先取りしたことになるだろうか。

**10.3 再帰型
ここのコード写経ではデータコンストラクタのパターンマッチがたくさん登場する。

まずは、ペアノの公理みたいな自然数定義（ゼロは自然数！）。
教科書ではn+kパターンで書かれていた部分を書き換えてみながら。
（ちなみに、NatをShowクラスのインスタンスにしていないので、hugsやghicでNatを評価するとエラーになってしまう。）

>|haskell|
-- rec (Peano axioms)
data Nat = Zero | Succ Nat

nat2int          :: Nat -> Int
nat2int Zero     =  0
nat2int (Succ n) =  1 + nat2int n

int2nat   :: Int -> Nat
int2nat 0 =  Zero
int2nat n =  Succ (int2nat (n-1))
-- n + k pattern
-- int2nat (n + 1) =  Succ (int2nat n)

add            :: Nat -> Nat -> Nat
add Zero n     =  n
add (Succ m) n =  Succ (add m n)
||<

続いて、リスト（コンスセルのリスト）を自分定義。
>|haskell|
-- rec (List)
data List a = Nil | Cons a (List a)

len             :: List a -> Int
len Nil         =  0
len (Cons _ xs) =  1 + len xs
||<

最後に、二分木。なお、<code>occurs'</code>関数は二分探索木用の定義。

>|haskell|
-- rec (Binary Tree)
data Tree = Leaf Int | Node Tree Int Tree

t :: Tree
t =  Node (Node (Leaf 1) 3 (Leaf 4)) 5 (Node (Leaf 6) 7 (Leaf 9))

occurs                :: Int -> Tree -> Bool
occurs m (Leaf n)     =  m == n
occurs m (Node l n r) =  m == n || occurs m l || occurs m r

flatten              :: Tree -> [Int]
flatten (Leaf n)     =  [n]
flatten (Node l n r) =  flatten l ++ [n] ++ flatten r

occurs' :: Int -> Tree -> Bool
occurs' m (Leaf n) =  m == n
occurs' m (Node l n r)
  | m == n    = True
  | m < n     = occurs' m l
  | otherwise = occurs' m r
||<

おまけで、木構造の定義のバリエーション。
>|haskell|
-- data Tree a = Leaf a | Node (Tree a) (Tree a)
-- data Tree a = Leaf | Node (Tree a) a (Tree a)
-- data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)
-- data Tree a = Node a [Tree a]
||<
"
2012-02-19,,"*1329633378*第10章 型とクラスの定義 #1
**10.1 typeによる型宣言
<code>type</code>キーワードは型のエイリアスに名前をつける方法。再帰定義はできない。
>|haskell|
type Assoc k v = [(k,v)]

find     :: Eq k => k -> Assoc k v -> v
find k t =  head [v | (k',v) <- t, k == k']
||<

<code>newtype</code>キーワードは教科書に出て来てないなあ。

**10.2 dataによる型宣言
<code>data</code>はデータコンストラクタ（構築子）を並べる型宣言。
下の例だと、<code>Left_</code>、<code>Right_</code>、<code>Up_</code>、<code>Down_</code>が引数なしのデータコンストラクタ。
要するに、型<code>Move</code>は列挙型ということ。

>|haskell|
-- nullary data constructor
type Pos = (Int,Int)
data Move = Left_ | Right_ | Up_ | Down_

move              :: Move -> Pos -> Pos
move Left_ (x,y)  =  (x-1,  y)
move Right_ (x,y) =  (x+1,  y)
move Up_ (x,y)    =  (  x,y-1)
move Down_ (x,y)  =  (  x,y+1)

moves          :: [Move] -> Pos -> Pos
moves [] p     =  p
moves (m:ms) p =  moves ms (move m p)

flip        :: Move -> Move
flip Left_  =  Right_
flip Right_ =  Left_
flip Up_    =  Down_
flip Down_  =  Up_
||<

下の例は、<code>Circle</code>が1引数のデータコンストラクタ、<code>Rect</code>が2引数のデータコンストラクタ。

>|haskell|
-- unary/binary data constructor
data Shape = Circle Float | Rect Float Float

square   :: Float -> Shape
square n =  Rect n n

area            :: Shape -> Float
area (Circle r) =  pi * r ^ 2
area (Rect x y) =  x * y
||<

多相型（型引数付き）も定義可能。ここで<code>Maybe a</code>が例に登場。
>|haskell|
-- polymorphic data constructor with a type parameter
-- (data Maybe a = Nothing | Just a)
safediv     :: Int -> Int -> Maybe Int
safediv _ 0 =  Nothing
safediv m n = Just (m `div` n)

safehead    :: [a] -> Maybe a
safehead [] =  Nothing
safehead xs =  Just (head xs)
||<
",,"*1329633378*第10章 型とクラスの定義 #1
**10.1 typeによる型宣言
<code>type</code>キーワードは型のエイリアスに名前をつける方法。再帰定義はできない。
>|haskell|
type Assoc k v = [(k,v)]

find     :: Eq k => k -> Assoc k v -> v
find k t =  head [v | (k',v) <- t, k == k']
||<

<code>newtype</code>キーワードは教科書に出て来てないなあ。

**10.2 dataによる型宣言
<code>data</code>はデータコンストラクタ（構築子）を並べる型宣言。
下の例だと、<code>Left_</code>、<code>Right_</code>、<code>Up_</code>、<code>Down_</code>が引数なしのデータコンストラクタ。
要するに、型<code>Move</code>は列挙型ということ。

>|haskell|
-- nullary data constructor
type Pos = (Int,Int)
data Move = Left_ | Right_ | Up_ | Down_

move              :: Move -> Pos -> Pos
move Left_ (x,y)  =  (x-1,  y)
move Right_ (x,y) =  (x+1,  y)
move Up_ (x,y)    =  (  x,y-1)
move Down_ (x,y)  =  (  x,y+1)

moves          :: [Move] -> Pos -> Pos
moves [] p     =  p
moves (m:ms) p =  moves ms (move m p)

flip        :: Move -> Move
flip Left_  =  Right_
flip Right_ =  Left_
flip Up_    =  Down_
flip Down_  =  Up_
||<

下の例は、<code>Circle</code>が1引数のデータコンストラクタ、<code>Rect</code>が2引数のデータコンストラクタ。

>|haskell|
-- unary/binary data constructor
data Shape = Circle Float | Rect Float Float

square   :: Float -> Shape
square n =  Rect n n

area            :: Shape -> Float
area (Circle r) =  pi * r ^ 2
area (Rect x y) =  x * y
||<

多相型（型引数付き）も定義可能。ここで<code>Maybe a</code>が例に登場。
>|haskell|
-- polymorphic data constructor with a type parameter
-- (data Maybe a = Nothing | Just a)
safediv     :: Int -> Int -> Maybe Int
safediv _ 0 =  Nothing
safediv m n = Just (m `div` n)

safehead    :: [a] -> Maybe a
safehead [] =  Nothing
safehead xs =  Just (head xs)
||<
"
2012-02-18,,"*1329559966*第9章 対話プログラム #9

**9.9 練習問題
練習問題5は「グラフィック・ライブラリを用いて」とか書いてあって面倒なのでパス。Windowsで動かなかったりするし。

><ol>
<li value=""6"">ニムはボードを使うゲームである。ボードには、番号の付いた行が五つあり、はじめは星が以下のように並べてある。
<pre>
1:*****
2:****
3:***
4:**
5:*
</pre>
二人のプレイヤーは、交互に行を一つ選び、その最後から一つ以上の星を取る。ボードから最後の星を取った方が勝ちである。ニムをHaskellで実装せよ。<br />ヒント：それぞれの残っている星の数のリストでボードを定義せよ。ボードの初期値は <code>[5,4,3,2,1]</code> となる。</li>
</ol><

割と長くなったので解説を入れながら。

まず、入力のところを考える。
入力は<code>""行番号 星の数""</code>と入力してEnterを押す仕様にする。
せっかくなのでパーザーモナドを使う。
>|haskell|
import Parsing

niminput :: Parser (Int,Int)
niminput =  do
  row <- nat
  space
  count <- nat
  return (row,count)
||<
こんな感じで、パーズに成功したら(行番号,星の数)というタプルを返すことにする。

出力は、9.5の関数を一部使う。
zip関数で(行番号,星の数)というタプルのリストを作って、それぞれを表示する。
>|haskell|
import NineFive

type Board = [Int]

display    :: Board -> IO ()
display xs =  seqn $ map displayline $ zip [1..length xs] xs

displayline :: (Int,Int) -> IO ()
displayline (row,count) = do
  putStr (show row ++ "":"")
  putStrLn (replicate count '*')
||<

星を取る関数の仕様はちょっと悩んだ。
入力が不正だと星を取れないというロジックを組み込まないといけない。
というわけで、(成否を表す真偽値,結果のボード)のタプルを返すようにしてみた。
Maybeモナドのほうがいいのかもしれないが、まだ教科書には出て来てないからな。
>|haskell|
getstars :: Board -> (Int,Int) -> (Bool,Board)
getstars xs (row,count)
  | row == 0              = (False,xs)
  | count == 0            = (False,xs)
  | row > length xs       = (False,xs)
  | xs !! (row-1) < count = (False,xs)
  | otherwise             = (True,take (row-1) xs ++ [xs !! (row-1) - count] ++ drop row xs)
||<

あとはIOモナドでグリグリと表示したり入力したり。

というわけで、回答はこちら。

>|haskell|
module NineNineFive where

import Parsing
import NineFive

niminput :: Parser (Int,Int)
niminput =  do
  row <- nat
  space
  count <- nat
  return (row,count)

type Board = [Int]

display    :: Board -> IO ()
display xs =  seqn $ map displayline $ zip [1..length xs] xs

displayline :: (Int,Int) -> IO ()
displayline (row,count) = do
  putStr (show row ++ "":"")
  putStrLn (replicate count '*')

getstars :: Board -> (Int,Int) -> (Bool,Board)
getstars xs (row,count)
  | row == 0              = (False,xs)
  | count == 0            = (False,xs)
  | row > length xs       = (False,xs)
  | xs !! (row-1) < count = (False,xs)
  | otherwise             = (True,take (row-1) xs ++ [xs !! (row-1) - count] ++ drop row xs)

turn :: Int -> Board -> IO ()
turn p b
  | all (==0) b = return ()
  | otherwise   = do {display b; input p b}

input :: Int -> Board -> IO ()
input p b = do
  putStr (""Player "" ++ show p ++ "": "")
  xs <- getLine
  process p b $ parse niminput xs

process :: Int -> Board -> [((Int,Int),String)] -> IO ()
process p b []      = do {beep; input p b}
process p b [(r,_)] = check p $ getstars b r

check :: Int -> (Bool,Board) -> IO ()
check p (False, b) = do {beep; input p b}
check p (True , b) =
  if all (==0) b then
    putStrLn (""Player "" ++ show p ++ "" won!"")
  else
    turn (chenge p) b

chenge   :: Int -> Int
chenge 1 =  2
chenge 2 =  1

nim :: IO ()
nim =  turn 1 [5,4,3,2,1]
||<
",,"*1329559966*第9章 対話プログラム #9

**9.9 練習問題
練習問題5は「グラフィック・ライブラリを用いて」とか書いてあって面倒なのでパス。Windowsで動かなかったりするし。

><ol>
<li value=""6"">ニムはボードを使うゲームである。ボードには、番号の付いた行が五つあり、はじめは星が以下のように並べてある。
<pre>
1:*****
2:****
3:***
4:**
5:*
</pre>
二人のプレイヤーは、交互に行を一つ選び、その最後から一つ以上の星を取る。ボードから最後の星を取った方が勝ちである。ニムをHaskellで実装せよ。<br />ヒント：それぞれの残っている星の数のリストでボードを定義せよ。ボードの初期値は <code>[5,4,3,2,1]</code> となる。</li>
</ol><

割と長くなったので解説を入れながら。

まず、入力のところを考える。
入力は<code>""行番号 星の数""</code>と入力してEnterを押す仕様にする。
せっかくなのでパーザーモナドを使う。
>|haskell|
import Parsing

niminput :: Parser (Int,Int)
niminput =  do
  row <- nat
  space
  count <- nat
  return (row,count)
||<
こんな感じで、パーズに成功したら(行番号,星の数)というタプルを返すことにする。

出力は、9.5の関数を一部使う。
zip関数で(行番号,星の数)というタプルのリストを作って、それぞれを表示する。
>|haskell|
import NineFive

type Board = [Int]

display    :: Board -> IO ()
display xs =  seqn $ map displayline $ zip [1..length xs] xs

displayline :: (Int,Int) -> IO ()
displayline (row,count) = do
  putStr (show row ++ "":"")
  putStrLn (replicate count '*')
||<

星を取る関数の仕様はちょっと悩んだ。
入力が不正だと星を取れないというロジックを組み込まないといけない。
というわけで、(成否を表す真偽値,結果のボード)のタプルを返すようにしてみた。
Maybeモナドのほうがいいのかもしれないが、まだ教科書には出て来てないからな。
>|haskell|
getstars :: Board -> (Int,Int) -> (Bool,Board)
getstars xs (row,count)
  | row == 0              = (False,xs)
  | count == 0            = (False,xs)
  | row > length xs       = (False,xs)
  | xs !! (row-1) < count = (False,xs)
  | otherwise             = (True,take (row-1) xs ++ [xs !! (row-1) - count] ++ drop row xs)
||<

あとはIOモナドでグリグリと表示したり入力したり。

というわけで、回答はこちら。

>|haskell|
module NineNineFive where

import Parsing
import NineFive

niminput :: Parser (Int,Int)
niminput =  do
  row <- nat
  space
  count <- nat
  return (row,count)

type Board = [Int]

display    :: Board -> IO ()
display xs =  seqn $ map displayline $ zip [1..length xs] xs

displayline :: (Int,Int) -> IO ()
displayline (row,count) = do
  putStr (show row ++ "":"")
  putStrLn (replicate count '*')

getstars :: Board -> (Int,Int) -> (Bool,Board)
getstars xs (row,count)
  | row == 0              = (False,xs)
  | count == 0            = (False,xs)
  | row > length xs       = (False,xs)
  | xs !! (row-1) < count = (False,xs)
  | otherwise             = (True,take (row-1) xs ++ [xs !! (row-1) - count] ++ drop row xs)

turn :: Int -> Board -> IO ()
turn p b
  | all (==0) b = return ()
  | otherwise   = do {display b; input p b}

input :: Int -> Board -> IO ()
input p b = do
  putStr (""Player "" ++ show p ++ "": "")
  xs <- getLine
  process p b $ parse niminput xs

process :: Int -> Board -> [((Int,Int),String)] -> IO ()
process p b []      = do {beep; input p b}
process p b [(r,_)] = check p $ getstars b r

check :: Int -> (Bool,Board) -> IO ()
check p (False, b) = do {beep; input p b}
check p (True , b) =
  if all (==0) b then
    putStrLn (""Player "" ++ show p ++ "" won!"")
  else
    turn (chenge p) b

chenge   :: Int -> Int
chenge 1 =  2
chenge 2 =  1

nim :: IO ()
nim =  turn 1 [5,4,3,2,1]
||<
"
2012-02-17,,"*1329456649*第9章 対話プログラム #8

**9.9 練習問題

><ol>
<li value=""4"">ライフゲームのボードを対話的に作成したり、変更したりできるエディターを作れ。</li>
</ol><

[http://haskell.g.hatena.ne.jp/matarillo/20120125/1327499245:title=9.7で写経したライフゲーム]を修正して、ボードサイズを可変にできるようにしてやったぜ。

>|haskell|
module NineNineFour where

import System.IO
import NineFive

getCh :: IO Char
getCh =  do hSetEcho stdin False
            c <- getChar
            hSetEcho stdin True
            return c

-- variable size

type Board = [Pos]
type Size  = Pos

showcells   :: Board -> IO ()
showcells b =  seqn [writeat p ""O"" | p <- b]

isAlive     :: Board -> Pos -> Bool
isAlive b p =  elem p b

isEmpty     :: Board -> Pos -> Bool
isEmpty b p =  not (isAlive b p)

neighbs         :: Size -> Pos -> [Pos]
neighbs s (x,y) =  map (wrap s)
                     [(x-1,y-1), (x,y-1), (x+1,y-1),
                      (x-1,y),            (x+1,y),
                      (x-1,y+1), (x,y+1), (x+1,y+1)]

wrap             :: Size -> Pos -> Pos
wrap (w,h) (x,y) =  (((x-1) `mod` w) + 1, ((y-1) `mod` h) + 1)

liveneighbs      :: Size -> Board -> Pos -> Int
liveneighbs s b  =  length . filter (isAlive b) . neighbs s

survivors     :: Size -> Board -> [Pos]
survivors s b =  [p | p <- b, elem (liveneighbs s b p) [2,3]]

births     :: Size -> Board -> [Pos]
births s b =  [p | p <- rmdups (concat (map (neighbs s) b)),
                   isEmpty b p,
                   liveneighbs s b p == 3]

rmdups        :: Eq a => [a] -> [a]
rmdups []     =  []
rmdups (x:xs) =  x:rmdups (filter ((/=) x) xs)

nextgen     :: Size -> Board -> Board
nextgen s b =  survivors s b ++ births s b

life     :: Size -> Board -> IO ()
life s b =  do
  cls
  showcells b
  wait 5000
  life s (nextgen s b)

wait   :: Int -> IO ()
wait n =  seqn [return () | _ <- [1..n]]

-- board maker

runlife     :: Int -> Int -> IO ()
runlife w h =  makeboard (w,h) [] (1,1)

makeboard       :: Size -> Board -> Pos -> IO ()
makeboard s b p =  do
  cls
  showcells b
  goto p
  c <- getCh
  process s b p c

move                   :: Size -> Pos -> Pos -> Pos
move s (dx,dy) (px,py) =  wrap s (px+dx,py+dy)

up    = ( 0, -1)
down  = ( 0,  1)
right = ( 1,  0)
left  = (-1,  0)

process      :: Size -> Board -> Pos -> Char -> IO ()
process s b p c
  | elem c ""\n"" = life s b
  | elem c "" ""  = makeboard s (flippos p b) p
  | elem c ""c""  = makeboard s [] p
  | elem c ""k""  = makeboard s b (move s up p)
  | elem c ""j""  = makeboard s b (move s down p)
  | elem c ""h""  = makeboard s b (move s left p)
  | elem c ""l""  = makeboard s b (move s right p)
  | otherwise   = makeboard s b p

flippos     :: Pos -> Board -> Board
flippos p b =  if elem p b
               then [q | q <- b, q /= p]
               else p : b

||<
",,"*1329456649*第9章 対話プログラム #8

**9.9 練習問題

><ol>
<li value=""4"">ライフゲームのボードを対話的に作成したり、変更したりできるエディターを作れ。</li>
</ol><

[http://haskell.g.hatena.ne.jp/matarillo/20120125/1327499245:title=9.7で写経したライフゲーム]を修正して、ボードサイズを可変にできるようにしてやったぜ。

>|haskell|
module NineNineFour where

import System.IO
import NineFive

getCh :: IO Char
getCh =  do hSetEcho stdin False
            c <- getChar
            hSetEcho stdin True
            return c

-- variable size

type Board = [Pos]
type Size  = Pos

showcells   :: Board -> IO ()
showcells b =  seqn [writeat p ""O"" | p <- b]

isAlive     :: Board -> Pos -> Bool
isAlive b p =  elem p b

isEmpty     :: Board -> Pos -> Bool
isEmpty b p =  not (isAlive b p)

neighbs         :: Size -> Pos -> [Pos]
neighbs s (x,y) =  map (wrap s)
                     [(x-1,y-1), (x,y-1), (x+1,y-1),
                      (x-1,y),            (x+1,y),
                      (x-1,y+1), (x,y+1), (x+1,y+1)]

wrap             :: Size -> Pos -> Pos
wrap (w,h) (x,y) =  (((x-1) `mod` w) + 1, ((y-1) `mod` h) + 1)

liveneighbs      :: Size -> Board -> Pos -> Int
liveneighbs s b  =  length . filter (isAlive b) . neighbs s

survivors     :: Size -> Board -> [Pos]
survivors s b =  [p | p <- b, elem (liveneighbs s b p) [2,3]]

births     :: Size -> Board -> [Pos]
births s b =  [p | p <- rmdups (concat (map (neighbs s) b)),
                   isEmpty b p,
                   liveneighbs s b p == 3]

rmdups        :: Eq a => [a] -> [a]
rmdups []     =  []
rmdups (x:xs) =  x:rmdups (filter ((/=) x) xs)

nextgen     :: Size -> Board -> Board
nextgen s b =  survivors s b ++ births s b

life     :: Size -> Board -> IO ()
life s b =  do
  cls
  showcells b
  wait 5000
  life s (nextgen s b)

wait   :: Int -> IO ()
wait n =  seqn [return () | _ <- [1..n]]

-- board maker

runlife     :: Int -> Int -> IO ()
runlife w h =  makeboard (w,h) [] (1,1)

makeboard       :: Size -> Board -> Pos -> IO ()
makeboard s b p =  do
  cls
  showcells b
  goto p
  c <- getCh
  process s b p c

move                   :: Size -> Pos -> Pos -> Pos
move s (dx,dy) (px,py) =  wrap s (px+dx,py+dy)

up    = ( 0, -1)
down  = ( 0,  1)
right = ( 1,  0)
left  = (-1,  0)

process      :: Size -> Board -> Pos -> Char -> IO ()
process s b p c
  | elem c ""\n"" = life s b
  | elem c "" ""  = makeboard s (flippos p b) p
  | elem c ""c""  = makeboard s [] p
  | elem c ""k""  = makeboard s b (move s up p)
  | elem c ""j""  = makeboard s b (move s down p)
  | elem c ""h""  = makeboard s b (move s left p)
  | elem c ""l""  = makeboard s b (move s right p)
  | otherwise   = makeboard s b p

flippos     :: Pos -> Board -> Board
flippos p b =  if elem p b
               then [q | q <- b, q /= p]
               else p : b

||<
"
2012-02-07,,"*1328616322*[Haskell][F#]Re: Haskell vs F#

[http://d.hatena.ne.jp/rst76/20120204/1328362118:title]

F#の環境を作るのが面倒という声も上がっているけど、
[http://ideone.com/DTAC2:title=オンラインでやりゃいいじゃない。パンがなければお菓子を食べればいいじゃない。]

というか、Linux/Mac/Solarisな人ならmonoを入れれ。

[http://www.go-mono.com/mono-downloads/download.html:title]
[http://functional-variations.net/crossplatform/:title]
",,"*1328616322*[Haskell][F#]Re: Haskell vs F#

[http://d.hatena.ne.jp/rst76/20120204/1328362118:title]

F#の環境を作るのが面倒という声も上がっているけど、
[http://ideone.com/DTAC2:title=オンラインでやりゃいいじゃない。パンがなければお菓子を食べればいいじゃない。]

というか、Linux/Mac/Solarisな人ならmonoを入れれ。

[http://www.go-mono.com/mono-downloads/download.html:title]
[http://functional-variations.net/crossplatform/:title]
"
2012-02-02,,"*1328173982*第9章 対話プログラム #7

**9.9 練習問題

><ol>
<li value=""3"">ライフゲームは、世代ごとに画面全体をクリアするので、動かす環境によっては、動きがちらつくかもしれない。それを防止するために、状態が変わったところだけ表示し直すようライフゲームを変更せよ。</li>
</ol><

うーん。リモートターミナルとかだとちらつくかもしれないかな。

>|diff|
@@ -1,5 +1,6 @@
-module NineSeven where
+module NineNineThree where
 
+import List
 import NineFive
 
 width :: Int
@@ -13,9 +14,12 @@
 glider :: Board
 glider =  [(4,2), (2,3), (4,3), (3,4), (4,4)]
 
-showcells   :: Board -> IO ()
-showcells b =  seqn [writeat p ""O"" | p <- b]
+clearcells    :: [Pos] -> IO ()
+clearcells xs =  seqn [writeat p "" "" | p <- xs]
 
+writecells    :: [Pos] -> IO ()
+writecells xs =  seqn [writeat p ""O"" | p <- xs]
+
 isAlive     :: Board -> Pos -> Bool
 isAlive b p =  elem p b
 
@@ -36,6 +40,9 @@
 survivors   :: Board -> [Pos]
 survivors b =  [p | p <- b, elem (liveneighbs b p) [2,3]]
 
+deaths   :: Board -> [Pos]
+deaths b =  [p | p <- b, not $ elem p (survivors b)]
+
 births   :: Board -> [Pos]
 births b =  [p | p <- rmdups (concat (map neighbs b)),
                  isEmpty b p,
@@ -50,9 +57,14 @@
 
 life   :: Board -> IO ()
 life b =  do cls
-             showcells b
-             wait 5000
-             life (nextgen b)
+             writecells b
+             wait 5000
+             life' b
 
+life'   :: Board -> IO ()
+life' b =  do writecells (births b)
+              clearcells (deaths b)
+              wait 5000
+              life' (nextgen b)
+
 wait   :: Int -> IO ()
 wait n =  seqn [return () | _ <- [1..n]]
||<

というわけで、<code>cls >>= showcells</code> のところを <code>writecells >>= clearcells</code> としてみた。
",,"*1328173982*第9章 対話プログラム #7

**9.9 練習問題

><ol>
<li value=""3"">ライフゲームは、世代ごとに画面全体をクリアするので、動かす環境によっては、動きがちらつくかもしれない。それを防止するために、状態が変わったところだけ表示し直すようライフゲームを変更せよ。</li>
</ol><

うーん。リモートターミナルとかだとちらつくかもしれないかな。

>|diff|
@@ -1,5 +1,6 @@
-module NineSeven where
+module NineNineThree where
 
+import List
 import NineFive
 
 width :: Int
@@ -13,9 +14,12 @@
 glider :: Board
 glider =  [(4,2), (2,3), (4,3), (3,4), (4,4)]
 
-showcells   :: Board -> IO ()
-showcells b =  seqn [writeat p ""O"" | p <- b]
+clearcells    :: [Pos] -> IO ()
+clearcells xs =  seqn [writeat p "" "" | p <- xs]
 
+writecells    :: [Pos] -> IO ()
+writecells xs =  seqn [writeat p ""O"" | p <- xs]
+
 isAlive     :: Board -> Pos -> Bool
 isAlive b p =  elem p b
 
@@ -36,6 +40,9 @@
 survivors   :: Board -> [Pos]
 survivors b =  [p | p <- b, elem (liveneighbs b p) [2,3]]
 
+deaths   :: Board -> [Pos]
+deaths b =  [p | p <- b, not $ elem p (survivors b)]
+
 births   :: Board -> [Pos]
 births b =  [p | p <- rmdups (concat (map neighbs b)),
                  isEmpty b p,
@@ -50,9 +57,14 @@
 
 life   :: Board -> IO ()
 life b =  do cls
-             showcells b
-             wait 5000
-             life (nextgen b)
+             writecells b
+             wait 5000
+             life' b
 
+life'   :: Board -> IO ()
+life' b =  do writecells (births b)
+              clearcells (deaths b)
+              wait 5000
+              life' (nextgen b)
+
 wait   :: Int -> IO ()
 wait n =  seqn [return () | _ <- [1..n]]
||<

というわけで、<code>cls >>= showcells</code> のところを <code>writecells >>= clearcells</code> としてみた。
"
2012-02-01,,"*1328097860*第9章 対話プログラム #6

**9.9 練習問題

><ol>
<li value=""2"">エラーの際に単にビープ音を鳴らすのではなく、エラーの位置が分かるように電卓を変更せよ。パーサーは消費しなかった文字列を返すという性質を活用するとよい。</li>
</ol><

「エラーの位置がわかるように」というのが何を求めているのかよくわからないが、「消費した（解読できた）位置まで戻る」という仕様にすることにした。

>|diff|
@@ -1,4 +1,4 @@
-module NineSix where
+module NineNineTwo where
 
 import Parsing
 import Expr
@@ -58,9 +58,9 @@
 
 eval    :: String -> IO ()
 eval xs =  case parse expr xs of
-             [(n,"""")] -> calc (show n)
-             _        -> do beep
-                            calc xs
+             [(n,"""")]  -> calc (show n)
+             [(_,out)] -> do beep
+                             calc (take (length xs - length out) xs)
 
 clear :: IO ()
 clear =  calc """"
||<

要するに<code>eval</code>のパターンマッチを書き換えて、消費しなかった文字を切り捨てて再表示している。

カッコが多いのがHaskellっぽくないのはわかっているけど、<code>take (length xs - length out) xs</code>が簡潔にならない限り、
>|haskell|
calc $ take (length xs - length out) xs
||<
にしたところでたいした違いはない。
",,"*1328097860*第9章 対話プログラム #6

**9.9 練習問題

><ol>
<li value=""2"">エラーの際に単にビープ音を鳴らすのではなく、エラーの位置が分かるように電卓を変更せよ。パーサーは消費しなかった文字列を返すという性質を活用するとよい。</li>
</ol><

「エラーの位置がわかるように」というのが何を求めているのかよくわからないが、「消費した（解読できた）位置まで戻る」という仕様にすることにした。

>|diff|
@@ -1,4 +1,4 @@
-module NineSix where
+module NineNineTwo where
 
 import Parsing
 import Expr
@@ -58,9 +58,9 @@
 
 eval    :: String -> IO ()
 eval xs =  case parse expr xs of
-             [(n,"""")] -> calc (show n)
-             _        -> do beep
-                            calc xs
+             [(n,"""")]  -> calc (show n)
+             [(_,out)] -> do beep
+                             calc (take (length xs - length out) xs)
 
 clear :: IO ()
 clear =  calc """"
||<

要するに<code>eval</code>のパターンマッチを書き換えて、消費しなかった文字を切り捨てて再表示している。

カッコが多いのがHaskellっぽくないのはわかっているけど、<code>take (length xs - length out) xs</code>が簡潔にならない限り、
>|haskell|
calc $ take (length xs - length out) xs
||<
にしたところでたいした違いはない。
"
2012-01-30,,"*1327900867*第9章 対話プログラム #5

では実際に解いてみよう。

**9.9 練習問題

><ol>
<li>アクション <code>getLine</code> に、削除キーで文字を消去できる機能を加えたアクション <code>readLine :: IO String</code> を定義せよ。<br />ヒント：一文字削除するための制御文字は <code>""\DEL""</code>、一文字戻るための制御文字列は <code>""\ESC[1D""</code> である。</li>
</ol><

結局、terminalのバッファリングモードの関係で、VirtualBoxでLinuxを動かした。
[http://haskell.g.hatena.ne.jp/matarillo/20120124/1327375513:title=最近のHugsにはgetChがないとのことでいろいろ面倒]だったからGHCiを使うことにした。
>|haskell|
module NineNineOne where

import System.IO

getCh :: IO Char
getCh =  do hSetEcho stdin False
            c <- getChar
            hSetEcho stdin True
            return c

readLine :: IO String
readLine =  f """"
            where
              f xs =  do c <- getCh
                         handle xs c
              handle xs '\n'   = do putChar '\n'
                                    return xs
              handle [] '\DEL' = f """"
              handle xs '\DEL' = do putStr ""\ESC[1D \ESC[1D""
                                    f (init xs)
              handle xs c      = do putChar c
                                    f (xs ++ [c])
||<

書いた後で考えると、<code>init xs</code>とか<code>xs ++ [c]</code>が気持ち悪いな。逆順のリストにしておいて、Enterが押されたときに<code>return reverse xs</code>のほうがよかった気もする。
",,"*1327900867*第9章 対話プログラム #5

では実際に解いてみよう。

**9.9 練習問題

><ol>
<li>アクション <code>getLine</code> に、削除キーで文字を消去できる機能を加えたアクション <code>readLine :: IO String</code> を定義せよ。<br />ヒント：一文字削除するための制御文字は <code>""\DEL""</code>、一文字戻るための制御文字列は <code>""\ESC[1D""</code> である。</li>
</ol><

結局、terminalのバッファリングモードの関係で、VirtualBoxでLinuxを動かした。
[http://haskell.g.hatena.ne.jp/matarillo/20120124/1327375513:title=最近のHugsにはgetChがないとのことでいろいろ面倒]だったからGHCiを使うことにした。
>|haskell|
module NineNineOne where

import System.IO

getCh :: IO Char
getCh =  do hSetEcho stdin False
            c <- getChar
            hSetEcho stdin True
            return c

readLine :: IO String
readLine =  f """"
            where
              f xs =  do c <- getCh
                         handle xs c
              handle xs '\n'   = do putChar '\n'
                                    return xs
              handle [] '\DEL' = f """"
              handle xs '\DEL' = do putStr ""\ESC[1D \ESC[1D""
                                    f (init xs)
              handle xs c      = do putChar c
                                    f (xs ++ [c])
||<

書いた後で考えると、<code>init xs</code>とか<code>xs ++ [c]</code>が気持ち悪いな。逆順のリストにしておいて、Enterが押されたときに<code>return reverse xs</code>のほうがよかった気もする。
"
2012-01-26,,"*1327536351*第9章 対話プログラム #4

**9.9 練習問題

今日は時間がないので、問題文を写すだけにしておく。

><ol>
<li>アクション <code>getLine</code> に、削除キーで文字を消去できる機能を加えたアクション <code>readLine :: IO String</code> を定義せよ。<br />ヒント：一文字削除するための制御文字は <code>""\DEL""</code>、一文字戻るための制御文字列は <code>""\ESC[1D""</code> である。</li>
<li>エラーの際に単にビープ音を鳴らすのではなく、エラーの位置が分かるように電卓を変更せよ。パーサーは消費しなかった文字列を返すという性質を活用するとよい。</li>
<li>ライフゲームは、世代ごとに画面全体をクリアするので、動かす環境によっては、動きがちらつくかもしれない。それを防止するために、状態が変わったところだけ表示し直すようライフゲームを変更せよ。</li>
<li>ライフゲームのボードを対話的に作成したり、変更したりできるエディターを作れ。</li>
<li>[http://www.haskell.org:title=www.haskell.org]から入手できるグラフィック・ライブラリを用いて、電卓とライフゲームのグラフィック版を作成せよ。</li>
<li>ニムはボードを使うゲームである。ボードには、番号の付いた行が五つあり、はじめは星が以下のように並べてある。
<pre>
1:*****
2:****
3:***
4:**
5:*
</pre>
二人のプレイヤーは、交互に行を一つ選び、その最後から一つ以上の星を取る。ボードから最後の星を取った方が勝ちである。ニムをHaskellで実装せよ。<br />ヒント：それぞれの残っている星の数のリストでボードを定義せよ。ボードの初期値は <code>[5,4,3,2,1]</code> となる。</li>
</ol><

*1327572788*ターミナル

さて、<code>getCh</code>の前から怪しいと思ってたのだけど、<code>getChar</code>がEnterを押すまでキーを認識しない。
いろいろ調べると、バッファリングモードの問題らしく
>|haskell|
import IO
do hSetBuffering stdio NoBuffering
||<
とかなんとかそういうのをやれと書いてある。が、やっても効かない。
mintty/msys の問題なのかなあ。sttyの問題なのか？よくわからん。
cmd.exeじゃエスケープシーケンスが効かないからってminttyを導入したのに、結局、Windowsでやるなってことなのか･･････
",,"*1327536351*第9章 対話プログラム #4

**9.9 練習問題

今日は時間がないので、問題文を写すだけにしておく。

><ol>
<li>アクション <code>getLine</code> に、削除キーで文字を消去できる機能を加えたアクション <code>readLine :: IO String</code> を定義せよ。<br />ヒント：一文字削除するための制御文字は <code>""\DEL""</code>、一文字戻るための制御文字列は <code>""\ESC[1D""</code> である。</li>
<li>エラーの際に単にビープ音を鳴らすのではなく、エラーの位置が分かるように電卓を変更せよ。パーサーは消費しなかった文字列を返すという性質を活用するとよい。</li>
<li>ライフゲームは、世代ごとに画面全体をクリアするので、動かす環境によっては、動きがちらつくかもしれない。それを防止するために、状態が変わったところだけ表示し直すようライフゲームを変更せよ。</li>
<li>ライフゲームのボードを対話的に作成したり、変更したりできるエディターを作れ。</li>
<li>[http://www.haskell.org:title=www.haskell.org]から入手できるグラフィック・ライブラリを用いて、電卓とライフゲームのグラフィック版を作成せよ。</li>
<li>ニムはボードを使うゲームである。ボードには、番号の付いた行が五つあり、はじめは星が以下のように並べてある。
<pre>
1:*****
2:****
3:***
4:**
5:*
</pre>
二人のプレイヤーは、交互に行を一つ選び、その最後から一つ以上の星を取る。ボードから最後の星を取った方が勝ちである。ニムをHaskellで実装せよ。<br />ヒント：それぞれの残っている星の数のリストでボードを定義せよ。ボードの初期値は <code>[5,4,3,2,1]</code> となる。</li>
</ol><

*1327572788*ターミナル

さて、<code>getCh</code>の前から怪しいと思ってたのだけど、<code>getChar</code>がEnterを押すまでキーを認識しない。
いろいろ調べると、バッファリングモードの問題らしく
>|haskell|
import IO
do hSetBuffering stdio NoBuffering
||<
とかなんとかそういうのをやれと書いてある。が、やっても効かない。
mintty/msys の問題なのかなあ。sttyの問題なのか？よくわからん。
cmd.exeじゃエスケープシーケンスが効かないからってminttyを導入したのに、結局、Windowsでやるなってことなのか･･････
"
2012-01-25,,"*1327499245* 第9章 対話プログラム #3

**ライフゲーム

さて、9.7はライフゲームの実装。
ひたすら写経。[http://haskell.g.hatena.ne.jp/matarillo/20110908/1315442247:title=9.5で実装した]関数群を使っている。

>|haskell|
module NineSeven where

import NineFive

width :: Int
width =  5

height :: Int
height =  5

type Board = [Pos]

glider :: Board
glider =  [(4,2), (2,3), (4,3), (3,4), (4,4)]

showcells   :: Board -> IO ()
showcells b =  seqn [writeat p ""O"" | p <- b]

isAlive     :: Board -> Pos -> Bool
isAlive b p =  elem p b

isEmpty     :: Board -> Pos -> Bool
isEmpty b p =  not (isAlive b p)

neighbs       :: Pos -> [Pos]
neighbs (x,y) = map wrap [(x-1,y-1), (x,y-1), (x+1,y-1),
                          (x-1,y),            (x+1,y),
                          (x-1,y+1), (x,y+1), (x+1,y+1)]

wrap       :: Pos -> Pos
wrap (x,y) =  (((x-1) `mod` width) + 1, ((y-1) `mod` height) + 1)

liveneighbs   :: Board -> Pos -> Int
liveneighbs b =  length . filter (isAlive b) . neighbs

survivors   :: Board -> [Pos]
survivors b =  [p | p <- b, elem (liveneighbs b p) [2,3]]

births   :: Board -> [Pos]
births b =  [p | p <- rmdups (concat (map neighbs b)),
                 isEmpty b p,
                 liveneighbs b p == 3]

rmdups        :: Eq a => [a] -> [a]
rmdups []     =  []
rmdups (x:xs) =  x:rmdups (filter ((/=) x) xs)

nextgen   :: Board -> Board
nextgen b =  survivors b ++ births b

life   :: Board -> IO ()
life b =  do cls
             showcells b
             wait 5000
             life (nextgen b)

wait   :: Int -> IO ()
wait n =  seqn [return () | _ <- [1..n]]
||<

<code>life glider</code>って実行すると、たしかにグライダーが！
ただし無限ループするので、Ctrl-cで止めないといけないけど。

<code>wait</code>がビジーループなのがおもしろい。IOモナドにもだいぶん馴染んできたかな。

*1327500609*木探索とCPS
もともと、俺の[http://haskell.g.hatena.ne.jp/matarillo/20110430/1304151012:title=Haskell学習の目標]は、“[http://d.hatena.ne.jp/rst76/20100706/1278430517:title]を全部理解できるようになること”だったわけで、それは今でも変わっていない。
で、Haskellはだんだんわかって来たけど、“木探索から CPS にすることで効率化”が腑に落ちてなかった。
そんな時に[http://www.geocities.jp/m_hiroi/func/ocaml25.html:title]というページを見つけた。
おお、なるほどね。CPSで効率化を理解する取っ掛かりができたぞ。
","rst76w１ヶ月遅れのコメントすみません。リンク先にもある通り、“木探索から CPS にすることで効率化”というのは間違いです。同じ計算をするなら、CPSにしようがしまいが、コストは変わりません。<br>確率計算の例だと、CPSに変換する際に実は計算モデルも若干変わっていて、そのために効率化されています。逆にもともとの木探索でも、モデルの記述をちょっと変えるだけで効率化できます。木探索が悪いわけではなくて、モデルの記述の仕方が悪いのです。<br>そのあたりは僕も整理できてなくて、うやむやにしていたのですが、時間を見つけて考えたいと思います。（そういう意味ではオリジナルの論文も、誤りがあるのではないかと思っています）x
matarillow実は、木探索とモナドにもっと慣れたらあらためてまた考えようと思って、ほっといてあります。;-)x
","*1327499245* 第9章 対話プログラム #3

**ライフゲーム

さて、9.7はライフゲームの実装。
ひたすら写経。[http://haskell.g.hatena.ne.jp/matarillo/20110908/1315442247:title=9.5で実装した]関数群を使っている。

>|haskell|
module NineSeven where

import NineFive

width :: Int
width =  5

height :: Int
height =  5

type Board = [Pos]

glider :: Board
glider =  [(4,2), (2,3), (4,3), (3,4), (4,4)]

showcells   :: Board -> IO ()
showcells b =  seqn [writeat p ""O"" | p <- b]

isAlive     :: Board -> Pos -> Bool
isAlive b p =  elem p b

isEmpty     :: Board -> Pos -> Bool
isEmpty b p =  not (isAlive b p)

neighbs       :: Pos -> [Pos]
neighbs (x,y) = map wrap [(x-1,y-1), (x,y-1), (x+1,y-1),
                          (x-1,y),            (x+1,y),
                          (x-1,y+1), (x,y+1), (x+1,y+1)]

wrap       :: Pos -> Pos
wrap (x,y) =  (((x-1) `mod` width) + 1, ((y-1) `mod` height) + 1)

liveneighbs   :: Board -> Pos -> Int
liveneighbs b =  length . filter (isAlive b) . neighbs

survivors   :: Board -> [Pos]
survivors b =  [p | p <- b, elem (liveneighbs b p) [2,3]]

births   :: Board -> [Pos]
births b =  [p | p <- rmdups (concat (map neighbs b)),
                 isEmpty b p,
                 liveneighbs b p == 3]

rmdups        :: Eq a => [a] -> [a]
rmdups []     =  []
rmdups (x:xs) =  x:rmdups (filter ((/=) x) xs)

nextgen   :: Board -> Board
nextgen b =  survivors b ++ births b

life   :: Board -> IO ()
life b =  do cls
             showcells b
             wait 5000
             life (nextgen b)

wait   :: Int -> IO ()
wait n =  seqn [return () | _ <- [1..n]]
||<

<code>life glider</code>って実行すると、たしかにグライダーが！
ただし無限ループするので、Ctrl-cで止めないといけないけど。

<code>wait</code>がビジーループなのがおもしろい。IOモナドにもだいぶん馴染んできたかな。

*1327500609*木探索とCPS
もともと、俺の[http://haskell.g.hatena.ne.jp/matarillo/20110430/1304151012:title=Haskell学習の目標]は、“[http://d.hatena.ne.jp/rst76/20100706/1278430517:title]を全部理解できるようになること”だったわけで、それは今でも変わっていない。
で、Haskellはだんだんわかって来たけど、“木探索から CPS にすることで効率化”が腑に落ちてなかった。
そんな時に[http://www.geocities.jp/m_hiroi/func/ocaml25.html:title]というページを見つけた。
おお、なるほどね。CPSで効率化を理解する取っ掛かりができたぞ。
"
2012-01-24,,"*1327375513*getCh
9.6の計算機プログラムの中でgetChという関数が出てきていて、コンパイルに通らないのでgetCharに置き換えてたんだけど、

><blockquote cite=""http://www.cs.nott.ac.uk/~gmh/errata.html"" title=""Programming in Haskell -- Errata""><
Page 90. The action getCh is no longer provided as a primitive in Hugs, but can be defined in Haskell as follows:
>|haskell|
   import System.IO 

   getCh :: IO Char
   getCh  = do hSetEcho stdin False
               c <- getChar
               hSetEcho stdin True
               return c
||<
This definition works with the Glasgow Haskell Compiler, but may not work with some Haskell systems, such as Hugs.
></blockquote><

えー。
",,"*1327375513*getCh
9.6の計算機プログラムの中でgetChという関数が出てきていて、コンパイルに通らないのでgetCharに置き換えてたんだけど、

><blockquote cite=""http://www.cs.nott.ac.uk/~gmh/errata.html"" title=""Programming in Haskell -- Errata""><
Page 90. The action getCh is no longer provided as a primitive in Hugs, but can be defined in Haskell as follows:
>|haskell|
   import System.IO 

   getCh :: IO Char
   getCh  = do hSetEcho stdin False
               c <- getChar
               hSetEcho stdin True
               return c
||<
This definition works with the Glasgow Haskell Compiler, but may not work with some Haskell systems, such as Hugs.
></blockquote><

えー。
"
2012-01-22,,"*1327206712*Windowsでもいいや
MSYS上のminttyからhugsを起動すればいいということで、今後はそうする。

*1327210855*第9章 対話プログラム #2
というわけでminttyからhugsを起動する方法にしたら捗った。
あと、今までは全部1ファイルでやろうとしていたが、色々無理が出てきたのでモジュール化した。

>|haskell|
module NineSix where

import Parsing
import Expr
import NineFive

box :: [String]
box =  [""+---------------+"",
        ""|               |"",
        ""+---+---+---+---+"",
        ""| q | c | d | = |"",
        ""+---+---+---+---+"",
        ""| 1 | 2 | 3 | + |"",
        ""+---+---+---+---+"",
        ""| 4 | 5 | 6 | - |"",
        ""+---+---+---+---+"",
        ""| 7 | 8 | 9 | * |"",
        ""+---+---+---+---+"",
        ""| 0 | ( | ) | / |"",
        ""+---+---+---+---+""]

buttons :: [Char]
buttons =  standard ++ extra
           where
             standard = ""qcd=123+456-789*0()/""
             extra    = ""QCD \ESC\BS\DEL\n""

showbox :: IO ()
showbox =  seqn [writeat (1,y) xs | (y,xs) <- zip [1..13] box]

display    :: String -> IO ()
display xs =  do writeat (3,2) ""             ""
                 writeat (3,2) (reverse (take 13 (reverse xs)))

calc    :: String -> IO ()
calc xs =  do display xs
              c <- getChar
              if elem c buttons then
                process c xs
              else
                do beep
                   calc xs

process      :: Char -> String -> IO ()
process c xs
  | elem c ""qQ\ESC""    = quit
  | elem c ""dD\BS\DEL"" = delete xs
  | elem c ""=\n""       = eval xs
  | elem c ""cC""        = clear
  | otherwise          = press c xs

quit :: IO ()
quit =  goto (1,14)

delete    :: String -> IO ()
delete """" =  calc """"
delete xs =  calc (init xs)

eval    :: String -> IO ()
eval xs =  case parse expr xs of
             [(n,"""")] -> calc (show n)
             _        -> do beep
                            calc xs

clear :: IO ()
clear =  calc """"

press      :: Char -> String -> IO ()
press c xs =  calc (xs ++ [c])

run :: IO ()
run =  do cls
          showbox
          clear
||<

プログラムを眺めるとわかるが、calc関数がメインループになっている。
もちろん、ループじゃなくて再帰だから、メイン再帰というべきなのか？
",,"*1327206712*Windowsでもいいや
MSYS上のminttyからhugsを起動すればいいということで、今後はそうする。

*1327210855*第9章 対話プログラム #2
というわけでminttyからhugsを起動する方法にしたら捗った。
あと、今までは全部1ファイルでやろうとしていたが、色々無理が出てきたのでモジュール化した。

>|haskell|
module NineSix where

import Parsing
import Expr
import NineFive

box :: [String]
box =  [""+---------------+"",
        ""|               |"",
        ""+---+---+---+---+"",
        ""| q | c | d | = |"",
        ""+---+---+---+---+"",
        ""| 1 | 2 | 3 | + |"",
        ""+---+---+---+---+"",
        ""| 4 | 5 | 6 | - |"",
        ""+---+---+---+---+"",
        ""| 7 | 8 | 9 | * |"",
        ""+---+---+---+---+"",
        ""| 0 | ( | ) | / |"",
        ""+---+---+---+---+""]

buttons :: [Char]
buttons =  standard ++ extra
           where
             standard = ""qcd=123+456-789*0()/""
             extra    = ""QCD \ESC\BS\DEL\n""

showbox :: IO ()
showbox =  seqn [writeat (1,y) xs | (y,xs) <- zip [1..13] box]

display    :: String -> IO ()
display xs =  do writeat (3,2) ""             ""
                 writeat (3,2) (reverse (take 13 (reverse xs)))

calc    :: String -> IO ()
calc xs =  do display xs
              c <- getChar
              if elem c buttons then
                process c xs
              else
                do beep
                   calc xs

process      :: Char -> String -> IO ()
process c xs
  | elem c ""qQ\ESC""    = quit
  | elem c ""dD\BS\DEL"" = delete xs
  | elem c ""=\n""       = eval xs
  | elem c ""cC""        = clear
  | otherwise          = press c xs

quit :: IO ()
quit =  goto (1,14)

delete    :: String -> IO ()
delete """" =  calc """"
delete xs =  calc (init xs)

eval    :: String -> IO ()
eval xs =  case parse expr xs of
             [(n,"""")] -> calc (show n)
             _        -> do beep
                            calc xs

clear :: IO ()
clear =  calc """"

press      :: Char -> String -> IO ()
press c xs =  calc (xs ++ [c])

run :: IO ()
run =  do cls
          showbox
          clear
||<

プログラムを眺めるとわかるが、calc関数がメインループになっている。
もちろん、ループじゃなくて再帰だから、メイン再帰というべきなのか？
"
2012-01-20,,"*1327021631*[F#]F#のつまみぐい

Haskellにくわしい後輩から「F#教えてください」と言われたが、俺もわからんのよ。F#のコードを書いたことがないので。

でもそれじゃつまらないので、Haskellの勉強で学んだ知識をもとにF#に挑戦してみた。

いろいろ試行錯誤した結果がこれだ。One, Two Three→[http://qiita.com/items/1798:title=F#で素数の無限シーケンスを作る]
",,"*1327021631*[F#]F#のつまみぐい

Haskellにくわしい後輩から「F#教えてください」と言われたが、俺もわからんのよ。F#のコードを書いたことがないので。

でもそれじゃつまらないので、Haskellの勉強で学んだ知識をもとにF#に挑戦してみた。

いろいろ試行錯誤した結果がこれだ。One, Two Three→[http://qiita.com/items/1798:title=F#で素数の無限シーケンスを作る]
"
2011-11-17,,"*1321541889* WinHugsはやめる

そういえばうちにはMac Miniがあったんだった。ずっとWindowsばかり起動していたから忘れていた。

てなわけでMacPortsをインストールした後Hugsをインストール。Windowsからはteraterm経由でアクセス。

おお、快適。エスケープシーケンスも動くし。",,"*1321541889* WinHugsはやめる

そういえばうちにはMac Miniがあったんだった。ずっとWindowsばかり起動していたから忘れていた。

てなわけでMacPortsをインストールした後Hugsをインストール。Windowsからはteraterm経由でアクセス。

おお、快適。エスケープシーケンスも動くし。"
2011-10-29,,"*1319870663*生きてます
IOモナドで計算機はいいんだけどさあ。Windowsではちょっとねえ。前回書いたように、エスケープシーケンスは動かないし、グラフィクスライブラリ(HGLとかSOEとか)は動かないし。やる気が……
VirtualBoxかなにかでUbuntuとか動かして、そこでHaskellをやるか……そのほうがいいか……",,"*1319870663*生きてます
IOモナドで計算機はいいんだけどさあ。Windowsではちょっとねえ。前回書いたように、エスケープシーケンスは動かないし、グラフィクスライブラリ(HGLとかSOEとか)は動かないし。やる気が……
VirtualBoxかなにかでUbuntuとか動かして、そこでHaskellをやるか……そのほうがいいか……"
2011-09-08,,"*1315442247* 第9章 対話プログラム #1

仕事が忙しくて書けてなかったけど、忘れたわけではない。

**入出力の型
<code>IO a</code>の簡易説明、っていうかこの<code>World</code>を使った説明はごまかしだよなあ。
写経したコードを試しに実行する時に困るんだよねえ。

カリー化によって（最近、ScalaやGroovy界隈で話題だったね）、引数をとるIO型を定義しなくても、<code>a -> IO b</code>で充分というのは納得。

**基本アクション
<code>getChar</code>と<code>putChar</code>を例にとった<code>return</code>の説明。
第8章でも<code>return</code>は出てきたけど、そこではオレオレreturnだったし、副作用の話はしていなかった。

モナドについては教科書以外で自習しておいたから、この節は適当に読み飛ばす。

**順序付け
演算子<code> >>= </code>と<code>do</code>記法の説明。
第8章でも出てきたけど、そこではオレオレbindだったので実際にはdo記法でプログラムを書くことはできなかった。

この節も適当に読み飛ばしつつ、やっとdo記法が使えるので、あらためて書き方をおさらいしておく。

**アクションの部品

さて、写経の時間。
今回は<code>getLine</code>、<code>putStr</code>、<code>putStrLn</code>を最初に定義しているけど、この3つの関数は標準ライブラリに入っているからそれを使うことにする。

>|haskell|
strlen :: IO ()
strlen = do putStr ""Enter a string: ""
            xs <- getLine
            putStr ""The string has ""
            putStr (show (length xs))
            putStrLn "" characters""
||<

さて、次が問題で。

>|haskell|
beep :: IO ()
beep = putStr ""\BEL""

cls :: IO ()
cls = putStr ""\ESC[2J""

type Pos = (Int, Int)

goto :: Pos -> IO ()
goto (x, y) = putStr (""\ESC["" ++ show y ++ "";"" ++ show x ++ ""H"")

writeat :: Pos -> String -> IO ()
writeat p xs = do goto p
                  putStr xs

seqn :: [IO a] -> IO ()
seqn [] = return ()
seqn (a: as) = do a
                  seqn as
||<

これを試すんだけど、WinHugsではエスケープシーケンスが効かない。というか、コマンドプロンプトで実行するhugs.exeでも効かない。

最近のWindowsでエスケープシーケンスを効かせたいときは、Cygwinを使うか、telnet経由で実行するという方法が考えられる。

とりあえず前者は嫌いなので却下して、後者をやってはみたが、面倒だな……。エスケープシーケンスが必須な練習問題でもない限りは無視しようと思う。

**電卓
<code>expr :: Parser Int</code>が存在していることが前提と書いてあるので、第8章の練習問題で書いた<code>expr</code>を持ってくる。減算演算子が右結合のやつだけど、別にいいよね。
ついでに、<code>do</code>記法で書きなおしておく。

>|haskell|
factor  :: Parser Int
factor  =  do symbol ""(""
              e <- expr
              symbol "")""
              return e
            +++ natural

term    :: Parser Int
term    =  do f <- factor
              (do symbol ""*""
                  t <- term
                  return (f * t)
                +++
               do symbol ""/""
                  t <- term
                  return (f `div` t)
                +++
               return f)

expr    :: Parser Int
expr    =  do t <- term
              (do symbol ""+""
                  e <- expr
                  return (t + e)
                +++
               do symbol ""-""
                  e <- expr
                  return (t - e)
                +++
               return t)
||<
",,"*1315442247* 第9章 対話プログラム #1

仕事が忙しくて書けてなかったけど、忘れたわけではない。

**入出力の型
<code>IO a</code>の簡易説明、っていうかこの<code>World</code>を使った説明はごまかしだよなあ。
写経したコードを試しに実行する時に困るんだよねえ。

カリー化によって（最近、ScalaやGroovy界隈で話題だったね）、引数をとるIO型を定義しなくても、<code>a -> IO b</code>で充分というのは納得。

**基本アクション
<code>getChar</code>と<code>putChar</code>を例にとった<code>return</code>の説明。
第8章でも<code>return</code>は出てきたけど、そこではオレオレreturnだったし、副作用の話はしていなかった。

モナドについては教科書以外で自習しておいたから、この節は適当に読み飛ばす。

**順序付け
演算子<code> >>= </code>と<code>do</code>記法の説明。
第8章でも出てきたけど、そこではオレオレbindだったので実際にはdo記法でプログラムを書くことはできなかった。

この節も適当に読み飛ばしつつ、やっとdo記法が使えるので、あらためて書き方をおさらいしておく。

**アクションの部品

さて、写経の時間。
今回は<code>getLine</code>、<code>putStr</code>、<code>putStrLn</code>を最初に定義しているけど、この3つの関数は標準ライブラリに入っているからそれを使うことにする。

>|haskell|
strlen :: IO ()
strlen = do putStr ""Enter a string: ""
            xs <- getLine
            putStr ""The string has ""
            putStr (show (length xs))
            putStrLn "" characters""
||<

さて、次が問題で。

>|haskell|
beep :: IO ()
beep = putStr ""\BEL""

cls :: IO ()
cls = putStr ""\ESC[2J""

type Pos = (Int, Int)

goto :: Pos -> IO ()
goto (x, y) = putStr (""\ESC["" ++ show y ++ "";"" ++ show x ++ ""H"")

writeat :: Pos -> String -> IO ()
writeat p xs = do goto p
                  putStr xs

seqn :: [IO a] -> IO ()
seqn [] = return ()
seqn (a: as) = do a
                  seqn as
||<

これを試すんだけど、WinHugsではエスケープシーケンスが効かない。というか、コマンドプロンプトで実行するhugs.exeでも効かない。

最近のWindowsでエスケープシーケンスを効かせたいときは、Cygwinを使うか、telnet経由で実行するという方法が考えられる。

とりあえず前者は嫌いなので却下して、後者をやってはみたが、面倒だな……。エスケープシーケンスが必須な練習問題でもない限りは無視しようと思う。

**電卓
<code>expr :: Parser Int</code>が存在していることが前提と書いてあるので、第8章の練習問題で書いた<code>expr</code>を持ってくる。減算演算子が右結合のやつだけど、別にいいよね。
ついでに、<code>do</code>記法で書きなおしておく。

>|haskell|
factor  :: Parser Int
factor  =  do symbol ""(""
              e <- expr
              symbol "")""
              return e
            +++ natural

term    :: Parser Int
term    =  do f <- factor
              (do symbol ""*""
                  t <- term
                  return (f * t)
                +++
               do symbol ""/""
                  t <- term
                  return (f `div` t)
                +++
               return f)

expr    :: Parser Int
expr    =  do t <- term
              (do symbol ""+""
                  e <- expr
                  return (t + e)
                +++
               do symbol ""-""
                  e <- expr
                  return (t - e)
                +++
               return t)
||<
"
2011-06-20,,"*1308581970*本物のモナドで第8章
教科書の第9章をパラパラと読んだら、第9章はIOモナド。しかも第8章のパーサーを使用するようだ。
てことは、第8章のパーサーを本物のモナドで定義しておかないと、サンプルコードを実行できないと思われる。
仕方なく、教科書のサイトから第8章のパーサーをダウンロード。
>|haskell|
Functional parsing library from chapter 8 of Programming in Haskell,
Graham Hutton, Cambridge University Press, 2007.


> module Parsing where
>
> import Char
> import Monad
>
> infixr 5 +++

The monad of parsers
--------------------

> newtype Parser a              =  P (String -> [(a,String)])
>
> instance Monad Parser where
>    return v                   =  P (\inp -> [(v,inp)])
>    p >>= f                    =  P (\inp -> case parse p inp of
>                                                []        -> []
>                                                [(v,out)] -> parse (f v) out)
> 
> instance MonadPlus Parser where
>    mzero                      =  P (\inp -> [])
>    p `mplus` q                =  P (\inp -> case parse p inp of
>                                                []        -> parse q inp
>                                                [(v,out)] -> [(v,out)])

Basic parsers
-------------

> failure                       :: Parser a
> failure                       =  mzero
>
> item                          :: Parser Char
> item                          =  P (\inp -> case inp of
>                                                []     -> []
>                                                (x:xs) -> [(x,xs)])
> 
> parse                         :: Parser a -> String -> [(a,String)]
> parse (P p) inp               =  p inp

Choice
------

> (+++)                         :: Parser a -> Parser a -> Parser a
> p +++ q                       =  p `mplus` q

Derived primitives
------------------

> sat                           :: (Char -> Bool) -> Parser Char
> sat p                         =  do x <- item
>                                     if p x then return x else failure
> 
> digit                         :: Parser Char
> digit                         =  sat isDigit
> 
> lower                         :: Parser Char
> lower                         =  sat isLower
> 
> upper                         :: Parser Char
> upper                         =  sat isUpper
> 
> letter                        :: Parser Char
> letter                        =  sat isAlpha
> 
> alphanum                      :: Parser Char
> alphanum                      =  sat isAlphaNum
> 
> char                          :: Char -> Parser Char
> char x                        =  sat (== x)
> 
> string                        :: String -> Parser String
> string []                     =  return []
> string (x:xs)                 =  do char x
>                                     string xs
>                                     return (x:xs)
> 
> many                          :: Parser a -> Parser [a]
> many p                        =  many1 p +++ return []
> 
> many1                         :: Parser a -> Parser [a]
> many1 p                       =  do v  <- p
>                                     vs <- many p
>                                     return (v:vs)
> 
> ident                         :: Parser String
> ident                         =  do x  <- lower
>                                     xs <- many alphanum
>                                     return (x:xs)
> 
> nat                           :: Parser Int
> nat                           =  do xs <- many1 digit
>                                     return (read xs)
>
> int                           :: Parser Int
> int                           =  do char '-'
>                                     n <- nat
>                                     return (-n)
>                                   +++ nat
> 
> space                         :: Parser ()
> space                         =  do many (sat isSpace)
>                                     return ()

Ignoring spacing
----------------

> token                         :: Parser a -> Parser a
> token p                       =  do space
>                                     v <- p
>                                     space
>                                     return v
> 
> identifier                    :: Parser String
> identifier                    =  token ident
> 
> natural                       :: Parser Int
> natural                       =  token nat
> 
> integer                       :: Parser Int
> integer                       =  token int
>
> symbol                        :: String -> Parser String
> symbol xs                     =  token (string xs)
||<

まだ知らないキーワードは、<code>infixr</code>と<code>newtype</code>と<code>instance</code>。ぐぐったら、<code>infixr</code>は演算子の優先順位と結合規則(右結合)を決めるもの。<code>newtype</code>は新しい型を定義するためのもの。<code>instance</code>は、きっと型クラスと型インスタンスの関係を定義するものだろう。
まだ知らない型は、<code>Monad</code>と<code>MonadPlus</code>。こっちはうすうす分かる。<code>instance</code>キーワードの後ろに来ているところから見れば、型クラスだ。",,"*1308581970*本物のモナドで第8章
教科書の第9章をパラパラと読んだら、第9章はIOモナド。しかも第8章のパーサーを使用するようだ。
てことは、第8章のパーサーを本物のモナドで定義しておかないと、サンプルコードを実行できないと思われる。
仕方なく、教科書のサイトから第8章のパーサーをダウンロード。
>|haskell|
Functional parsing library from chapter 8 of Programming in Haskell,
Graham Hutton, Cambridge University Press, 2007.


> module Parsing where
>
> import Char
> import Monad
>
> infixr 5 +++

The monad of parsers
--------------------

> newtype Parser a              =  P (String -> [(a,String)])
>
> instance Monad Parser where
>    return v                   =  P (\inp -> [(v,inp)])
>    p >>= f                    =  P (\inp -> case parse p inp of
>                                                []        -> []
>                                                [(v,out)] -> parse (f v) out)
> 
> instance MonadPlus Parser where
>    mzero                      =  P (\inp -> [])
>    p `mplus` q                =  P (\inp -> case parse p inp of
>                                                []        -> parse q inp
>                                                [(v,out)] -> [(v,out)])

Basic parsers
-------------

> failure                       :: Parser a
> failure                       =  mzero
>
> item                          :: Parser Char
> item                          =  P (\inp -> case inp of
>                                                []     -> []
>                                                (x:xs) -> [(x,xs)])
> 
> parse                         :: Parser a -> String -> [(a,String)]
> parse (P p) inp               =  p inp

Choice
------

> (+++)                         :: Parser a -> Parser a -> Parser a
> p +++ q                       =  p `mplus` q

Derived primitives
------------------

> sat                           :: (Char -> Bool) -> Parser Char
> sat p                         =  do x <- item
>                                     if p x then return x else failure
> 
> digit                         :: Parser Char
> digit                         =  sat isDigit
> 
> lower                         :: Parser Char
> lower                         =  sat isLower
> 
> upper                         :: Parser Char
> upper                         =  sat isUpper
> 
> letter                        :: Parser Char
> letter                        =  sat isAlpha
> 
> alphanum                      :: Parser Char
> alphanum                      =  sat isAlphaNum
> 
> char                          :: Char -> Parser Char
> char x                        =  sat (== x)
> 
> string                        :: String -> Parser String
> string []                     =  return []
> string (x:xs)                 =  do char x
>                                     string xs
>                                     return (x:xs)
> 
> many                          :: Parser a -> Parser [a]
> many p                        =  many1 p +++ return []
> 
> many1                         :: Parser a -> Parser [a]
> many1 p                       =  do v  <- p
>                                     vs <- many p
>                                     return (v:vs)
> 
> ident                         :: Parser String
> ident                         =  do x  <- lower
>                                     xs <- many alphanum
>                                     return (x:xs)
> 
> nat                           :: Parser Int
> nat                           =  do xs <- many1 digit
>                                     return (read xs)
>
> int                           :: Parser Int
> int                           =  do char '-'
>                                     n <- nat
>                                     return (-n)
>                                   +++ nat
> 
> space                         :: Parser ()
> space                         =  do many (sat isSpace)
>                                     return ()

Ignoring spacing
----------------

> token                         :: Parser a -> Parser a
> token p                       =  do space
>                                     v <- p
>                                     space
>                                     return v
> 
> identifier                    :: Parser String
> identifier                    =  token ident
> 
> natural                       :: Parser Int
> natural                       =  token nat
> 
> integer                       :: Parser Int
> integer                       =  token int
>
> symbol                        :: String -> Parser String
> symbol xs                     =  token (string xs)
||<

まだ知らないキーワードは、<code>infixr</code>と<code>newtype</code>と<code>instance</code>。ぐぐったら、<code>infixr</code>は演算子の優先順位と結合規則(右結合)を決めるもの。<code>newtype</code>は新しい型を定義するためのもの。<code>instance</code>は、きっと型クラスと型インスタンスの関係を定義するものだろう。
まだ知らない型は、<code>Monad</code>と<code>MonadPlus</code>。こっちはうすうす分かる。<code>instance</code>キーワードの後ろに来ているところから見れば、型クラスだ。"
2011-06-18,,"*1308368255*第8章 関数型パーサー #7
**演習問題
***問題7
累乗を定義。
>|haskell|
term' :: Parser Int
term'  = pow >>- \p ->
         (symbol ""*"" >>- \d ->
          term' >>- \t ->
          return' (p * t))
         +++
         (symbol ""/"" >>- \d ->
          term' >>- \t ->
          return' (p `div` t))
         +++
         return' p

pow :: Parser Int
pow  = factor >>- \f ->
       (symbol ""^"" >>- \d ->
        pow >>- \p ->
        return' (f ^ p))
       +++
       return' f
||<

***問題8

a.
>||
expr ::= expr '-' nat | nat
nat  ::= '0' | '1' | '2' | ...
||<

b.
>|haskell|
expr'' :: Parser Int
expr''  = (expr'' >>- \e->
           symbol ""-"" >>- \d ->
           natural >>- \n ^>
           return' (e - n))
          +++ natural
||<

c.
左再帰なので無限ループになる。
(<code>expr ::= nat | expr '-' nat</code> にしてみたら、減算がパースされなかったので、これではだめ。)

d.
>|haskell|
expr'' :: Parser Int
expr''  = natural >>- \n ->
          many (symbol ""-"" >>- \d -> natural) >>- \ns ->
          return' (foldl (-) n ns)
||<
おー、綺麗に動いた。


まとまった時間が取れないのでちまちましか進まなかったが、やっと第8章が終わった！
※といっても、本物のモナドが教科書で登場したら、また戻ってきて復習するつもりだけど。",,"*1308368255*第8章 関数型パーサー #7
**演習問題
***問題7
累乗を定義。
>|haskell|
term' :: Parser Int
term'  = pow >>- \p ->
         (symbol ""*"" >>- \d ->
          term' >>- \t ->
          return' (p * t))
         +++
         (symbol ""/"" >>- \d ->
          term' >>- \t ->
          return' (p `div` t))
         +++
         return' p

pow :: Parser Int
pow  = factor >>- \f ->
       (symbol ""^"" >>- \d ->
        pow >>- \p ->
        return' (f ^ p))
       +++
       return' f
||<

***問題8

a.
>||
expr ::= expr '-' nat | nat
nat  ::= '0' | '1' | '2' | ...
||<

b.
>|haskell|
expr'' :: Parser Int
expr''  = (expr'' >>- \e->
           symbol ""-"" >>- \d ->
           natural >>- \n ^>
           return' (e - n))
          +++ natural
||<

c.
左再帰なので無限ループになる。
(<code>expr ::= nat | expr '-' nat</code> にしてみたら、減算がパースされなかったので、これではだめ。)

d.
>|haskell|
expr'' :: Parser Int
expr''  = natural >>- \n ->
          many (symbol ""-"" >>- \d -> natural) >>- \ns ->
          return' (foldl (-) n ns)
||<
おー、綺麗に動いた。


まとまった時間が取れないのでちまちましか進まなかったが、やっと第8章が終わった！
※といっても、本物のモナドが教科書で登場したら、また戻ってきて復習するつもりだけど。"
2011-06-16,,"*1308187848*第8章 関数型パーサー #6
**演習問題
***問題6
おれおれbindとreturnで。
>|haskell|
expr' :: Parser Int
expr'  = term' >>- \t ->
         (symbol ""+"" >>- \d ->
          expr' >>- \e ->
          return' (t + e))
         +++
         (symbol ""-"" >>- \d ->
          expr' >>- \e ->
          return' (t - e))
         +++
         return' t

term' :: Parser Int
term'  = factor >>- \f ->
         (symbol ""*"" >>- \d ->
          term' >>- \t ->
          return' (f * t))
         +++
         (symbol ""/"" >>- \d ->
          term' >>- \t ->
          return' (f `div` t))
         +++
         return' f
||<
",,"*1308187848*第8章 関数型パーサー #6
**演習問題
***問題6
おれおれbindとreturnで。
>|haskell|
expr' :: Parser Int
expr'  = term' >>- \t ->
         (symbol ""+"" >>- \d ->
          expr' >>- \e ->
          return' (t + e))
         +++
         (symbol ""-"" >>- \d ->
          expr' >>- \e ->
          return' (t - e))
         +++
         return' t

term' :: Parser Int
term'  = factor >>- \f ->
         (symbol ""*"" >>- \d ->
          term' >>- \t ->
          return' (f * t))
         +++
         (symbol ""/"" >>- \d ->
          term' >>- \t ->
          return' (f `div` t))
         +++
         return' f
||<
"
2011-06-14,,"*1308066287*第8章 関数型パーサー #5
**演習問題

***問題4
>||
        expr
         |
        term
   ______|________
   |     |       |
 factor  *      term
   |        _____|___
  nat       |    |  |
   |      factor * term
   2        |       |
           nat    factor
            |       |
            3      nat
                    |
                    4
||<
>||
                 expr
                  |
                 term
       ___________|_____
       |          |    |
     factor       *   term
_______|________       |
|      |       |     factor
(     expr     )       |
   ____|____          nat
   |   |   |           |
  term +  expr         4
   |       |
 factor   term
   |       |
  nat    factor
   |       |
   2      nat
           |
           3
||<

***問題5
左から一致を試すので、左再帰で無限ループになりそうだけど。そういうことではなく？
(追記)試してみたらstack overflowになった。やはり。",,"*1308066287*第8章 関数型パーサー #5
**演習問題

***問題4
>||
        expr
         |
        term
   ______|________
   |     |       |
 factor  *      term
   |        _____|___
  nat       |    |  |
   |      factor * term
   2        |       |
           nat    factor
            |       |
            3      nat
                    |
                    4
||<
>||
                 expr
                  |
                 term
       ___________|_____
       |          |    |
     factor       *   term
_______|________       |
|      |       |     factor
(     expr     )       |
   ____|____          nat
   |   |   |           |
  term +  expr         4
   |       |
 factor   term
   |       |
  nat    factor
   |       |
   2      nat
           |
           3
||<

***問題5
左から一致を試すので、左再帰で無限ループになりそうだけど。そういうことではなく？
(追記)試してみたらstack overflowになった。やはり。"
2011-06-12,,"*1307898655*第8章 関数型パーサー #4
旅行に行ったので間があいてしまった。

**数式

相変わらずdo記法を使わずにオレオレbindとオレオレreturnで書いてみる。

>|haskell|
expr :: Parser Int
expr  = term >>- \t ->
        (symbol ""+"" >>- \d ->
         expr >>- \e ->
         return' (t + e))
        +++ return' t

term :: Parser Int
term  = factor >>- \f ->
        (symbol ""*"" >>- \d ->
         term >>- \t ->
         return' (f * t))
        +++ return' f

factor :: Parser Int
factor  = (symbol ""("" >>- \d1 ->
           expr >>- \e ->
           symbol "")"" >>- \d2 ->
           return' e)
          +++ natural

eval :: String -> Int
eval xs = case parse expr xs of
            [(n,[])]  -> n
            [(_,out)] -> error (""unused input "" ++ out)
            []        -> error ""invalid input""
||<

**練習問題

***問題1

<code>symbol</code>にしたけど<code>char</code>でもよかったな。
>|haskell|
int :: Parser Int
int  = (symbol ""-"" >>- \d ->
        natural >>- \n ->
        return' (-n))
       +++ natural
||<

***問題2

1行読んで無視する<code>line</code>を定義してみた。
>|haskell|
comment :: Parser ()
comment  = string ""--"" >>- \d1 ->
           line
           where
             line = item >>- \x ->
                    case x of
                      '\n' -> return' ()
                      _    -> line
||<

***問題3
1個目
>||
           expr
     _______|___
     |      |  |
    expr    + expr
 ____|___      |
 |   |  |     term
expr + expr    |
 |      |     factor
term   term    |
 |      |     nat
factor factor  |
 |      |      4
nat    nat
 |      |
 2      3
||<

2個目
>||
    expr
 ____|_______
 |   |      |
expr +     expr
 |      ____|___
term    |   |  |
 |     expr + expr
factor  |      |
 |     term   term
nat     |      |
 |     factor factor
 2      |      |
       nat    nat
        |      |
        3      4
||<",,"*1307898655*第8章 関数型パーサー #4
旅行に行ったので間があいてしまった。

**数式

相変わらずdo記法を使わずにオレオレbindとオレオレreturnで書いてみる。

>|haskell|
expr :: Parser Int
expr  = term >>- \t ->
        (symbol ""+"" >>- \d ->
         expr >>- \e ->
         return' (t + e))
        +++ return' t

term :: Parser Int
term  = factor >>- \f ->
        (symbol ""*"" >>- \d ->
         term >>- \t ->
         return' (f * t))
        +++ return' f

factor :: Parser Int
factor  = (symbol ""("" >>- \d1 ->
           expr >>- \e ->
           symbol "")"" >>- \d2 ->
           return' e)
          +++ natural

eval :: String -> Int
eval xs = case parse expr xs of
            [(n,[])]  -> n
            [(_,out)] -> error (""unused input "" ++ out)
            []        -> error ""invalid input""
||<

**練習問題

***問題1

<code>symbol</code>にしたけど<code>char</code>でもよかったな。
>|haskell|
int :: Parser Int
int  = (symbol ""-"" >>- \d ->
        natural >>- \n ->
        return' (-n))
       +++ natural
||<

***問題2

1行読んで無視する<code>line</code>を定義してみた。
>|haskell|
comment :: Parser ()
comment  = string ""--"" >>- \d1 ->
           line
           where
             line = item >>- \x ->
                    case x of
                      '\n' -> return' ()
                      _    -> line
||<

***問題3
1個目
>||
           expr
     _______|___
     |      |  |
    expr    + expr
 ____|___      |
 |   |  |     term
expr + expr    |
 |      |     factor
term   term    |
 |      |     nat
factor factor  |
 |      |      4
nat    nat
 |      |
 2      3
||<

2個目
>||
    expr
 ____|_______
 |   |      |
expr +     expr
 |      ____|___
term    |   |  |
 |     expr + expr
factor  |      |
 |     term   term
nat     |      |
 |     factor factor
 2      |      |
       nat    nat
        |      |
        3      4
||<"
2011-05-20,,"*1305910871*第8章 関数型パーサー #3
間を空けると感覚が鈍ってだめだなあ。

**パーサーの部品

ひたすら写経。

>|haskell|
import Data.Char

sat :: (Char -> Bool) -> Parser Char
sat p = item >>- \x ->
        if p x then return' x else failure

digit   :: Parser Char
digit    = sat isDigit

lower   :: Parser Char
lower    = sat isLower

upper   :: Parser Char
upper    = sat isUpper

letter   :: Parser Char
letter    = sat isAlpha

alphanum :: Parser Char
alphanum  = sat isAlphaNum

char     :: Char -> Parser Char
char x    = sat (== x)

string :: String -> Parser String
string []     = return' []
string (x:xs) = char x >>- \d1 ->
                string xs >>- \d2 ->
                return' (x:xs)

many  :: Parser a -> Parser [a]
many p = many1 p +++ return' []

many1  :: Parser a -> Parser [a]
many1 p = p >>- \v ->
          many p >>- \vs ->
          return' (v:vs)

ident :: Parser String
ident  = lower >>- \x ->
         many alphanum >>- \xs ->
         return' (x:xs)

nat :: Parser Int
nat  = many1 digit >>- \xs ->
       return' (read xs)

space :: Parser ()
space  = many (sat isSpace) >>- \d ->
         return' ()
||<

パーサーはモナド（もどき）なのでbind（もどき）ができて、合成もできる。最後の3つ（識別子パーサー、自然数パーサー、空白パーサー）まで積み上がっていくのはなかなか凄いねえ。

**空白の扱い
さっきの部品を使って、前後の空白を無視する(単に消費する)パーサーを組み上げる。
>|haskell|
token  :: Parser a -> Parser a
token p = space >>- \d1 ->
          p >>- \v ->
          space >>- \d2 ->
          return' v

identifier :: Parser String
identifier  = token ident

natural :: Parser Int
natural  = token nat

symbol   :: String -> Parser String
symbol xs = token (string xs)
||<

ここまでできると、応用として空白を無視する整数リストのパーサーができる。

>|haskell|
p :: Parser [Int]
p = symbol ""["" >>- \d1 ->
    natural >>- \n ->
    many (symbol "","" >>- \d2 -> natural) >>- \ns ->
    symbol ""]"" >>- \d3 ->
    return' (n:ns)
||<

Hugsでの実行サンプルはこちら。
>|haskell|
Main> parse p "" [ 1 , 2 , 3   ] ""
[([1,2,3],"""")]
Main> parse p "" [ 1 , a , 3   ] ""
[]
||<


慣れてくるとパーサー定義が「読める」ようになってくる。ある種のDSL。関数型言語ならではなのか、Haskellならではなのか。
",,"*1305910871*第8章 関数型パーサー #3
間を空けると感覚が鈍ってだめだなあ。

**パーサーの部品

ひたすら写経。

>|haskell|
import Data.Char

sat :: (Char -> Bool) -> Parser Char
sat p = item >>- \x ->
        if p x then return' x else failure

digit   :: Parser Char
digit    = sat isDigit

lower   :: Parser Char
lower    = sat isLower

upper   :: Parser Char
upper    = sat isUpper

letter   :: Parser Char
letter    = sat isAlpha

alphanum :: Parser Char
alphanum  = sat isAlphaNum

char     :: Char -> Parser Char
char x    = sat (== x)

string :: String -> Parser String
string []     = return' []
string (x:xs) = char x >>- \d1 ->
                string xs >>- \d2 ->
                return' (x:xs)

many  :: Parser a -> Parser [a]
many p = many1 p +++ return' []

many1  :: Parser a -> Parser [a]
many1 p = p >>- \v ->
          many p >>- \vs ->
          return' (v:vs)

ident :: Parser String
ident  = lower >>- \x ->
         many alphanum >>- \xs ->
         return' (x:xs)

nat :: Parser Int
nat  = many1 digit >>- \xs ->
       return' (read xs)

space :: Parser ()
space  = many (sat isSpace) >>- \d ->
         return' ()
||<

パーサーはモナド（もどき）なのでbind（もどき）ができて、合成もできる。最後の3つ（識別子パーサー、自然数パーサー、空白パーサー）まで積み上がっていくのはなかなか凄いねえ。

**空白の扱い
さっきの部品を使って、前後の空白を無視する(単に消費する)パーサーを組み上げる。
>|haskell|
token  :: Parser a -> Parser a
token p = space >>- \d1 ->
          p >>- \v ->
          space >>- \d2 ->
          return' v

identifier :: Parser String
identifier  = token ident

natural :: Parser Int
natural  = token nat

symbol   :: String -> Parser String
symbol xs = token (string xs)
||<

ここまでできると、応用として空白を無視する整数リストのパーサーができる。

>|haskell|
p :: Parser [Int]
p = symbol ""["" >>- \d1 ->
    natural >>- \n ->
    many (symbol "","" >>- \d2 -> natural) >>- \ns ->
    symbol ""]"" >>- \d3 ->
    return' (n:ns)
||<

Hugsでの実行サンプルはこちら。
>|haskell|
Main> parse p "" [ 1 , 2 , 3   ] ""
[([1,2,3],"""")]
Main> parse p "" [ 1 , a , 3   ] ""
[]
||<


慣れてくるとパーサー定義が「読める」ようになってくる。ある種のDSL。関数型言語ならではなのか、Haskellならではなのか。
"
2011-05-14,,"*1305333413*第8章 関数型パーサー #2
**連結

今度はバインド演算子 (>>=)が出てきた。
教科書では、この演算子は「そして」と読めばいいと書いてある。教科書の付録Bには、この演算子の意味は“順序付け”だとある。その真意は後から分かってくる。

>|haskell|
(>>-) :: Parser a -> (a -> Parser b) -> Parser b
p >>- f = \inp -> case parse p inp of
                    [] -> []
                    [(v, out)] -> parse (f v) out
||<

上の定義に出てくる<code>p</code>は1つ目のパーサー、<code>f</code>は「1つ目のパーサーのパース結果を前提にした2つ目のパーサー」ととらえればいい。演算結果は、1つ目のパーサーと2つ目のパーサーを実際に連結したパーサーだ（型は2つめのパーサーと同じ型になる）。
右辺の<code>inp</code>は入力文字列。入力文字列を1つ目のパーサーに食わせた結果が<code>parse p inp</code>で、その結果を元にパターンマッチで分岐している。落ち着いて読めば難しくはない。

そして、このバインド演算子の連続適用方法が説明される。

>|haskell|
p1 >>= \v1 ->
p2 >>= \v2 ->
...
pn >>= \vn ->
return (f v1 v2 ... vn)
||<

でもこれちょっと端折ってるなあ。最初はこのバインド演算子の使い方として、「右辺をラムダ式にすると便利」という所からにしてほしい。つまり、

>|haskell|
p1 >>= (\v1 -> return (f v1))
||<

の右辺は、「左辺のパース結果をv1としたときの、最終的なパーサー」で、かつバインド演算子の優先順位は低いから右辺の括弧は省略できて、

>|haskell|
p1 >>= \v1 -> return (f v1)
||<

と書ける。そしてこのときには、「p1の結果をバインド演算子によってv1に結びつけたとき、最終的なパース結果はv1の関数になる。」という意味になる。

ここで初めてバインド演算子の連続適用（というか、入れ子適用）の話をすればいい。

パーサー p1とp2があったとき、p1とp2を結合するには

>|haskell|
p1 >>= \v1 -> (p2 >>= \v2 -> return (f v1 v2))
||<

と書くけれども、ここでもバインド演算子の優先順位は低いから右辺の括弧は省略できて、

>|haskell|
p1 >>= \v1 -> p2 >>= \v2 -> return (f v1 v2)
||<

と書ける。これを改行して見やすくしたものが

>|haskell|
p1 >>= \v1 ->
p2 >>= \v2 ->
return (f v1 v2)
||<

で、これの意味は、「p1の結果をバインド演算子によってv1に結びつけ、<strong>そしてその次に</strong>p2の結果をバインド演算子によってv2に結びつけたとき、最終的なパース結果はv1とv2の関数になる。」だ。ここまで説明すれば、パーサの数がn個になったときの書き方もすぐ理解できると思う。

さて、話は次に進んで、do記法だ。

>|haskell|
do v1 <- p1
   v2 <- p2
   ...
   vn <- pn
   return (f v1 v2 ... vn)
||<

と、Haskellではこのように書けると出てくるのだけど、ここが地味に嘘で、そのためには<strong>本物のモナド</strong>を使う必要がある。
もともと、<code>return</code>や<code>>>=</code>も本物のモナド用の関数・演算子なので、この章では使えない。それを知っていたので、わざとその代わりに<code>return'</code>や<code>>>-</code>を定義してみたのだけど、さすがにdo記法だけは対応できない。まあ、10章まで待ちます。

さて、教科書はこの後はdo記法で書かれているけど、Hugsで動かしたいので、do記法を使わずに、おれおれ<code>>>-</code>とおれおれ<code>return'</code>で写経する。

>|haskell|
p :: Parser (Char, Char)
p = item >>- \x ->
    item >>- \_ ->
    item >>- \y ->
    return' (x, y)
||<

do記法だと使用しない値は変数にバインドしなくていいけど、バインド演算子で書く場合には省略できないのがちょっと残念。

**選択

これはor、っていうか<code>||</code>演算子に似ている。

>|haskell|
(+++) :: Parser a -> Parser a -> Parser a
p +++ q = \inp -> case parse p inp of
                    [] -> parse q inp
                    [(v, out)] -> [(v, out)]

||<",,"*1305333413*第8章 関数型パーサー #2
**連結

今度はバインド演算子 (>>=)が出てきた。
教科書では、この演算子は「そして」と読めばいいと書いてある。教科書の付録Bには、この演算子の意味は“順序付け”だとある。その真意は後から分かってくる。

>|haskell|
(>>-) :: Parser a -> (a -> Parser b) -> Parser b
p >>- f = \inp -> case parse p inp of
                    [] -> []
                    [(v, out)] -> parse (f v) out
||<

上の定義に出てくる<code>p</code>は1つ目のパーサー、<code>f</code>は「1つ目のパーサーのパース結果を前提にした2つ目のパーサー」ととらえればいい。演算結果は、1つ目のパーサーと2つ目のパーサーを実際に連結したパーサーだ（型は2つめのパーサーと同じ型になる）。
右辺の<code>inp</code>は入力文字列。入力文字列を1つ目のパーサーに食わせた結果が<code>parse p inp</code>で、その結果を元にパターンマッチで分岐している。落ち着いて読めば難しくはない。

そして、このバインド演算子の連続適用方法が説明される。

>|haskell|
p1 >>= \v1 ->
p2 >>= \v2 ->
...
pn >>= \vn ->
return (f v1 v2 ... vn)
||<

でもこれちょっと端折ってるなあ。最初はこのバインド演算子の使い方として、「右辺をラムダ式にすると便利」という所からにしてほしい。つまり、

>|haskell|
p1 >>= (\v1 -> return (f v1))
||<

の右辺は、「左辺のパース結果をv1としたときの、最終的なパーサー」で、かつバインド演算子の優先順位は低いから右辺の括弧は省略できて、

>|haskell|
p1 >>= \v1 -> return (f v1)
||<

と書ける。そしてこのときには、「p1の結果をバインド演算子によってv1に結びつけたとき、最終的なパース結果はv1の関数になる。」という意味になる。

ここで初めてバインド演算子の連続適用（というか、入れ子適用）の話をすればいい。

パーサー p1とp2があったとき、p1とp2を結合するには

>|haskell|
p1 >>= \v1 -> (p2 >>= \v2 -> return (f v1 v2))
||<

と書くけれども、ここでもバインド演算子の優先順位は低いから右辺の括弧は省略できて、

>|haskell|
p1 >>= \v1 -> p2 >>= \v2 -> return (f v1 v2)
||<

と書ける。これを改行して見やすくしたものが

>|haskell|
p1 >>= \v1 ->
p2 >>= \v2 ->
return (f v1 v2)
||<

で、これの意味は、「p1の結果をバインド演算子によってv1に結びつけ、<strong>そしてその次に</strong>p2の結果をバインド演算子によってv2に結びつけたとき、最終的なパース結果はv1とv2の関数になる。」だ。ここまで説明すれば、パーサの数がn個になったときの書き方もすぐ理解できると思う。

さて、話は次に進んで、do記法だ。

>|haskell|
do v1 <- p1
   v2 <- p2
   ...
   vn <- pn
   return (f v1 v2 ... vn)
||<

と、Haskellではこのように書けると出てくるのだけど、ここが地味に嘘で、そのためには<strong>本物のモナド</strong>を使う必要がある。
もともと、<code>return</code>や<code>>>=</code>も本物のモナド用の関数・演算子なので、この章では使えない。それを知っていたので、わざとその代わりに<code>return'</code>や<code>>>-</code>を定義してみたのだけど、さすがにdo記法だけは対応できない。まあ、10章まで待ちます。

さて、教科書はこの後はdo記法で書かれているけど、Hugsで動かしたいので、do記法を使わずに、おれおれ<code>>>-</code>とおれおれ<code>return'</code>で写経する。

>|haskell|
p :: Parser (Char, Char)
p = item >>- \x ->
    item >>- \_ ->
    item >>- \y ->
    return' (x, y)
||<

do記法だと使用しない値は変数にバインドしなくていいけど、バインド演算子で書く場合には省略できないのがちょっと残念。

**選択

これはor、っていうか<code>||</code>演算子に似ている。

>|haskell|
(+++) :: Parser a -> Parser a -> Parser a
p +++ q = \inp -> case parse p inp of
                    [] -> parse q inp
                    [(v, out)] -> [(v, out)]

||<"
2011-05-11,,"*1305126241*第8章 関数型パーサー #1
モナドの章！（教科書にはまだ「モナド」という言葉は出てこないのだけど）

本章のパーサーは、文字列を受け取って、パース結果と残りの文字列の組をリストとして返す。
Maybeの代わりにリストで成功・失敗を表現するところが興味深い。まあリストもモナドなんだけどね。

>|haskell|
type Parser a = String -> [(a, String)]
||<

なんか、脚注には「この章のプログラムは動かない。」と書いてある……
まあ、気にせず進めよう。

**基本的なパーサー

しれっと<code>return</code>が出てきたｗ気づかないふりをしよう。

>|haskell|

type Parser a = String -> [(a, String)]

return' :: a -> Parser a
return' v = \inp -> [(v, inp)]

failure :: Parser a
failure = \inp -> []

item :: Parser Char
item = \inp -> case inp of
                 [] -> []
                 (x : xs) -> [(x, xs)]

parse :: Parser a -> String -> [(a, String)]
parse p inp = p inp
||<
<code>case</code>文は<code>if</code>文に少し似ているけど、パターンマッチを使える構文とのこと。",,"*1305126241*第8章 関数型パーサー #1
モナドの章！（教科書にはまだ「モナド」という言葉は出てこないのだけど）

本章のパーサーは、文字列を受け取って、パース結果と残りの文字列の組をリストとして返す。
Maybeの代わりにリストで成功・失敗を表現するところが興味深い。まあリストもモナドなんだけどね。

>|haskell|
type Parser a = String -> [(a, String)]
||<

なんか、脚注には「この章のプログラムは動かない。」と書いてある……
まあ、気にせず進めよう。

**基本的なパーサー

しれっと<code>return</code>が出てきたｗ気づかないふりをしよう。

>|haskell|

type Parser a = String -> [(a, String)]

return' :: a -> Parser a
return' v = \inp -> [(v, inp)]

failure :: Parser a
failure = \inp -> []

item :: Parser Char
item = \inp -> case inp of
                 [] -> []
                 (x : xs) -> [(x, xs)]

parse :: Parser a -> String -> [(a, String)]
parse p inp = p inp
||<
<code>case</code>文は<code>if</code>文に少し似ているけど、パターンマッチを使える構文とのこと。"
2011-05-10,,"*1305031064*第7章 高階関数 #3
ちょっと寄り道しすぎたかな。

**関数合成演算子

>|haskell|
(.) :: (b -> c) -> (a -> b) -> (a -> c)
f . g = \x -> f (g x)
||<

この演算は結合法則を満たすという。
>||
f . (g . h) = f . (\x -> g (h x))
            = \y -> f ((\x -> g (h x)) y)
            = \y -> f (g (h y))

(f . g) . h = (\x -> f (g x)) . h
            = \y -> (\x -> f (g x)) (h y)
            = \y -> f (g (h y))
||<
というわけで、確かに簡約すれば同じものになった。つまり、<code>f . g . h</code>のように、中かっこを書かなくてもよい。

C#でも関数を2つ引数にとって匿名関数を返すメソッドを書くことはできるけど、演算子として定義することはできない（デリゲートでは演算子をオーバーロードできない）から、中かっこも減らないし、大してうれしくない。（それに、入れ子になったラムダ式を処理系が最適化してくれるはずがないから、処理効率が心配である。）

**文字列の変換器

いきなり型の定義（というか、エイリアス？）が出てきたけど、ここでは深く考えないほうがいいんだろうな。
>|haskell|
type Bit = Int
||<

そして、標準ライブラリ関数 <code>iterate</code> も出てきた。こっちはちゃんと理解するために、自分で定義しなおしておこう。
>|haskell|
iterate' :: (a -> a) -> a -> [a]
iterate' f x = x : (iterate' f (f x))
||<

ライブラリ関数 <code>repeat</code>も出てきたけど、これは前のエントリで自習して知ってるから省略。

以下、なんだか長いが写経する。ここでは数値の2進表記は逆順に書かれていることに注意。

>|haskell|
import Data.Char

type Bit = Int

-- 教科書では、まずsumとiterateを使ってbin2intを定義して、
-- bin2int bits = sum [w * b | (w, b) <- zip weights bits]
--                where weights = iterate (*2) 1
-- それからfoldrを使って書きなおしている。
-- 確かに、sumは集約関数なんだから、foldrで書き直せることは道理だ。
bin2int :: [Bit] -> Bit
bin2int = foldr (\x y -> x + 2 * y) 0

-- そうであるなら、int2binはunfoldで書けるはず。
-- 教科書にはまだunfoldは出てきてないけどね。;-)
int2bin :: Bit -> [Bit]
int2bin 0 = []
int2bin n = n `mod` 2 : int2bin (n `div` 2)

-- 8bit化する
make8 :: [Bit] -> [Bit]
make8 bits = take 8 (bits ++ repeat 0)

-- 文字列をビットストリームに変換する
encode :: String -> [Bit]
encode = concat . map (make8 . int2bin . ord)

-- 8bitごと分解してリスト化する
chop8 :: [Bit] -> [ [Bit] ]
chop8 [] = []
chop8 bits = take 8 bits : chop8 (drop 8 bits)

-- ビットストリームを文字列に変換する
decode :: [Bit] -> String
decode = map (chr . bin2int) . chop8

-- 通信路をモデル化する
channel :: [Bit] -> [Bit]
channel = id

-- 通信をシミュレートする
transmit :: String -> String
transmit = decode . channel . encode
||<

**練習問題

***問題1
>|haskell|
-- question1 f p xs = [f x | x <- xs, p x]
question1 f p xs = ((map f) . (filter p)) xs
||<

***問題2

問題4の後で、2引数のラムダ式に書きなおした。2引数のラムダ式の方が理解しやすいと思う。

>|haskell|
all' :: (a -> Bool) -> [a] -> Bool
-- all' p = foldr ((&&) . p) True
all' p = foldr (\x y -> p x && y) True

any' :: (a -> Bool) -> [a] -> Bool
-- any' p = foldr ((||) . p) False
any' p = foldr (\x y -> p x || y) False

takeWhile' :: (a -> Bool) -> [a] -> [a]
-- takeWhile' p = foldr (\x -> if p x then (x:) else const []) []
takeWhile' p = foldr (\x y -> if p x then x : y else []) []

dropWhile' :: (a -> Bool) -> [a] -> [a]
-- dropWhile' p = foldr (\x -> if p x then id else (x:)) []
dropWhile' p = foldr (\x y -> if p x then y else x : y) []
||<

<code>takeWhile</code>と<code>dropWhile</code>については、最初はガードを使った場合分けを考えていたので、<code>foldr</code>を使うより再帰のほうが簡潔かなと思っていた。
問題3を解いているときに「if-then-elseなら1行で書ける！」と気づいたので書きなおしたのだが、その時はなぜか1引数のラムダ式で書いていた。そのせいで<code>const</code>や<code>id</code>を使うはめになっている。

***問題3

問題4の後で、2引数のラムダ式に書きなおした。2引数のラムダ式の方が理解しやすいと思う。

>|haskell|
map' :: (a -> b) -> [a] -> [b]
-- map' f = foldr ((:) . f) []
map' f = foldr (\x y -> f x : y) []

filter' :: (a -> Bool) -> [a] -> [a]
-- filter' p = foldr (\x -> if p x then (x:) else id) []
filter' p = foldr (\x y -> if p x then x : y else y) []
||<

***問題4

>|haskell|
dec2int :: [Int] -> Int
dec2int = foldl (\x y -> x * 10 + y) 0
||<

解きながら「文字列の変換器」を読み返して反省した。<code>foldr</code>や<code>foldl</code>にラムダ式を食わせるときは、2引数のラムダ式のほうが見やすい。
というわけで、練習問題の回答をさかのぼって修正した。

***問題5
たぶん型があわないんじゃないかなと予想して、Hugsで型を見てみる。
>|haskell|
filter even :: Integral a => [a] -> [a]
map (^2) :: (Num a, Integral b) => [a] -> [a]
sum :: Num a => [a] -> a
||<
あれ。整数クラスに適用する分には問題なさそうだけど……と思ったが、ここで、<code>compose</code>は標準ライブラリ関数ではなかったことに気づき、教科書を読み返した。

>|haskell|
compose :: [a -> a] -> (a -> a)
compose = foldr (.) id
||<
ここで目から鱗。そうか、リスト内の関数はすべて同じ型じゃないといけないんだな。

>|haskell|
sum . map (^2) . filter even
||<
という関数合成には問題ないけど、sumだけ型が違うからリストには入らない。把握した。

***問題6

ん？2つ組のタプルだけでいいの？

>|haskell|
curry' :: ((a, b) -> c) -> (a -> b -> c)
curry' f x y = f (x, y)

uncurry' :: (a -> b -> c) -> ((a, b) -> c)
uncurry' f (x, y) = f x y
||<

*1304981277*foldrでdrop
foldrが無限リストを扱えるというならできるはずだと思って書いてみた。

>|haskell|
drop' n = foldr f [] . zip (trueWhile n)
          where
              trueWhile n = (replicate n True) ++ (repeat False)
              f (True, _)  = id
              f (_ , x) = (:) x
||<

（追記）<code>foldr</code>に食わせる関数が2引数であることが分かった方が理解しやすい。
関数合成も少ない方が理解しやすい気がする。
名前はもちろん長い方が理解しやすい。

>|haskell|
drop' n xs = foldr dropWhileTrue [] (zip trueThenFalse xs)
             where
               trueThenFalse = (replicate n True) ++ (repeat False)
               dropWhileTrue (b, x) xs = if b then xs else x : xs
||<
",,"*1305031064*第7章 高階関数 #3
ちょっと寄り道しすぎたかな。

**関数合成演算子

>|haskell|
(.) :: (b -> c) -> (a -> b) -> (a -> c)
f . g = \x -> f (g x)
||<

この演算は結合法則を満たすという。
>||
f . (g . h) = f . (\x -> g (h x))
            = \y -> f ((\x -> g (h x)) y)
            = \y -> f (g (h y))

(f . g) . h = (\x -> f (g x)) . h
            = \y -> (\x -> f (g x)) (h y)
            = \y -> f (g (h y))
||<
というわけで、確かに簡約すれば同じものになった。つまり、<code>f . g . h</code>のように、中かっこを書かなくてもよい。

C#でも関数を2つ引数にとって匿名関数を返すメソッドを書くことはできるけど、演算子として定義することはできない（デリゲートでは演算子をオーバーロードできない）から、中かっこも減らないし、大してうれしくない。（それに、入れ子になったラムダ式を処理系が最適化してくれるはずがないから、処理効率が心配である。）

**文字列の変換器

いきなり型の定義（というか、エイリアス？）が出てきたけど、ここでは深く考えないほうがいいんだろうな。
>|haskell|
type Bit = Int
||<

そして、標準ライブラリ関数 <code>iterate</code> も出てきた。こっちはちゃんと理解するために、自分で定義しなおしておこう。
>|haskell|
iterate' :: (a -> a) -> a -> [a]
iterate' f x = x : (iterate' f (f x))
||<

ライブラリ関数 <code>repeat</code>も出てきたけど、これは前のエントリで自習して知ってるから省略。

以下、なんだか長いが写経する。ここでは数値の2進表記は逆順に書かれていることに注意。

>|haskell|
import Data.Char

type Bit = Int

-- 教科書では、まずsumとiterateを使ってbin2intを定義して、
-- bin2int bits = sum [w * b | (w, b) <- zip weights bits]
--                where weights = iterate (*2) 1
-- それからfoldrを使って書きなおしている。
-- 確かに、sumは集約関数なんだから、foldrで書き直せることは道理だ。
bin2int :: [Bit] -> Bit
bin2int = foldr (\x y -> x + 2 * y) 0

-- そうであるなら、int2binはunfoldで書けるはず。
-- 教科書にはまだunfoldは出てきてないけどね。;-)
int2bin :: Bit -> [Bit]
int2bin 0 = []
int2bin n = n `mod` 2 : int2bin (n `div` 2)

-- 8bit化する
make8 :: [Bit] -> [Bit]
make8 bits = take 8 (bits ++ repeat 0)

-- 文字列をビットストリームに変換する
encode :: String -> [Bit]
encode = concat . map (make8 . int2bin . ord)

-- 8bitごと分解してリスト化する
chop8 :: [Bit] -> [ [Bit] ]
chop8 [] = []
chop8 bits = take 8 bits : chop8 (drop 8 bits)

-- ビットストリームを文字列に変換する
decode :: [Bit] -> String
decode = map (chr . bin2int) . chop8

-- 通信路をモデル化する
channel :: [Bit] -> [Bit]
channel = id

-- 通信をシミュレートする
transmit :: String -> String
transmit = decode . channel . encode
||<

**練習問題

***問題1
>|haskell|
-- question1 f p xs = [f x | x <- xs, p x]
question1 f p xs = ((map f) . (filter p)) xs
||<

***問題2

問題4の後で、2引数のラムダ式に書きなおした。2引数のラムダ式の方が理解しやすいと思う。

>|haskell|
all' :: (a -> Bool) -> [a] -> Bool
-- all' p = foldr ((&&) . p) True
all' p = foldr (\x y -> p x && y) True

any' :: (a -> Bool) -> [a] -> Bool
-- any' p = foldr ((||) . p) False
any' p = foldr (\x y -> p x || y) False

takeWhile' :: (a -> Bool) -> [a] -> [a]
-- takeWhile' p = foldr (\x -> if p x then (x:) else const []) []
takeWhile' p = foldr (\x y -> if p x then x : y else []) []

dropWhile' :: (a -> Bool) -> [a] -> [a]
-- dropWhile' p = foldr (\x -> if p x then id else (x:)) []
dropWhile' p = foldr (\x y -> if p x then y else x : y) []
||<

<code>takeWhile</code>と<code>dropWhile</code>については、最初はガードを使った場合分けを考えていたので、<code>foldr</code>を使うより再帰のほうが簡潔かなと思っていた。
問題3を解いているときに「if-then-elseなら1行で書ける！」と気づいたので書きなおしたのだが、その時はなぜか1引数のラムダ式で書いていた。そのせいで<code>const</code>や<code>id</code>を使うはめになっている。

***問題3

問題4の後で、2引数のラムダ式に書きなおした。2引数のラムダ式の方が理解しやすいと思う。

>|haskell|
map' :: (a -> b) -> [a] -> [b]
-- map' f = foldr ((:) . f) []
map' f = foldr (\x y -> f x : y) []

filter' :: (a -> Bool) -> [a] -> [a]
-- filter' p = foldr (\x -> if p x then (x:) else id) []
filter' p = foldr (\x y -> if p x then x : y else y) []
||<

***問題4

>|haskell|
dec2int :: [Int] -> Int
dec2int = foldl (\x y -> x * 10 + y) 0
||<

解きながら「文字列の変換器」を読み返して反省した。<code>foldr</code>や<code>foldl</code>にラムダ式を食わせるときは、2引数のラムダ式のほうが見やすい。
というわけで、練習問題の回答をさかのぼって修正した。

***問題5
たぶん型があわないんじゃないかなと予想して、Hugsで型を見てみる。
>|haskell|
filter even :: Integral a => [a] -> [a]
map (^2) :: (Num a, Integral b) => [a] -> [a]
sum :: Num a => [a] -> a
||<
あれ。整数クラスに適用する分には問題なさそうだけど……と思ったが、ここで、<code>compose</code>は標準ライブラリ関数ではなかったことに気づき、教科書を読み返した。

>|haskell|
compose :: [a -> a] -> (a -> a)
compose = foldr (.) id
||<
ここで目から鱗。そうか、リスト内の関数はすべて同じ型じゃないといけないんだな。

>|haskell|
sum . map (^2) . filter even
||<
という関数合成には問題ないけど、sumだけ型が違うからリストには入らない。把握した。

***問題6

ん？2つ組のタプルだけでいいの？

>|haskell|
curry' :: ((a, b) -> c) -> (a -> b -> c)
curry' f x y = f (x, y)

uncurry' :: (a -> b -> c) -> ((a, b) -> c)
uncurry' f (x, y) = f x y
||<

*1304981277*foldrでdrop
foldrが無限リストを扱えるというならできるはずだと思って書いてみた。

>|haskell|
drop' n = foldr f [] . zip (trueWhile n)
          where
              trueWhile n = (replicate n True) ++ (repeat False)
              f (True, _)  = id
              f (_ , x) = (:) x
||<

（追記）<code>foldr</code>に食わせる関数が2引数であることが分かった方が理解しやすい。
関数合成も少ない方が理解しやすい気がする。
名前はもちろん長い方が理解しやすい。

>|haskell|
drop' n xs = foldr dropWhileTrue [] (zip trueThenFalse xs)
             where
               trueThenFalse = (replicate n True) ++ (repeat False)
               dropWhileTrue (b, x) xs = if b then xs else x : xs
||<
"
2011-05-08,,"*1304861961*第7章 高階関数 #2
**リスト処理
標準ライブラリPreludeに含まれるリスト処理高階関数。
-<code>map :: (a -> b) -> [a] -> [b]</code>
-<code>filter :: (a -> Bool) -> [a] -> [a]</code>
-<code>all :: (a -> Bool) -> [a] -> Bool</code>
-<code>any :: (a -> Bool) -> [a] -> Bool</code>
-<code>takeWhile :: (a -> Bool) -> [a] -> [a]</code>
-<code>dropWhile :: (a -> Bool) -> [a] -> [a]</code>

LINQだとmapがSelectでfilterがWhereだけど、後は同名のメソッドがある。

**畳込関数 foldr
来ましたfoldr。定義を写経してみる。
>|haskell|
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f v [] = v
foldr f v (x : xs) = f x (foldr f v xs)
||<
再帰定義を見ると簡潔だし、無限リストに適用できそうなのも理解できる。ただし
-関数fを適用する際に、第2引数が遅延評価される（正格評価されない）
-関数fが値を返す際に、第2引数を評価しないか、または評価を遅延できる
の両方が必要になる（でないと結局foldrは終わらない）。

では、foldrを使って定義したライブラリ関数を写経しよう。
>|haskell|
sum     = foldr (+) 0
product = foldr (*) 1
or      = foldr (||) False
and     = foldr (&&) True
length  = foldr (\_ n -> 1 + n) 0
reverse = foldr (\x xs -> xs ++ [x]) []
(++) xs ys  = foldr (:) ys xs
||<

**畳込関数 foldl
こっちはLINQにあるけれども、やはり定義を写経。
>|haskell|
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f v [] = v
foldl f v (x : xs) = foldl f (f v x) xs
||<
ふーむ。定義だけ見ると分かったような分からんような。ただ、無限リストに適用すると、fがどんな性質を持っていようが再帰が終わらないことはわかる。

foldrとfoldlの型を並べてみる。（型変数を揃えておく）

>|haskell|
foldr :: (a -> b -> b) -> b -> [a] -> b
foldl :: (b -> a -> b) -> b -> [a] -> b
||<
というわけで、第1引数の関数が右結合か左結合かというのがなんとなく分かった気がする。

上と同じライブラリ関数をfoldlで定義すると。

>|haskell|
sum     = foldl (+) 0
product = foldl (*) 1
or      = foldl (||) False
and     = foldl (&&) True
length  = foldl (\n _ -> n + 1) 0
reverse = foldl (\xs x -> x : xs) []
-- 教科書の (++) の定義は意味不明。(xs++)を++で定義している。
-- foldlだけでは定義できなくて、foldrが必要ってこと？
||<

続きはまた明日以降。

*1304857778*第7章 高階関数 #1

map/filter/foldr/foldlを例にした説明。
このうち、foldr以外はLINQにもある。mapは[http://msdn.microsoft.com/ja-jp/library/bb546168.aspx:title=Select]、filterは[http://msdn.microsoft.com/ja-jp/library/bb546161.aspx:title=Where]、foldlは[http://msdn.microsoft.com/ja-jp/library/bb546138.aspx:title=Aggregate]。だから大体問題ないんだけど、foldrを理解するのにちょっと時間がかかった。
教科書にはまだ書いてなかったんだけど、どうやらfoldrは無限リストを扱えるようなのだ。
まじ？どうやって？なんでfoldlではだめなの？

ということでいろいろ調べながら、C#でfoldrを実装してみた。
[http://d.hatena.ne.jp/matarillo/20110507/p1:title]

これで少し納得がいった。foldrで無限リストを扱うには遅延評価が必要だと。

では教科書に戻る。",,"*1304861961*第7章 高階関数 #2
**リスト処理
標準ライブラリPreludeに含まれるリスト処理高階関数。
-<code>map :: (a -> b) -> [a] -> [b]</code>
-<code>filter :: (a -> Bool) -> [a] -> [a]</code>
-<code>all :: (a -> Bool) -> [a] -> Bool</code>
-<code>any :: (a -> Bool) -> [a] -> Bool</code>
-<code>takeWhile :: (a -> Bool) -> [a] -> [a]</code>
-<code>dropWhile :: (a -> Bool) -> [a] -> [a]</code>

LINQだとmapがSelectでfilterがWhereだけど、後は同名のメソッドがある。

**畳込関数 foldr
来ましたfoldr。定義を写経してみる。
>|haskell|
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f v [] = v
foldr f v (x : xs) = f x (foldr f v xs)
||<
再帰定義を見ると簡潔だし、無限リストに適用できそうなのも理解できる。ただし
-関数fを適用する際に、第2引数が遅延評価される（正格評価されない）
-関数fが値を返す際に、第2引数を評価しないか、または評価を遅延できる
の両方が必要になる（でないと結局foldrは終わらない）。

では、foldrを使って定義したライブラリ関数を写経しよう。
>|haskell|
sum     = foldr (+) 0
product = foldr (*) 1
or      = foldr (||) False
and     = foldr (&&) True
length  = foldr (\_ n -> 1 + n) 0
reverse = foldr (\x xs -> xs ++ [x]) []
(++) xs ys  = foldr (:) ys xs
||<

**畳込関数 foldl
こっちはLINQにあるけれども、やはり定義を写経。
>|haskell|
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f v [] = v
foldl f v (x : xs) = foldl f (f v x) xs
||<
ふーむ。定義だけ見ると分かったような分からんような。ただ、無限リストに適用すると、fがどんな性質を持っていようが再帰が終わらないことはわかる。

foldrとfoldlの型を並べてみる。（型変数を揃えておく）

>|haskell|
foldr :: (a -> b -> b) -> b -> [a] -> b
foldl :: (b -> a -> b) -> b -> [a] -> b
||<
というわけで、第1引数の関数が右結合か左結合かというのがなんとなく分かった気がする。

上と同じライブラリ関数をfoldlで定義すると。

>|haskell|
sum     = foldl (+) 0
product = foldl (*) 1
or      = foldl (||) False
and     = foldl (&&) True
length  = foldl (\n _ -> n + 1) 0
reverse = foldl (\xs x -> x : xs) []
-- 教科書の (++) の定義は意味不明。(xs++)を++で定義している。
-- foldlだけでは定義できなくて、foldrが必要ってこと？
||<

続きはまた明日以降。

*1304857778*第7章 高階関数 #1

map/filter/foldr/foldlを例にした説明。
このうち、foldr以外はLINQにもある。mapは[http://msdn.microsoft.com/ja-jp/library/bb546168.aspx:title=Select]、filterは[http://msdn.microsoft.com/ja-jp/library/bb546161.aspx:title=Where]、foldlは[http://msdn.microsoft.com/ja-jp/library/bb546138.aspx:title=Aggregate]。だから大体問題ないんだけど、foldrを理解するのにちょっと時間がかかった。
教科書にはまだ書いてなかったんだけど、どうやらfoldrは無限リストを扱えるようなのだ。
まじ？どうやって？なんでfoldlではだめなの？

ということでいろいろ調べながら、C#でfoldrを実装してみた。
[http://d.hatena.ne.jp/matarillo/20110507/p1:title]

これで少し納得がいった。foldrで無限リストを扱うには遅延評価が必要だと。

では教科書に戻る。"
2011-05-05,,"*1304611396*第6章 再帰関数
考え方は難しくないけど、パターンマッチがおもしろい。

**基本概念

繰り返し簡約することで値が求まる。n+kパターンは再帰に便利。
>|haskell|
factorial 0       = 1
factorial (n + 1) = (n + 1) * factorial n
||<

**リストに対する再帰
これこれ。このパターンマッチを忘れていた。
>|haskell|
product [] = 1
product (n : ns) = n * product ns
||<
これがないと、headとかtailを無駄に書いてしまう。

ついでに、isortを写経。
>|haskell|
insert x [] = [x]
insert x (y : ys) | x <= y = x : y : ys
                  | otherwise = y : insert x ys

isort []       = []
isort (x : xs) = insert x (isort xs)
||<

**複数の引数
第5章にzip'の自分定義をしたけど、リストパターンを使えばもっとすっきり。
>|haskell|
zip' _ [] = []
zip' [] _ = []
zip' (x : xs) (y : ys) = (x, y) : zip' xs ys
||<

**多重再帰
フィボナッチ数が典型例。
>|haskell|
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci (n + 2) = fibonacci n + fibonacci (n + 1)
||<

**相互再帰
例は人工的すぎるけど。

>|haskell|
even' 0 = True
even' (n + 1) = odd' n
odd' 0 = False
odd' (n + 1) = even' n
||<

**再帰の秘訣
他のプログラミング言語で再帰に馴染んでいる人にしてみれば、何を今更な内容かも。
+型を定義する
+場合分けをする
+簡単な方を定義する
+複雑な方を定義する
+一般化し単純化する
第5段階がミソかな。

ここの写経はいいや。

**練習問題
***問題1
>|haskell|
m ^ 0 = 1
m ^ (n + 1) = m * (m ^ n)
||<

>|haskell|
2 ^ 3 = 2 * (2 ^ 2)
      = 2 * (2 * (2 ^ 1))
      = 2 * (2 * (2 * (2 ^ 0)))
      = 2 * (2 * (2 * 1))
      = 8
||<


***問題2

>|haskell|
length [1, 2, 3] = length (1: (2: (3: [])))
                 = 1 + length (2: (3: []))
                 = 1 + (1 + length (3: []))
                 = 1 + (1 + (1 + length []))
                 = 1 + (1 + (1 + 0))
                 = 3
||<

>|haskell|
drop 3 [1, 2, 3, 4, 5] = drop 3 (1: (2: (3: (4: (5: [])))))
                       = drop 2 (2: (3: (4: (5: []))))
                       = drop 1 (3: (4: (5: [])))
                       = drop 0 (4: (5: []))
                       = 4: (5: [])
                       = [4, 5]
||<

>|haskell|
init [1, 2, 3] = init (1: (2: (3: [])))
               = 1: init (2: (3: []))
               = 1: (2: init (3: []))
               = 1: (2: [])
               = [1, 2]
||<

***問題3

>|haskell|
and [] = True
and (x : xs) | x == False = False
             | otherwise = and xs
||<

>|haskell|
concat [] = []
concat (xs : xss) = xs ++ concat' xss
||<

concat、最初は間違えた。Hugsで実行しながら修正した。引数の型をちゃんと意識したらできた。

>|haskell|
replicate 0 _ = []
replicate (n + 1) x = x : replicate n x
||<

>|haskell|
(x: _) !! 0 = x
(x: xs) !! (n + 1) = xs !! n
||<

>|haskell|
elem _ [] = False
elem x (y: ys) | x == y    = True
               | otherwise = elem x ys
||<

***問題4

>|haskell|
merge [] xs = xs
merge xs [] = xs
merge (x: xs) (y: ys) | x <= y    = x : merge xs (y: ys)
                      | otherwise = y : merge (x : xs) ys
||<

***問題5
>|haskell|
halve xs = splitAt (length xs `div` 2) xs

msort [] = []
msort [x] = [x]
msort xs = merge (msort fs) (msort ss)
           where (fs, ss) = halve xs
||<

***問題6
5段階の工程は面倒だから省略するけど、型は明示しよう。
>|haskell|
sum :: Num a => [a] -> a
sum [] = 0
sum (x: xs) = x + sum xs
||<

>|haskell|
take :: Integral a => a -> [b] -> [b]
take 0 _ = []
take n [] = []
take (n + 1) (x: xs) = x : take n xs
||<

>|haskell|
last :: [a] -> a
last [x] = x
last (x: xs) = last xs
||<

*1304589921*ここまでのまとめ：ライブラリ関数
ここまで教科書に出てきたライブラリ関数(演算子も含める)をまとめてみる。
教科書の付録Aにはもっと多くの関数が載っている。（付録Aを読んでみたら、ガードのotherwiseはキーワードではなくTrueと評価される定数だった。新しい発見。）

-<code>(+) :: Num a => a -> a -> a</code> 
-<code>(-) :: Num a => a -> a -> a</code> 
-<code>(*) :: Num a => a -> a -> a</code> 
-<code>negate :: Num a => a -> a</code>
-<code>abs :: Num a => a -> a</code>
-<code>signum :: Num a => a -> a</code>
-<code>mod :: Integral a => a -> a -> a</code>
-<code>div :: Integral a => a -> a -> a</code>
-<code>even :: Integral a => a -> Bool</code>
-<code>odd :: Integral a => a -> Bool</code>
-<code>(/) :: Fractional a => a -> a -> a</code>
-<code>recip :: Fractional a => a -> a</code>
-<code>(^) :: (Num a, Integral b) => a -> b -> a</code>
-<code>sum :: Num a => [a] -> a</code>
-<code>product :: Num a => [a] -> a</code>
-<code>(++) :: [a] -> [a] -> [a]</code>
-<code>head :: [a] -> a</code>
-<code>tail :: [a] -> [a]</code>
-<code>(!!) :: [a] -> Int -> a</code>
-<code>take :: Int -> [a] -> [a]</code>
-<code>drop :: Int -> [a] -> [a]</code>
-<code>length :: [a] -> Int</code>
-<code>null :: [a] -> Bool</code>
-<code>reverse :: [a] -> [a]</code>
-<code>init :: [a] -> [a]</code>
-<code>not :: Bool -> Bool</code>
-<code>(&&) :: Bool -> Bool -> Bool</code>
-<code>(||) :: Bool -> Bool -> Bool</code>
-<code>fst :: (a,b) -> a</code>
-<code>snd :: (a,b) -> b</code>
-<code>zip :: [a] -> [b] -> [(a,b)]</code>
-<code>splitAt :: Int -> [a] -> ([a],[a])</code>
-<code>(:) :: a -> [a] -> [a]</code>
-<code>id :: a -> a</code>
-<code>(==) :: Eq a => a -> a -> Bool</code>
-<code>(/=) :: Eq a => a -> a -> Bool</code>
-<code>(<) :: Ord a => a -> a -> Bool</code>
-<code>(<=) :: Ord a => a -> a -> Bool</code>
-<code>(>) :: Ord a => a -> a -> Bool</code>
-<code>(>=) :: Ord a => a -> a -> Bool</code>
-<code>min :: Ord a => a -> a -> a</code>
-<code>max :: Ord a => a -> a -> a</code>
-<code>show :: Show a => a -> String</code>
-<code>read :: Read a => String -> a</code>
-<code>const :: a -> b -> a</code>
-<code>map :: (a -> b) -> [a] -> [b]</code>
-<code>and :: [Bool] -> Bool</code>
-<code>or :: [Bool] -> Bool</code>
-<code>concat :: [ [a] ] -> [a]</code>
-<code>fromIntegral :: (Integral a, Num b) => a -> b</code>
-<code>replicate :: Int -> a -> [a]</code>

**Data.Char
-<code>ord :: Char -> Int</code>
-<code>chr :: Int -> Char</code>
-<code>isDigit :: Char -> Bool</code>
-<code>isLower :: Char -> Bool</code>
-<code>isUpper :: Char -> Bool</code>
-<code>toLower :: Char -> Char</code>
-<code>toUpper :: Char -> Char</code>

*1304565090*第5章 リスト内包表記
C#だとLINQだけど、Haskellなどの関数型言語やPythonではリスト内包。これも書き方さえ覚えてしまえばそんなに難しい話じゃない。
Haskellではforとか書かないので、やっぱり数学っぽい。でもやってることはforと同じ。
>|haskell|
[(x, y) | x <- [1, 2, 3], y <- [4, 5]]
||<
と、リストの中にバー(|)を置いて、右側に生成器を書く。生成器を複数並べると、ネストしたforみたいになる。(最も右側の生成器が最も頻繁に変化するというあたりもforと同じ。)

リスト内包でもワイルドカード(_)が使える。
>|haskell|
first ps = [x | (x, _) <- ps]
||<
でもこれ、ワイルドカードである意味はあるのかな？

>|haskell|
first ps = [x | (x, y) <- ps]
||<
これでも同じじゃないかと思うけど……それとも遅延評価されるかどうかが変わるのだろうか？

**ガード

リスト内包のガードはフィルタになる。LINQでいうところのwhere、Pythonのリスト内包で言うところのif。
Haskellだとカンマ(,)で区切って論理式を書くようだけど、分かりやすいのかこれ？関数定義のガードはバー(|)を伴うけど、リスト内包ではすでにバーを使ってしまっているからカンマ区切りって、なんだかなあ。

>|haskell|
factors n = [x | x <- [1..n], n `mod` x == 0]
||<

書いてしまえば、短くまとまっているけどね。

教科書では、factorsからprime、primeからprimesを作っているので、写経してみる。

>|haskell|
factors n = [x | x <- [1..n], n `mod` x == 0]
prime n = factors n == [1, n]
primes n = [x | x <- [2..n], prime x]
||<

**zip関数

自分で書くとこんな感じか？（復習を兼ねて、cons演算子とパターンマッチで）

>|haskell|
zip' _ [] = []
zip' [] _ = []
zip' xs ys = (head xs, head ys) : zip' (tail xs) (tail ys)
||<

教科書では、zipからpairsを作り、pairsからsortedを作っているので、写経してみる。

>|haskell|
pairs xs = zip xs (tail xs)
sorted xs = and [x <= y | (x, y) <- pairs xs]
||<

なるほど、and関数(とor関数)にはリストを食わせるのか。逆に言うとこいつらは2項演算子じゃないんだな。

**文字列の内包表記

ここで、Stringは[Char]であることが示される。[http://haskell.g.hatena.ne.jp/matarillo/20110429/1304100404:title=気づいてたけど。]

ただし String is a [Char]なのはいいけど、逆はどうなんだろう。つまり、Stringと[Char]は同値なのか？というのが気になったので、試してみた。

>|haskell|
abc :: a -> String
abc _ = ['a', 'b', 'c']
||<
という関数を書いてみたけど普通に使えたので、Stringは[Char]のエイリアスなんだろうと理解した。

**シーザー暗号
これも写経する。

>|haskell|
import Data.Char

table = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.2, 0.8, 4.0, 2.4,
         6.7, 7.5, 1.9, 0.1,  6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1]

let2int c = ord c - ord 'a'
int2let n = chr (ord 'a' + n)
shift n c | isLower c = int2let ((let2int c + n) `mod` 26)
          | otherwise = c
encode n xs = [shift n x | x <- xs]

lowers xs = length [x | x <- xs, isLower x]
count x xs = length [x' | x' <- xs, x == x']
percent n m = (fromIntegral n / fromIntegral m) * 100
freqs xs = [percent (count x xs) n | x <- ['a'..'z']]
           where n = lowers xs

chisqr os es = sum [((o - e) ^ 2) / e | (o, e) <- zip os es]
rotate n xs = drop n xs ++ take n xs
positions x xs = [i | (x', i) <- zip xs [0..n], x == x']
                 where n = length xs - 1

crack xs = encode (-factor) xs
           where
             factor = head (positions (minimum chitab) chitab)
             chitab = [chisqr (rotate n table') table | n <- [0..25]]
             table' = freqs xs
||<
うわ、動いた。すごいけど気持ち悪っ！

**演習問題

***問題1
>|haskell|
sum [n^2 | n <- [1..100]]
||<

***問題2
>|haskell|
replicate n x = [x | _ <- [1..n]]
||<

***問題3
>|haskell|
pyths n = [(x, y, z) | x <- [1..n], y <- [1..n], z <- [1..n], x^2 + y^2 == z^2] 
||<

***問題4
>|haskell|
factors n = [x | x <- [1..n], n `mod` x == 0]
perfects n = [x | x <- [1..n], sum (factors x) == 2 * x]
||<

***問題5
>|haskell|
concat [[(x,y) | y <- [4,5,6]] | x <- [1,2,3]]
||<

***問題6
>|haskell|
find k t = [v | (k', v) <- t, k == k']
positions x xs = find x (zip xs [0..n])
                 where n = length xs - 1
||<

***問題7
>|haskell|
scalarproduct xs ys = sum [x * y | (x, y) <- zip xs ys]
||<

***問題8
上記シーザー暗号の差分だけ。面倒だったからmap関数を使ったけど、いいよね。教科書にもさらっと出てきたし。

>|haskell|
let2int' b c = ord c - ord b
int2let' b n = chr (ord b + n)
shift' b n c = int2let' b ((let2int' b c + n) `mod` 26)
shift n c | isLower c = shift' 'a' n c
          | isUpper c = shift' 'A' n c
          | otherwise = c

crack xs = encode (-factor) xs
           where
             factor = head (positions (minimum chitab) chitab)
             chitab = [chisqr (rotate n table') table | n <- [0..25]]
             table' = freqs (map toLower xs)
||<",,"*1304611396*第6章 再帰関数
考え方は難しくないけど、パターンマッチがおもしろい。

**基本概念

繰り返し簡約することで値が求まる。n+kパターンは再帰に便利。
>|haskell|
factorial 0       = 1
factorial (n + 1) = (n + 1) * factorial n
||<

**リストに対する再帰
これこれ。このパターンマッチを忘れていた。
>|haskell|
product [] = 1
product (n : ns) = n * product ns
||<
これがないと、headとかtailを無駄に書いてしまう。

ついでに、isortを写経。
>|haskell|
insert x [] = [x]
insert x (y : ys) | x <= y = x : y : ys
                  | otherwise = y : insert x ys

isort []       = []
isort (x : xs) = insert x (isort xs)
||<

**複数の引数
第5章にzip'の自分定義をしたけど、リストパターンを使えばもっとすっきり。
>|haskell|
zip' _ [] = []
zip' [] _ = []
zip' (x : xs) (y : ys) = (x, y) : zip' xs ys
||<

**多重再帰
フィボナッチ数が典型例。
>|haskell|
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci (n + 2) = fibonacci n + fibonacci (n + 1)
||<

**相互再帰
例は人工的すぎるけど。

>|haskell|
even' 0 = True
even' (n + 1) = odd' n
odd' 0 = False
odd' (n + 1) = even' n
||<

**再帰の秘訣
他のプログラミング言語で再帰に馴染んでいる人にしてみれば、何を今更な内容かも。
+型を定義する
+場合分けをする
+簡単な方を定義する
+複雑な方を定義する
+一般化し単純化する
第5段階がミソかな。

ここの写経はいいや。

**練習問題
***問題1
>|haskell|
m ^ 0 = 1
m ^ (n + 1) = m * (m ^ n)
||<

>|haskell|
2 ^ 3 = 2 * (2 ^ 2)
      = 2 * (2 * (2 ^ 1))
      = 2 * (2 * (2 * (2 ^ 0)))
      = 2 * (2 * (2 * 1))
      = 8
||<


***問題2

>|haskell|
length [1, 2, 3] = length (1: (2: (3: [])))
                 = 1 + length (2: (3: []))
                 = 1 + (1 + length (3: []))
                 = 1 + (1 + (1 + length []))
                 = 1 + (1 + (1 + 0))
                 = 3
||<

>|haskell|
drop 3 [1, 2, 3, 4, 5] = drop 3 (1: (2: (3: (4: (5: [])))))
                       = drop 2 (2: (3: (4: (5: []))))
                       = drop 1 (3: (4: (5: [])))
                       = drop 0 (4: (5: []))
                       = 4: (5: [])
                       = [4, 5]
||<

>|haskell|
init [1, 2, 3] = init (1: (2: (3: [])))
               = 1: init (2: (3: []))
               = 1: (2: init (3: []))
               = 1: (2: [])
               = [1, 2]
||<

***問題3

>|haskell|
and [] = True
and (x : xs) | x == False = False
             | otherwise = and xs
||<

>|haskell|
concat [] = []
concat (xs : xss) = xs ++ concat' xss
||<

concat、最初は間違えた。Hugsで実行しながら修正した。引数の型をちゃんと意識したらできた。

>|haskell|
replicate 0 _ = []
replicate (n + 1) x = x : replicate n x
||<

>|haskell|
(x: _) !! 0 = x
(x: xs) !! (n + 1) = xs !! n
||<

>|haskell|
elem _ [] = False
elem x (y: ys) | x == y    = True
               | otherwise = elem x ys
||<

***問題4

>|haskell|
merge [] xs = xs
merge xs [] = xs
merge (x: xs) (y: ys) | x <= y    = x : merge xs (y: ys)
                      | otherwise = y : merge (x : xs) ys
||<

***問題5
>|haskell|
halve xs = splitAt (length xs `div` 2) xs

msort [] = []
msort [x] = [x]
msort xs = merge (msort fs) (msort ss)
           where (fs, ss) = halve xs
||<

***問題6
5段階の工程は面倒だから省略するけど、型は明示しよう。
>|haskell|
sum :: Num a => [a] -> a
sum [] = 0
sum (x: xs) = x + sum xs
||<

>|haskell|
take :: Integral a => a -> [b] -> [b]
take 0 _ = []
take n [] = []
take (n + 1) (x: xs) = x : take n xs
||<

>|haskell|
last :: [a] -> a
last [x] = x
last (x: xs) = last xs
||<

*1304589921*ここまでのまとめ：ライブラリ関数
ここまで教科書に出てきたライブラリ関数(演算子も含める)をまとめてみる。
教科書の付録Aにはもっと多くの関数が載っている。（付録Aを読んでみたら、ガードのotherwiseはキーワードではなくTrueと評価される定数だった。新しい発見。）

-<code>(+) :: Num a => a -> a -> a</code> 
-<code>(-) :: Num a => a -> a -> a</code> 
-<code>(*) :: Num a => a -> a -> a</code> 
-<code>negate :: Num a => a -> a</code>
-<code>abs :: Num a => a -> a</code>
-<code>signum :: Num a => a -> a</code>
-<code>mod :: Integral a => a -> a -> a</code>
-<code>div :: Integral a => a -> a -> a</code>
-<code>even :: Integral a => a -> Bool</code>
-<code>odd :: Integral a => a -> Bool</code>
-<code>(/) :: Fractional a => a -> a -> a</code>
-<code>recip :: Fractional a => a -> a</code>
-<code>(^) :: (Num a, Integral b) => a -> b -> a</code>
-<code>sum :: Num a => [a] -> a</code>
-<code>product :: Num a => [a] -> a</code>
-<code>(++) :: [a] -> [a] -> [a]</code>
-<code>head :: [a] -> a</code>
-<code>tail :: [a] -> [a]</code>
-<code>(!!) :: [a] -> Int -> a</code>
-<code>take :: Int -> [a] -> [a]</code>
-<code>drop :: Int -> [a] -> [a]</code>
-<code>length :: [a] -> Int</code>
-<code>null :: [a] -> Bool</code>
-<code>reverse :: [a] -> [a]</code>
-<code>init :: [a] -> [a]</code>
-<code>not :: Bool -> Bool</code>
-<code>(&&) :: Bool -> Bool -> Bool</code>
-<code>(||) :: Bool -> Bool -> Bool</code>
-<code>fst :: (a,b) -> a</code>
-<code>snd :: (a,b) -> b</code>
-<code>zip :: [a] -> [b] -> [(a,b)]</code>
-<code>splitAt :: Int -> [a] -> ([a],[a])</code>
-<code>(:) :: a -> [a] -> [a]</code>
-<code>id :: a -> a</code>
-<code>(==) :: Eq a => a -> a -> Bool</code>
-<code>(/=) :: Eq a => a -> a -> Bool</code>
-<code>(<) :: Ord a => a -> a -> Bool</code>
-<code>(<=) :: Ord a => a -> a -> Bool</code>
-<code>(>) :: Ord a => a -> a -> Bool</code>
-<code>(>=) :: Ord a => a -> a -> Bool</code>
-<code>min :: Ord a => a -> a -> a</code>
-<code>max :: Ord a => a -> a -> a</code>
-<code>show :: Show a => a -> String</code>
-<code>read :: Read a => String -> a</code>
-<code>const :: a -> b -> a</code>
-<code>map :: (a -> b) -> [a] -> [b]</code>
-<code>and :: [Bool] -> Bool</code>
-<code>or :: [Bool] -> Bool</code>
-<code>concat :: [ [a] ] -> [a]</code>
-<code>fromIntegral :: (Integral a, Num b) => a -> b</code>
-<code>replicate :: Int -> a -> [a]</code>

**Data.Char
-<code>ord :: Char -> Int</code>
-<code>chr :: Int -> Char</code>
-<code>isDigit :: Char -> Bool</code>
-<code>isLower :: Char -> Bool</code>
-<code>isUpper :: Char -> Bool</code>
-<code>toLower :: Char -> Char</code>
-<code>toUpper :: Char -> Char</code>

*1304565090*第5章 リスト内包表記
C#だとLINQだけど、Haskellなどの関数型言語やPythonではリスト内包。これも書き方さえ覚えてしまえばそんなに難しい話じゃない。
Haskellではforとか書かないので、やっぱり数学っぽい。でもやってることはforと同じ。
>|haskell|
[(x, y) | x <- [1, 2, 3], y <- [4, 5]]
||<
と、リストの中にバー(|)を置いて、右側に生成器を書く。生成器を複数並べると、ネストしたforみたいになる。(最も右側の生成器が最も頻繁に変化するというあたりもforと同じ。)

リスト内包でもワイルドカード(_)が使える。
>|haskell|
first ps = [x | (x, _) <- ps]
||<
でもこれ、ワイルドカードである意味はあるのかな？

>|haskell|
first ps = [x | (x, y) <- ps]
||<
これでも同じじゃないかと思うけど……それとも遅延評価されるかどうかが変わるのだろうか？

**ガード

リスト内包のガードはフィルタになる。LINQでいうところのwhere、Pythonのリスト内包で言うところのif。
Haskellだとカンマ(,)で区切って論理式を書くようだけど、分かりやすいのかこれ？関数定義のガードはバー(|)を伴うけど、リスト内包ではすでにバーを使ってしまっているからカンマ区切りって、なんだかなあ。

>|haskell|
factors n = [x | x <- [1..n], n `mod` x == 0]
||<

書いてしまえば、短くまとまっているけどね。

教科書では、factorsからprime、primeからprimesを作っているので、写経してみる。

>|haskell|
factors n = [x | x <- [1..n], n `mod` x == 0]
prime n = factors n == [1, n]
primes n = [x | x <- [2..n], prime x]
||<

**zip関数

自分で書くとこんな感じか？（復習を兼ねて、cons演算子とパターンマッチで）

>|haskell|
zip' _ [] = []
zip' [] _ = []
zip' xs ys = (head xs, head ys) : zip' (tail xs) (tail ys)
||<

教科書では、zipからpairsを作り、pairsからsortedを作っているので、写経してみる。

>|haskell|
pairs xs = zip xs (tail xs)
sorted xs = and [x <= y | (x, y) <- pairs xs]
||<

なるほど、and関数(とor関数)にはリストを食わせるのか。逆に言うとこいつらは2項演算子じゃないんだな。

**文字列の内包表記

ここで、Stringは[Char]であることが示される。[http://haskell.g.hatena.ne.jp/matarillo/20110429/1304100404:title=気づいてたけど。]

ただし String is a [Char]なのはいいけど、逆はどうなんだろう。つまり、Stringと[Char]は同値なのか？というのが気になったので、試してみた。

>|haskell|
abc :: a -> String
abc _ = ['a', 'b', 'c']
||<
という関数を書いてみたけど普通に使えたので、Stringは[Char]のエイリアスなんだろうと理解した。

**シーザー暗号
これも写経する。

>|haskell|
import Data.Char

table = [8.2, 1.5, 2.8, 4.3, 12.7, 2.2, 2.0, 6.1, 7.0, 0.2, 0.8, 4.0, 2.4,
         6.7, 7.5, 1.9, 0.1,  6.0, 6.3, 9.1, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1]

let2int c = ord c - ord 'a'
int2let n = chr (ord 'a' + n)
shift n c | isLower c = int2let ((let2int c + n) `mod` 26)
          | otherwise = c
encode n xs = [shift n x | x <- xs]

lowers xs = length [x | x <- xs, isLower x]
count x xs = length [x' | x' <- xs, x == x']
percent n m = (fromIntegral n / fromIntegral m) * 100
freqs xs = [percent (count x xs) n | x <- ['a'..'z']]
           where n = lowers xs

chisqr os es = sum [((o - e) ^ 2) / e | (o, e) <- zip os es]
rotate n xs = drop n xs ++ take n xs
positions x xs = [i | (x', i) <- zip xs [0..n], x == x']
                 where n = length xs - 1

crack xs = encode (-factor) xs
           where
             factor = head (positions (minimum chitab) chitab)
             chitab = [chisqr (rotate n table') table | n <- [0..25]]
             table' = freqs xs
||<
うわ、動いた。すごいけど気持ち悪っ！

**演習問題

***問題1
>|haskell|
sum [n^2 | n <- [1..100]]
||<

***問題2
>|haskell|
replicate n x = [x | _ <- [1..n]]
||<

***問題3
>|haskell|
pyths n = [(x, y, z) | x <- [1..n], y <- [1..n], z <- [1..n], x^2 + y^2 == z^2] 
||<

***問題4
>|haskell|
factors n = [x | x <- [1..n], n `mod` x == 0]
perfects n = [x | x <- [1..n], sum (factors x) == 2 * x]
||<

***問題5
>|haskell|
concat [[(x,y) | y <- [4,5,6]] | x <- [1,2,3]]
||<

***問題6
>|haskell|
find k t = [v | (k', v) <- t, k == k']
positions x xs = find x (zip xs [0..n])
                 where n = length xs - 1
||<

***問題7
>|haskell|
scalarproduct xs ys = sum [x * y | (x, y) <- zip xs ys]
||<

***問題8
上記シーザー暗号の差分だけ。面倒だったからmap関数を使ったけど、いいよね。教科書にもさらっと出てきたし。

>|haskell|
let2int' b c = ord c - ord b
int2let' b n = chr (ord b + n)
shift' b n c = int2let' b ((let2int' b c + n) `mod` 26)
shift n c | isLower c = shift' 'a' n c
          | isUpper c = shift' 'A' n c
          | otherwise = c

crack xs = encode (-factor) xs
           where
             factor = head (positions (minimum chitab) chitab)
             chitab = [chisqr (rotate n table') table | n <- [0..25]]
             table' = freqs (map toLower xs)
||<"
2011-05-03,,"*1304414029*第4章 関数定義
**条件式
if 論理式 then 式1 else 式2 の3つ組。ifもthenもelseも関数ではないようだが、3つ組で式となる。
>|haskell|
abs' n = if n >= 0 then n else - n
||<
話はそれるが、この場合の最後のやつは単項演算子に見えるけど、実は2項演算子なのかな。もしそうなら、(-n) = (0 - n) と自動的に置き換えられているのだろうか。

**ガード
論理式で条件分岐。数学っぽいよね。

>|haskell|
abs' n | n >= 0 = n
       | otherwise = - n
||<
これ、改行には特に意味が無いのかな。(Hugsで試してみる)やはり改行には意味が無いようだな。

**パターンマッチ
論理式ではなく、実引数で分岐。
>|haskell|
not' False = True
not' True = False
||<
今度のは改行に意味がある。
>|haskell|
not' False = True not' True = False
-- Error!
||<
と、改行を抜いたらエラーになった。
では、他の関数定義と混ぜたら？
>|haskell|
not' False = True
abs' n = if n >= 0 then n else -n
not' True = False
-- Error!
||<
やはりエラーになった。(「not'が多重定義されている」とのこと。)というわけで、関数定義は1箇所にまとめて書く必要がある。だからこそ、ワイルドカードがきちんと働くのだろう。
>|haskell|
and' True True = True
and' _ _ = False
||<
1行目によってand'の型が<code>Bool -> Bool -> Bool</code>と分かっているので、2行目の定義があるからといって<code>and' ""True"" ""False""</code>みたいな式を書くとエラーになる。
では、型の指定がなかったら？
>|haskell|
true' _ = True
||<
ってやると、ちゃんと多相型 <code>a -> Bool</code>になるから流石だ。

***タプルパターン
>|haskell|
fst (x, _) = x
||<

***リストパターン
>|haskell|
head' [x : _] = x
||<

***n+kパターン
これはコードゴルフ以外には使わないほうがよさそうだ。
>|haskell|
pred 0 = 0
pred (n + 1) = n
||<

**λ式
さすがにこれは、C#にもあるし、JavaScriptにもあるし、すんなり理解できる。
>|haskell|
odds n = map (\x -> x * 2 + 1) [0..n-1]
||<
逆に、下の書き方のほうがまだ馴染んでない。
>|haskell|
odds n = map f [0..n-1]
         where f x = x * 2 + 1
||<

**セクション
演算子を中かっこでくくる(右引数または左引数をふくめてもよい)とセクションになるのはわかった。
>|haskell|
inv = (1/)
||<
とすると、
>|haskell|
inv :: Double -> Double
||<
という関数になる。

**演習問題

***問題1

>|haskell|
halve :: [a] -> ([a],[a])
halve xs = splitAt (length xs `div` 2) xs
||<

***問題2-a

>|haskell|
safetail :: [a] -> [a]
safetail xs = if null xs then [] else tail xs
||<


***問題2-b

>|haskell|
safetail :: [a] -> [a]
safetail xs | null xs = []
            | otherwise = tail xs
||<


***問題2-c

>|haskell|
safetail :: [a] -> [a]
safetail [] = []
safetail xs = tail xs
||<

***問題3-a
ワイルドカードを使わない場合
>|haskell|
(||) :: Bool -> Bool -> Bool
True || True = True
True || False = True
False || True = True
False || False = False
||<


***問題3-b
ワイルドカードを使う場合
>|haskell|
(||) :: Bool -> Bool -> Bool
False || False = False
_ || _ = True
||<


***問題3-c
ワイルドカードと引数を使う場合(ショートサーキット)
>|haskell|
(||) :: Bool -> Bool -> Bool
True || _ = True
False || b = b
||<

4通り……？？教科書にも3通りしか載ってない気がするが。

***問題4
>|haskell|
(&&) :: Bool -> Bool -> Bool
a && b = if a then
           if b then True else False
         else False
||<

***問題5
>|haskell|
(&&) :: Bool -> Bool -> Bool
a && b = if a then b else False
||<


***問題6
>|haskell|
mult = \x -> (\y -> (\z -> x * y * z))
||<",,"*1304414029*第4章 関数定義
**条件式
if 論理式 then 式1 else 式2 の3つ組。ifもthenもelseも関数ではないようだが、3つ組で式となる。
>|haskell|
abs' n = if n >= 0 then n else - n
||<
話はそれるが、この場合の最後のやつは単項演算子に見えるけど、実は2項演算子なのかな。もしそうなら、(-n) = (0 - n) と自動的に置き換えられているのだろうか。

**ガード
論理式で条件分岐。数学っぽいよね。

>|haskell|
abs' n | n >= 0 = n
       | otherwise = - n
||<
これ、改行には特に意味が無いのかな。(Hugsで試してみる)やはり改行には意味が無いようだな。

**パターンマッチ
論理式ではなく、実引数で分岐。
>|haskell|
not' False = True
not' True = False
||<
今度のは改行に意味がある。
>|haskell|
not' False = True not' True = False
-- Error!
||<
と、改行を抜いたらエラーになった。
では、他の関数定義と混ぜたら？
>|haskell|
not' False = True
abs' n = if n >= 0 then n else -n
not' True = False
-- Error!
||<
やはりエラーになった。(「not'が多重定義されている」とのこと。)というわけで、関数定義は1箇所にまとめて書く必要がある。だからこそ、ワイルドカードがきちんと働くのだろう。
>|haskell|
and' True True = True
and' _ _ = False
||<
1行目によってand'の型が<code>Bool -> Bool -> Bool</code>と分かっているので、2行目の定義があるからといって<code>and' ""True"" ""False""</code>みたいな式を書くとエラーになる。
では、型の指定がなかったら？
>|haskell|
true' _ = True
||<
ってやると、ちゃんと多相型 <code>a -> Bool</code>になるから流石だ。

***タプルパターン
>|haskell|
fst (x, _) = x
||<

***リストパターン
>|haskell|
head' [x : _] = x
||<

***n+kパターン
これはコードゴルフ以外には使わないほうがよさそうだ。
>|haskell|
pred 0 = 0
pred (n + 1) = n
||<

**λ式
さすがにこれは、C#にもあるし、JavaScriptにもあるし、すんなり理解できる。
>|haskell|
odds n = map (\x -> x * 2 + 1) [0..n-1]
||<
逆に、下の書き方のほうがまだ馴染んでない。
>|haskell|
odds n = map f [0..n-1]
         where f x = x * 2 + 1
||<

**セクション
演算子を中かっこでくくる(右引数または左引数をふくめてもよい)とセクションになるのはわかった。
>|haskell|
inv = (1/)
||<
とすると、
>|haskell|
inv :: Double -> Double
||<
という関数になる。

**演習問題

***問題1

>|haskell|
halve :: [a] -> ([a],[a])
halve xs = splitAt (length xs `div` 2) xs
||<

***問題2-a

>|haskell|
safetail :: [a] -> [a]
safetail xs = if null xs then [] else tail xs
||<


***問題2-b

>|haskell|
safetail :: [a] -> [a]
safetail xs | null xs = []
            | otherwise = tail xs
||<


***問題2-c

>|haskell|
safetail :: [a] -> [a]
safetail [] = []
safetail xs = tail xs
||<

***問題3-a
ワイルドカードを使わない場合
>|haskell|
(||) :: Bool -> Bool -> Bool
True || True = True
True || False = True
False || True = True
False || False = False
||<


***問題3-b
ワイルドカードを使う場合
>|haskell|
(||) :: Bool -> Bool -> Bool
False || False = False
_ || _ = True
||<


***問題3-c
ワイルドカードと引数を使う場合(ショートサーキット)
>|haskell|
(||) :: Bool -> Bool -> Bool
True || _ = True
False || b = b
||<

4通り……？？教科書にも3通りしか載ってない気がするが。

***問題4
>|haskell|
(&&) :: Bool -> Bool -> Bool
a && b = if a then
           if b then True else False
         else False
||<

***問題5
>|haskell|
(&&) :: Bool -> Bool -> Bool
a && b = if a then b else False
||<


***問題6
>|haskell|
mult = \x -> (\y -> (\z -> x * y * z))
||<"
2011-05-01,,"*1304258593*第3章 型とクラス #2
だんだんそれっぽくなってきた。

**多相型

型の中に型変数を含めることで、任意の型に適用可能な関数を定義できる。これジェネリクスってことかなあ。

教科書に書いてあるlength関数の例は、

>|haskell|
length :: [a] -> Int
||<

なんだけど、C#で言えば、

>|cs|
static int Length<T>(IEnumerable<T> arg);
||<

ってことのようだ。(C#では関数じゃなくてメソッドにするのが普通なので、そのように書いた。)

型変数には小文字を使うそうだ。

**多重定義型

新しい言葉が出てきた。クラスとインスタンス。Haskellでいうクラスはもちろんオブジェクト指向言語のクラスとは違う。クラスのインスタンスは型なのだ。複数の型に共通する何かがクラスということらしい。

その後のところを読むと、どうもJavaやC#でいうところのインターフェースが、Haskellのクラスにちょっと似ている気がする。（でもきっと間違っているのだろう。間違いに気づくのはいつだろうか。）

クラスの話は後回しにして、多重定義型。最初の例が加算演算子<code>+</code>だったので、オーバーロードみたいなこと？と思ったがよく読むと違う。どうも、多層型がジェネリクスだとすれば、多重定義型は型制約のあるジェネリクスのように思える。

Haskellの例は

>|haskell|
(+) :: Num a => a -> a -> a
||<

となっているから、C#だと

>|cs|
static T Add<T>(T x, T y) where T : ICalculatable // ICalculatableインターフェースは今適当にでっち上げた
||<

みたいな。（でもきっと間違っているのだろう。間違いに気づくのはいつだろうか。）

そして、数値も多重定義型っていうのはちょっと驚いたけど納得。だから<code>Int</code>のコンテキストでも<code>Float</code>のコンテキストでも3というリテラル(?)を使えるのだ。C#の場合は数値リテラルの型が決まっていて、暗黙の型変換またはキャストができるという発想。違うもんだね。

**基本クラス

上に書いたように、インターフェースだと思うと何となく納得。

:<code>Eq</code>クラス:<code>IEquatable&lt;T&gt;</code>。
:<code>Ord</code>クラス:<code>IComparable&lt;T&gt;</code>。
:<code>Show</code>クラス:<code>IFormattable</code>。いやちょっと違うか。C#の場合はobject型にToString()メソッドがあるし。
:<code>Read</code>クラス:<code>IConvertible</code>。これもちょっと違うけど。
:<code>Num</code>クラス:C#にはこれに当たる型はない。組み込みの数値型には最初から演算子が定義されている。
:<code>Integral</code>クラス:C#にはこれに当たる型はない。組み込みの数値型には最初から演算子が定義されている。
:<code>Fractional</code>クラス:C#にはこれに当たる型はない。組み込みの数値型には最初から演算子が定義されている。

<code>div</code> と <code>(/)</code>の使い分けに注意かな。

**練習問題

***練習問題1

-<code>['a', 'b', 'c'] :: [Char]</code>
-<code>('a', 'b', 'c') :: (Char, Char, Char)</code>
-<code>[(False, 'o'), (True, '1')] :: [(Bool, Char)]</code>
-<code>([False, True], ['0', '1']) :: ([Bool], [Char])</code>
-<code>[tail, init, reverse] :: [ [a] ]</code>かな？init関数は教科書に出てきてないぞ。
--Hugsで見てみた。おっと、関数だったのは分かってたはずなのに書きそこねた。<code>[tail, init, reverse] :: [ [a] -> [a] ]</code>だね。

***練習問題2

-<code>second xs = head (tail xs) :: [a] -> a</code>
-<code>swap(x, y) = (y, x) :: (a, b) -> (b, a)</code>
-<code>pair x y = (x, y) :: a -> b -> (a, b)</code>
-<code>double x = x * 2 :: Num a => a -> a</code>
-<code>palindrome xs = reverse xs == xs :: Eq a => [a] -> Bool</code>
--リストはそもそもEqクラスなのかな？と思ってよく読み返してみたら、要素がEqクラスならリストもEqクラスということのようだ。
-<code>twice f x = f (f x) :: (a -> a) -> a -> a</code>
--これ少し難しいな。

***練習問題3

Hugsで見てみた。演習問題1の最後の以外は合ってた！

それにしても、Haskellの型推論はすごいな。

***練習問題4

一般的に関数の型をEqクラスのインスタンスにするのが実現不可能な理由？それって停止問題みたいなことかなあ。わからんからまた明日考える。",,"*1304258593*第3章 型とクラス #2
だんだんそれっぽくなってきた。

**多相型

型の中に型変数を含めることで、任意の型に適用可能な関数を定義できる。これジェネリクスってことかなあ。

教科書に書いてあるlength関数の例は、

>|haskell|
length :: [a] -> Int
||<

なんだけど、C#で言えば、

>|cs|
static int Length<T>(IEnumerable<T> arg);
||<

ってことのようだ。(C#では関数じゃなくてメソッドにするのが普通なので、そのように書いた。)

型変数には小文字を使うそうだ。

**多重定義型

新しい言葉が出てきた。クラスとインスタンス。Haskellでいうクラスはもちろんオブジェクト指向言語のクラスとは違う。クラスのインスタンスは型なのだ。複数の型に共通する何かがクラスということらしい。

その後のところを読むと、どうもJavaやC#でいうところのインターフェースが、Haskellのクラスにちょっと似ている気がする。（でもきっと間違っているのだろう。間違いに気づくのはいつだろうか。）

クラスの話は後回しにして、多重定義型。最初の例が加算演算子<code>+</code>だったので、オーバーロードみたいなこと？と思ったがよく読むと違う。どうも、多層型がジェネリクスだとすれば、多重定義型は型制約のあるジェネリクスのように思える。

Haskellの例は

>|haskell|
(+) :: Num a => a -> a -> a
||<

となっているから、C#だと

>|cs|
static T Add<T>(T x, T y) where T : ICalculatable // ICalculatableインターフェースは今適当にでっち上げた
||<

みたいな。（でもきっと間違っているのだろう。間違いに気づくのはいつだろうか。）

そして、数値も多重定義型っていうのはちょっと驚いたけど納得。だから<code>Int</code>のコンテキストでも<code>Float</code>のコンテキストでも3というリテラル(?)を使えるのだ。C#の場合は数値リテラルの型が決まっていて、暗黙の型変換またはキャストができるという発想。違うもんだね。

**基本クラス

上に書いたように、インターフェースだと思うと何となく納得。

:<code>Eq</code>クラス:<code>IEquatable&lt;T&gt;</code>。
:<code>Ord</code>クラス:<code>IComparable&lt;T&gt;</code>。
:<code>Show</code>クラス:<code>IFormattable</code>。いやちょっと違うか。C#の場合はobject型にToString()メソッドがあるし。
:<code>Read</code>クラス:<code>IConvertible</code>。これもちょっと違うけど。
:<code>Num</code>クラス:C#にはこれに当たる型はない。組み込みの数値型には最初から演算子が定義されている。
:<code>Integral</code>クラス:C#にはこれに当たる型はない。組み込みの数値型には最初から演算子が定義されている。
:<code>Fractional</code>クラス:C#にはこれに当たる型はない。組み込みの数値型には最初から演算子が定義されている。

<code>div</code> と <code>(/)</code>の使い分けに注意かな。

**練習問題

***練習問題1

-<code>['a', 'b', 'c'] :: [Char]</code>
-<code>('a', 'b', 'c') :: (Char, Char, Char)</code>
-<code>[(False, 'o'), (True, '1')] :: [(Bool, Char)]</code>
-<code>([False, True], ['0', '1']) :: ([Bool], [Char])</code>
-<code>[tail, init, reverse] :: [ [a] ]</code>かな？init関数は教科書に出てきてないぞ。
--Hugsで見てみた。おっと、関数だったのは分かってたはずなのに書きそこねた。<code>[tail, init, reverse] :: [ [a] -> [a] ]</code>だね。

***練習問題2

-<code>second xs = head (tail xs) :: [a] -> a</code>
-<code>swap(x, y) = (y, x) :: (a, b) -> (b, a)</code>
-<code>pair x y = (x, y) :: a -> b -> (a, b)</code>
-<code>double x = x * 2 :: Num a => a -> a</code>
-<code>palindrome xs = reverse xs == xs :: Eq a => [a] -> Bool</code>
--リストはそもそもEqクラスなのかな？と思ってよく読み返してみたら、要素がEqクラスならリストもEqクラスということのようだ。
-<code>twice f x = f (f x) :: (a -> a) -> a -> a</code>
--これ少し難しいな。

***練習問題3

Hugsで見てみた。演習問題1の最後の以外は合ってた！

それにしても、Haskellの型推論はすごいな。

***練習問題4

一般的に関数の型をEqクラスのインスタンスにするのが実現不可能な理由？それって停止問題みたいなことかなあ。わからんからまた明日考える。"
2011-04-30,,"*1304151012*Haskell学習の目標
とりあえずの目標は、[http://d.hatena.ne.jp/rst76/20100706/1278430517:title]を全部理解できるようになること。

今日、UnitとBindはモナドに関係しているということを知った。

[http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx:title]

教科書(プログラミングHaskell)はまだぜんぜん最初のほうで、モナドが出てくるのはまだ先の話だけど。",,"*1304151012*Haskell学習の目標
とりあえずの目標は、[http://d.hatena.ne.jp/rst76/20100706/1278430517:title]を全部理解できるようになること。

今日、UnitとBindはモナドに関係しているということを知った。

[http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx:title]

教科書(プログラミングHaskell)はまだぜんぜん最初のほうで、モナドが出てくるのはまだ先の話だけど。"
2011-04-29,,"*1304100404*第3章 型とクラス #1
さて、そろそろHaskellらしいところに入ってきたかな。

型を示すには、<code>式 :: 型</code> と書く。

なんだか、いきなり前振りなしで「評価されていない式」って言葉が出てきた。Haskellの遅延評価のことを言っているのかもしれないが、唐突すぎるだろ。この本のこういう所は嫌だな。

Hugsの<code>:type</code>コマンドを学んだ！
Hugsの<code>:load</code>コマンドが、プログラム中では<code>import</code>と同じということを学んだ！

-<code>Bool</code>型
--真偽値。<code>True</code>と<code>False</code>。
-<code>Char</code>型
--文字。シングルクォート。
-<code>String</code>型
--文字列。ダブルクォート。
-<code>Int</code>型
--固定精度整数。普通の32ビット符号付き整数。オーバーフローに注意。
-<code>Integer</code>型
--多倍長整数。
---これ必要だよね。C#には長らくなかった。([http://msdn.microsoft.com/ja-jp/library/system.numerics.biginteger.aspx:title=.NET 4から標準ライブラリに入った])
-<code>Float</code>型
--単精度浮動小数点数。普通の32ビットIEEE 754浮動小数点数。
---だとすればNaN、+∞、-∞も値に含まれるはず。あとで出てくるかな？
-<code>[T]</code>型
--T型のリスト。遅延評価されるので無限リストもOK。
---Hugsで<code>:type [""a"",""b""]</code>って入れたら<code>[ [Char] ]</code>って返ってきた……たぶんStringは[Char]でもあるんだろうけど。
-<code>(T1, T2,...,Tn)</code>型
--タプル。要素は必ず有限。
---要素0のタプルはunit。
---要素1のタプルは禁止。
-<code>Tin→Tout</code>型
--関数。定義域が制限されていてもOK。
---<code>→</code>を複数並べると、カリー化された関数を表す。<code>→</code>は右結合だから<code>T1→T2→T3</code>は<code>T1→(T2→T3)</code>と違いがない。
---ただし<code>(T1→T2)→T3</code>は違う型。こっちは関数を引数に取る関数になる。
---カリー化されていない多変数関数を定義したい場合はタプルを使って<code>(T1,T2,...,Tn)→Tout</code>とやってもいいが、カリー化された関数のほうが柔軟。
---0引数の関数は、遅延評価される値と違いがないので、<code>→T</code>という型の関数はない。<code>T</code>型があるだけ。
---<code>()→T</code>という型は定義できるが、unitを引数に取るので0引数にはならない。(Hugsで試した。)
---たぶん<code>T→</code>のような戻り値がない関数も定義できないのではないだろうか。何らかの意味のない値(たとえばunit)を返すようにするとか。

*1304094908*第2章 はじめの一歩
処理系としては、Haskell Platform 2011.2.0.1 および WinHugs をインストールしてある。

最初、test.hsをロードしようとしてエラーが出て困った。
>||
ERROR file:test.hs:1 - Syntax error in declaration (unexpected symbol ""x"")
||<
ちょっとぐぐったら原因判明。文字コードがBOMつきUTF-8だったのが問題だったらしい。基本的にはANSIまたはBOMなしUTF-8じゃないといけないようだ。ま、BOMつきUTF-8なんて使うドザが悪いというのはあるけど、それにしてもOSSの文字コードの扱いはいろいろ良くないところがあるよね。

><dl>
<dt>練習問題1</dt><dd><ul>
<li>2^3*4 = (2^3)*4 = 32</li>
<li>2*3+4*5=(2*3)+(4*5) = 26</li>
<li>2+3*4^5=2+(3*(4^5)) = 3074</li>
</ul></dd>
<dt>練習問題2</dt><dd>もちろんHugsでやってる。</dd>
<dt>練習問題3</dt><dd>
<pre>N = a `div` length xs
    where
      a = 10
     xs = [1,2,3,4,5]
</pre><br />
実行してみたらエラーメッセージで分かるだろう。<ul>
<li><code>Syntax error in input (unexpected symbol ""xs"")</code><br />
たぶんxsのインデントが悪い。空白を追加。</li>
<li><code>Undefined data constructor ""N""</code><br />
Nが大文字だからエラーになっているっぽい。小文字にしてみる。</li>
</ul>あれ、エラー消えちゃった。引数なしの関数nを表示してみたら2って出るし。関数にするのは良くなかった？でもデータコンストラクタとか、まだ教科書に出てきてないぞ。<br />
……もう一度問題文を見たら、'div'って書いてある。ここが間違いだったらしい。正しくはバッククォートを用いて`div`とやる（上では最初から`div`と書いてしまっていた）。
</dl><

*1304064809*プログラミングHaskellを買った
asin:4274067815:detail

これから勉強していく。

まずは第1章を読んだ。が、プログラムなんだか数学なんだか。いきなりリストが出てきているし。qsortの定義は擬似コードなのか実コードなのかわからない。

:練習問題1:なんだこれ。外側のdoubleを適用した後2番目のdoubleを適用する、でいいのか？(内側のdoubleから適用するのと、外側のdoubleを適用した後1番目のdoubleを適用するのは、本文中に出てきたので)
:練習問題2:<code>sum [x] = x + sum [ ] = x</code>
:練習問題3:<code>qsort larger ++ [x] ++ qsort smaller</code>ってする。
:練習問題4:ピボットと同じ値が捨てられてしまう。<code>qsort [2,2,3,1,1] = qsort [1, 1] ++ [2] ++ qsort [3] = (qsort [ ] ++ [1] ++ qsort [ ]) ++ [2] ++ (qsort [ ] ++ [3] ++ qsort [ ]) = [1, 2, 3]</code>ってなる。つまり、ピボットとか関係なしに、sortしてuniqしたことになりそうだな。証明は……面倒くさい。",,"*1304100404*第3章 型とクラス #1
さて、そろそろHaskellらしいところに入ってきたかな。

型を示すには、<code>式 :: 型</code> と書く。

なんだか、いきなり前振りなしで「評価されていない式」って言葉が出てきた。Haskellの遅延評価のことを言っているのかもしれないが、唐突すぎるだろ。この本のこういう所は嫌だな。

Hugsの<code>:type</code>コマンドを学んだ！
Hugsの<code>:load</code>コマンドが、プログラム中では<code>import</code>と同じということを学んだ！

-<code>Bool</code>型
--真偽値。<code>True</code>と<code>False</code>。
-<code>Char</code>型
--文字。シングルクォート。
-<code>String</code>型
--文字列。ダブルクォート。
-<code>Int</code>型
--固定精度整数。普通の32ビット符号付き整数。オーバーフローに注意。
-<code>Integer</code>型
--多倍長整数。
---これ必要だよね。C#には長らくなかった。([http://msdn.microsoft.com/ja-jp/library/system.numerics.biginteger.aspx:title=.NET 4から標準ライブラリに入った])
-<code>Float</code>型
--単精度浮動小数点数。普通の32ビットIEEE 754浮動小数点数。
---だとすればNaN、+∞、-∞も値に含まれるはず。あとで出てくるかな？
-<code>[T]</code>型
--T型のリスト。遅延評価されるので無限リストもOK。
---Hugsで<code>:type [""a"",""b""]</code>って入れたら<code>[ [Char] ]</code>って返ってきた……たぶんStringは[Char]でもあるんだろうけど。
-<code>(T1, T2,...,Tn)</code>型
--タプル。要素は必ず有限。
---要素0のタプルはunit。
---要素1のタプルは禁止。
-<code>Tin→Tout</code>型
--関数。定義域が制限されていてもOK。
---<code>→</code>を複数並べると、カリー化された関数を表す。<code>→</code>は右結合だから<code>T1→T2→T3</code>は<code>T1→(T2→T3)</code>と違いがない。
---ただし<code>(T1→T2)→T3</code>は違う型。こっちは関数を引数に取る関数になる。
---カリー化されていない多変数関数を定義したい場合はタプルを使って<code>(T1,T2,...,Tn)→Tout</code>とやってもいいが、カリー化された関数のほうが柔軟。
---0引数の関数は、遅延評価される値と違いがないので、<code>→T</code>という型の関数はない。<code>T</code>型があるだけ。
---<code>()→T</code>という型は定義できるが、unitを引数に取るので0引数にはならない。(Hugsで試した。)
---たぶん<code>T→</code>のような戻り値がない関数も定義できないのではないだろうか。何らかの意味のない値(たとえばunit)を返すようにするとか。

*1304094908*第2章 はじめの一歩
処理系としては、Haskell Platform 2011.2.0.1 および WinHugs をインストールしてある。

最初、test.hsをロードしようとしてエラーが出て困った。
>||
ERROR file:test.hs:1 - Syntax error in declaration (unexpected symbol ""x"")
||<
ちょっとぐぐったら原因判明。文字コードがBOMつきUTF-8だったのが問題だったらしい。基本的にはANSIまたはBOMなしUTF-8じゃないといけないようだ。ま、BOMつきUTF-8なんて使うドザが悪いというのはあるけど、それにしてもOSSの文字コードの扱いはいろいろ良くないところがあるよね。

><dl>
<dt>練習問題1</dt><dd><ul>
<li>2^3*4 = (2^3)*4 = 32</li>
<li>2*3+4*5=(2*3)+(4*5) = 26</li>
<li>2+3*4^5=2+(3*(4^5)) = 3074</li>
</ul></dd>
<dt>練習問題2</dt><dd>もちろんHugsでやってる。</dd>
<dt>練習問題3</dt><dd>
<pre>N = a `div` length xs
    where
      a = 10
     xs = [1,2,3,4,5]
</pre><br />
実行してみたらエラーメッセージで分かるだろう。<ul>
<li><code>Syntax error in input (unexpected symbol ""xs"")</code><br />
たぶんxsのインデントが悪い。空白を追加。</li>
<li><code>Undefined data constructor ""N""</code><br />
Nが大文字だからエラーになっているっぽい。小文字にしてみる。</li>
</ul>あれ、エラー消えちゃった。引数なしの関数nを表示してみたら2って出るし。関数にするのは良くなかった？でもデータコンストラクタとか、まだ教科書に出てきてないぞ。<br />
……もう一度問題文を見たら、'div'って書いてある。ここが間違いだったらしい。正しくはバッククォートを用いて`div`とやる（上では最初から`div`と書いてしまっていた）。
</dl><

*1304064809*プログラミングHaskellを買った
asin:4274067815:detail

これから勉強していく。

まずは第1章を読んだ。が、プログラムなんだか数学なんだか。いきなりリストが出てきているし。qsortの定義は擬似コードなのか実コードなのかわからない。

:練習問題1:なんだこれ。外側のdoubleを適用した後2番目のdoubleを適用する、でいいのか？(内側のdoubleから適用するのと、外側のdoubleを適用した後1番目のdoubleを適用するのは、本文中に出てきたので)
:練習問題2:<code>sum [x] = x + sum [ ] = x</code>
:練習問題3:<code>qsort larger ++ [x] ++ qsort smaller</code>ってする。
:練習問題4:ピボットと同じ値が捨てられてしまう。<code>qsort [2,2,3,1,1] = qsort [1, 1] ++ [2] ++ qsort [3] = (qsort [ ] ++ [1] ++ qsort [ ]) ++ [2] ++ (qsort [ ] ++ [3] ++ qsort [ ]) = [1, 2, 3]</code>ってなる。つまり、ピボットとか関係なしに、sortしてuniqしたことになりそうだな。証明は……面倒くさい。"
